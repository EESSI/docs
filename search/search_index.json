{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the EESSI project documentation!","text":"<p>Quote</p> <p>What if there was a way to avoid having to install a broad range of scientific software from scratch on every HPC cluster or cloud instance you use or maintain, without compromising on performance?</p> <p>The European Environment for Scientific Software Installations (EESSI, pronounced as \"easy\") is a collaboration between different European partners in HPC community. The goal of this project is to build a common stack of scientific software installations for HPC systems and beyond, including laptops, personal workstations and cloud infrastructure.</p>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>What is EESSI?</li> <li>Contact info</li> <li>Governance</li> </ul> <p>For users:</p> <ul> <li><code>software.eessi.io</code> repository</li> <li>Access, initialize and use EESSI</li> <li>Overview of software</li> <li>How to run EESSI test suite</li> <li>How to use EESSI in CI<ul> <li>GitHub Actions</li> <li>GitLab CI/CD</li> </ul> </li> <li>Get help or report issue</li> </ul> <p>For system administrators:</p> <ul> <li>EESSI layered structure: filesystem, compatibility, software</li> <li>Installing EESSI</li> <li>Setting up a mirror server</li> </ul> <p>For contributors:</p> <ul> <li>Adding software to EESSI</li> <li>Meetings</li> </ul> <p>The EESSI project was covered during a quick AWS HPC Tech Short video (15 June 2023):</p>"},{"location":"bot/","title":"Build-test-deploy bot","text":"<p>Building, testing, and deploying software is done by one or more bot instances.</p> <p>The EESSI build-test-deploy bot  is implemented as a GitHub App in the <code>eessi-bot-software-layer</code> repository.</p> <p>It operates in the context of pull requests to the <code>compatibility-layer</code> repository or the <code>software-layer</code> repository, and follows the instructions supplied by humans, so the procedure of adding software to EESSI is semi-automatic.</p> <p>It leverages the scripts provided in the <code>bot/</code> subdirectory of the target repository (see for example here), like <code>bot/build.sh</code> to build software, and <code>bot/check-result.sh</code> to check whether the software was built correctly.</p>"},{"location":"bot/#high-level-design","title":"High-level design","text":"<p>The bot  consists of two components: the event handler, and the job manager.</p>"},{"location":"bot/#event-handler","title":"Event handler","text":"<p>The bot event handler is responsible for handling GitHub events for the GitHub repositories it is registered to.</p> <p>It is triggered for every event that it receives from GitHub. Most events are ignored, but specific events trigger the bot to take action.</p> <p>Examples of actionable events are submitting of a comment that starts with <code>bot:</code>, which may specify an instruction for the bot like building software, or adding a <code>bot:deploy</code> label (see deploying).</p>"},{"location":"bot/#job-manager","title":"Job manager","text":"<p>The bot job manager is responsible for monitoring the queued and running jobs, and reporting back when jobs completed.</p> <p>It runs every couple of minutes as a cron job.</p>"},{"location":"bot/#basics","title":"Basics","text":"<p>Instructions for the bot  should always start with <code>bot:</code>.</p> <p>To get help from the bot, post a comment with <code>bot: help</code>.</p> <p>To make the bot report how it is configured, post a comment with <code>bot: show_config</code>.</p>"},{"location":"bot/#permissions","title":"Permissions","text":"<p>The bot  is configured to only act on instructions issued by specific GitHub accounts.</p> <p>There are separate configuration options for allowing to send instructions to the bot, to trigger building of software, and to deploy software installations in to the EESSI repository.</p> <p>Note</p> <p>Ask for help in the <code>#software-layer-bot</code> channel of the EESSI Slack if needed!</p>"},{"location":"bot/#building","title":"Building","text":"<p>To instruct the bot  to build software, one or more <code>build</code> instructions should be issued by posting a comment in the pull request (see also here).</p> <p>The most basic build instruction that can be sent to the bot is:</p> <pre><code>bot: build\n</code></pre> <p>Warning</p> <p>Only use <code>bot: build</code> if you are confident that it is OK to do so.</p> <p>Most likely, you want to supply one or more filters to avoid that the bot builds for all its configurations.</p>"},{"location":"bot/#filters","title":"Filters","text":"<p>Build instructions can include filters that are applied by each bot instance to determine which builds should be executed, based on:</p> <ul> <li><code>instance</code>: the <code>name</code> of the bot instance, for example <code>instance:aws</code> for the bot instance running in AWS;</li> <li><code>repository</code>: the target repository, for example <code>eessi-2023.06-software</code> which corresponds to the 2023.06 version of the EESSI software layer;</li> <li><code>architecture</code>: the name of the CPU microarchitecture, for example <code>x86_64/amd/zen2</code>;</li> </ul> <p>Note</p> <p>Use <code>:</code> as separator to specify a value for a particular filter, do not add spaces after the <code>:</code>.</p> <p>The bot recognizes shorthands for the supported filters, so you can use <code>inst:...</code> instead of <code>instance:...</code>, <code>repo:...</code> instead of <code>repository:...</code>, and <code>arch:...</code> instead of <code>architecture:...</code>.</p>"},{"location":"bot/#combining-filters","title":"Combining filters","text":"<p>You can combine multiple filters in a single <code>build</code> instruction. Separate filters with a space, order of filters does not matter.</p> <p>For example:</p> <pre><code>bot: build repo:eessi-hpc.org-2023.06-software arch:x86_64/amd/zen2\n</code></pre>"},{"location":"bot/#multiple-build-instructions","title":"Multiple build instructions","text":"<p>You can issue multiple build instructions in a single comment, even across multiple bot instances, repositories, and CPU targets. Specify one build instruction per line.</p> <p>For example:</p> <pre><code>bot: build repo:eessi-hpc.org-2023.06-software arch:x86_64/amd/zen3 inst:aws\nbot: build repo:eessi-hpc.org-2023.06-software arch:aarch64/generic inst:azure\n</code></pre> <p>Note</p> <p>The bot applies the filters with partial matching, which you can use to combine multiple build instructions into a single one.</p> <p>For example, if you only want to build for all <code>aarch64</code> CPU targets, you can use <code>arch:aarch64</code> as filter.</p> <p>The same applies to the <code>instance</code> and <code>repository</code> filters.</p>"},{"location":"bot/#behind-the-scenes","title":"Behind-the-scenes","text":""},{"location":"bot/#processing-build-instructions","title":"Processing build instructions","text":"<p>When the bot receives build instructions through a comment in a pull request, they are processed by the event handler component. It will:</p> <p>1) Combine its active configuration (instance name, repositories, supported CPU targets)    and the build instructions to prepare a list of jobs to submit;</p> <p>2) Create a working directory for each job, including a Slurm job script that    runs the <code>bot/build.sh</code> script in the context of the changes proposed in the pull request to build the    software, and runs <code>bot/check-result.sh</code> script at the end to check whether the build was successful;</p> <p>3) Submit each prepared job to a workernode that can build for the specified CPU target, and put a hold on it.</p>"},{"location":"bot/#managing-build-jobs","title":"Managing build jobs","text":"<p>During the next iteration of the job manager, the submitted jobs are released and queued for execution.</p> <p>The job manager also monitors the running jobs at regular intervals, and reports back in the pull request when a job has completed. It also reports the result (<code>SUCCESS</code>  or <code>FAILURE</code> ), based on the result of the <code>bot/check-result.sh</code> script.</p>"},{"location":"bot/#artefacts","title":"Artefacts","text":"<p>If all goes well, each job should produce a tarball as an artefact, which contains the software installations and the corresponding environment module files.</p> <p>The message reported by the job manager provides an overview of the contents of the artefact, which was created by the <code>bot/check-result.sh</code> script.</p>"},{"location":"bot/#testing","title":"Testing","text":"<p>Warning</p> <p>The test phase is not implemented yet in the bot.</p> <p>We intend to use the EESSI test suite in different OS configurations to verify that the software that was built works as expected.</p>"},{"location":"bot/#deploying","title":"Deploying","text":"<p>To deploy the artefacts that were obtained in the build phase, you should add the <code>bot: deploy</code> label to the pull request.</p> <p>This will trigger the event handler to upload the artefacts for ingestion into the EESSI repository.</p>"},{"location":"bot/#behind-the-scenes_1","title":"Behind-the-scenes","text":"<p>The current setup for the software-layer repository, is as follows:</p> <ul> <li>The bot deploys the artefacts (tarballs) to an S3 bucket in AWS, along with a metadata file, using the   <code>eessi-upload-to-staging</code> script;</li> <li>A cron job that runs every couple of minutes on the CernVM-FS Stratum-0 server opens a pull request to   the (private) EESSI/staging repository, to move the metadata file for   each uploaded tarball from the <code>staged</code> to the <code>approved</code> directory;</li> <li>Once that pull request gets merged, the target is automatically ingested into the EESSI repository by a cron job   on the Stratum-0 server, and the metadata file is moved from <code>approved</code> to <code>ingested</code> in the <code>EESSI/staging</code> repository;</li> </ul>"},{"location":"compatibility_layer/","title":"Compatibility layer","text":"<p>The middle layer of the EESSI project is the compatibility layer, which ensures that our scientific software stack is compatible with different client operating systems (different Linux distributions, macOS and even Windows via WSL).</p> <p>For this we rely on Gentoo Prefix, by installing a limited set of Gentoo Linux packages in a non-standard location (a \"prefix\"), using Gentoo's package manager Portage.</p> <p>The compatible layer is maintained via our https://github.com/EESSI/compatibility-layer GitHub repository.</p>"},{"location":"contact/","title":"Contact info","text":"<p>For more information:</p> <ul> <li>Visit our website</li> <li>Consult our documentation</li> <li>Ask for help at our support portal</li> <li>Join our Slack channel</li> <li>Reach out to one of the project partners</li> <li>Check out our GitHub repositories</li> <li>Follow us on Twitter</li> </ul> <p></p>"},{"location":"filesystem_layer/","title":"Filesystem layer","text":""},{"location":"filesystem_layer/#cernvm-file-system-cernvm-fs","title":"CernVM File System (CernVM-FS)","text":"<p>The bottom layer of the EESSI project is the filesystem layer, which is responsible for distributing the software stack.</p> <p>For this we rely on CernVM-FS (or CVMFS for short), a network file system used to distribute the software to the clients in a fast, reliable and scalable way.</p> <p>CVMFS was created over 10 years ago specifically for the purpose of globally distributing a large software stack. For the experiments at the Large Hadron Collider, it hosts several hundred million files and directories that are distributed to the order of hundred thousand client computers.</p> <p></p> <p>The hierarchical structure with multiple caching layers (Stratum-0, Stratum-1's located at partner sites and local caching proxies) ensures good performance with limited resources. Redundancy is provided by using multiple Stratum-1's at various sites. Since CVMFS is based on the HTTP protocol, the ubiquitous Squid caching proxy can be leveraged to reduce server loads and improve performance at large installations (such as HPC clusters). Clients can easily mount the file system (read-only) via a FUSE (Filesystem in Userspace) module.</p> <p>For a (basic) introduction to CernVM-FS, see this presentation.</p> <p>Detailed information about how we configure CVMFS is available at https://github.com/EESSI/filesystem-layer.</p>"},{"location":"filesystem_layer/#eessi-infrastructure","title":"EESSI infrastructure","text":"<p>For both the pilot and production repositories, EESSI hosts a CernVM-FS Stratum 0 and a number of public Stratum 1 servers. Client systems using EESSI by default connect against the public EESSI CernVM-FS Stratum 1 servers. The status of the infrastructure for the pilot repository is displayed at http://status.eessi-infra.org, while for the production repository it is displayed at https://status.eessi.io.</p>"},{"location":"governance/","title":"EESSI Governance","text":"<p>EESSI recognises that formal governance is essential given the ambitions of the project, not just for EESSI itself but also to those who would adopt EESSI and/or fund its development.</p> <p>EESSI is, therefore, in the process of adopting a formal governance model. To facilitate this process it has created an Interim Steering Committee whose role is to progress this adoption while also providing direction to the project.</p>"},{"location":"governance/#members-of-the-interim-steering-committee","title":"Members of the Interim Steering Committee","text":"<p>The members of the Interim Steering Committee are listed below. Each member of the Interim Steering Committee also nominate an alternate should they not be able to attend a meeting of the committee.</p> <ul> <li>Interim Steering Committee Lead: Kenneth Hoste (Ghent University), @boegel<ul> <li>Alternate: Lara Peeters (Ghent University),  @laraPPr</li> </ul> </li> <li>Alan O'Cais (CECAM, University of Barcelona),  @ocaisa<ul> <li>Alternate: Davide Grassano (CECAM),  @crivella</li> </ul> </li> <li>Bob Dr\u00f6ge (University of Groningen),  @bedroge<ul> <li>Alternate: Henk-Jan Zilverberg (University of Groningen),  @zilverberg</li> </ul> </li> <li>Caspar van Leeuwen (SURF),  @casparvl<ul> <li>Alternate: Satish Kamath (SURF),  @satishskamath</li> </ul> </li> <li>Thomas R\u00f6blitz (University of Bergen), @trz42<ul> <li>Alternate: Terje Kvernes (University of Oslo),  @terjekv</li> </ul> </li> </ul>"},{"location":"meetings/","title":"Meetings","text":""},{"location":"meetings/#monthly-meetings-online","title":"Monthly meetings (online)","text":"<p>Online EESSI update meeting, every 1st Thursday of the month at 14:00 CE(S)T.</p> <p>More info can be found on the EESSI wiki.</p>"},{"location":"meetings/#physical-meetings","title":"Physical meetings","text":"<ul> <li>EESSI Community Meeting in Amsterdam (NL), 14-16 Sept 2022</li> </ul>"},{"location":"meetings/#physical-meetings-archive","title":"Physical meetings (archive)","text":""},{"location":"meetings/#2020","title":"2020","text":"<ul> <li>Meeting in Groningen (NL), 16 Jan 2020</li> <li>Meeting in Delft (NL), 5 Mar 2020</li> </ul>"},{"location":"meetings/#2019","title":"2019","text":"<ul> <li>Meeting in Cambridge (UK), 20-21 May 2019</li> </ul>"},{"location":"overview/","title":"Overview of the EESSI project","text":""},{"location":"overview/#scope-goals","title":"Scope &amp; Goals","text":"<p>Through the EESSI project, we want to set up a shared stack of scientific software installations, and by doing so avoid a lot of duplicate work across HPC sites.</p> <p>For end users, we want to provide a uniform user experience with respect to available scientific software, regardless of which system they use.</p> <p>Our software stack should work on laptops, personal workstations, HPC clusters and in the cloud, which means we will need to support different CPUs, networks, GPUs, and so on. We hope to make this work for any Linux distribution and maybe even macOS and Windows via WSL, and a wide variety of CPU architectures (Intel, AMD, ARM, POWER, RISC-V).</p> <p>Of course we want to focus on the performance of the software, but also on automating the workflow for maintaining the software stack, thoroughly testing the installations, and collaborating efficiently.</p>"},{"location":"overview/#inspiration","title":"Inspiration","text":"<p>The EESSI concept is heavily inspired by Compute Canada software stack, which is a shared software stack used on all 5 major national systems in Canada and a bunch of smaller ones.</p> <p>The design of the Compute Canada software stack is discussed in detail in the PEARC'19 paper \"Providing a Unified Software Environment for Canada\u2019s National Advanced Computing Centers\".</p> <p>It has also been presented at the 5th EasyBuild User Meetings (slides, recorded talk), and is well documented.</p>"},{"location":"overview/#layered-structure","title":"Layered structure","text":"<p>The EESSI project consists of 3 layers.</p> <p></p> <p>The bottom layer is the filesystem layer, which is responsible for distributing the software stack across clients.</p> <p>The middle layer is a compatibility layer, which ensures that the software stack is compatible with multiple different client operating systems.</p> <p>The top layer is the software layer, which contains the actual scientific software applications and their dependencies.</p> <p>The host OS still provides a couple of things, like drivers for network and GPU, support for shared filesystems like GPFS and Lustre, a resource manager like Slurm, and so on.</p>"},{"location":"overview/#opportunities","title":"Opportunities","text":"<p>We hope to collaborate with interested parties across the HPC community, including HPC centres, vendors, consultancy companies and scientific software developers.</p> <p>Through our software stack, HPC users can seamlessly hop between sites, since the same software is available everywhere.</p> <p>We can leverage each others work with respect to providing tested and properly optimized scientific software installations more efficiently, and provide a platform for easy benchmarking of new systems.</p> <p>By working together with the developers of scientific software we can provide vetted installations for the broad HPC community.</p>"},{"location":"overview/#challenges","title":"Challenges","text":"<p>There are many challenges in an ambitious project like this, including (but probably not limited to):</p> <ul> <li>Finding time and manpower to get the software stack set up properly;</li> <li>Leveraging system sources like network interconnect (MPI &amp; co), accelerators (GPUs), ...;</li> <li>Supporting CPU architectures other than x86_64, including ARM, POWER, RISC-V, ...</li> <li>Dealing with licensed software, like Intel tools, MATLAB, ANSYS, ...;</li> <li>Integration with resource managers (Slurm) and vendor provided software (Cray PE);</li> <li>Convincing HPC site admins to adopt EESSI;</li> </ul>"},{"location":"overview/#current-status","title":"Current status","text":"<p>(June 2020)</p> <p>We are actively working on the EESSI repository, and are organizing monthly meetings to discuss progress and next steps forward.</p> <p>Keep an eye on our GitHub repositories at https://github.com/EESSI and our Twitter feed.</p>"},{"location":"partners/","title":"Project partners","text":""},{"location":"partners/#delft-university-of-technology-the-netherlands","title":"Delft University of Technology (The Netherlands)","text":"<ul> <li>Robbert Eggermont</li> <li>Koen Mulderij</li> </ul>"},{"location":"partners/#dell-technologies-europe","title":"Dell Technologies (Europe)","text":"<ul> <li>Walther Blom, High Education &amp; Research</li> <li>Jaco van Dijk, Higher Education</li> </ul>"},{"location":"partners/#eindhoven-university-of-technology","title":"Eindhoven University of Technology","text":"<ul> <li>Alain van Hoof, HPC-Lab</li> </ul>"},{"location":"partners/#ghent-university-belgium","title":"Ghent University (Belgium)","text":"<ul> <li>Kenneth Hoste, HPC-UGent</li> </ul>"},{"location":"partners/#hpcnow-spain","title":"HPCNow! (Spain)","text":"<ul> <li>Oriol Mula Valls</li> </ul>"},{"location":"partners/#julich-supercomputing-centre-germany","title":"J\u00fclich Supercomputing Centre (Germany)","text":"<ul> <li>Alan O'Cais</li> </ul>"},{"location":"partners/#university-of-cambridge-united-kingdom","title":"University of Cambridge (United Kingdom)","text":"<ul> <li>Mark Sharpley, Research Computing Services Division</li> </ul>"},{"location":"partners/#university-of-groningen-the-netherlands","title":"University of Groningen (The Netherlands)","text":"<ul> <li>Bob Dr\u00f6ge, Center for Information Technology</li> <li>Henk-Jan Zilverberg, Center for Information Technology</li> </ul>"},{"location":"partners/#university-of-twente-the-netherlands","title":"University of Twente (The Netherlands)","text":"<ul> <li>Geert Jan Laanstra, Electrical Engineering, Mathematics and Computer Science (EEMCS)</li> </ul>"},{"location":"partners/#university-of-oslo-norway","title":"University of Oslo (Norway)","text":"<ul> <li>Terje Kvernes</li> </ul>"},{"location":"partners/#university-of-bergen-norway","title":"University of Bergen (Norway)","text":"<ul> <li>Thomas R\u00f6blitz</li> </ul>"},{"location":"partners/#vrije-universiteit-amsterdam-the-netherlands","title":"Vrije Universiteit Amsterdam (The Netherlands)","text":"<ul> <li>Peter Stol</li> </ul>"},{"location":"partners/#surf-the-netherlands","title":"SURF (The Netherlands)","text":"<ul> <li>Caspar van Leeuwen</li> <li>Marco Verdicchio</li> <li>Bas van der Vlies</li> </ul>"},{"location":"software_layer/","title":"Software layer","text":"<p>The top layer of the EESSI project is the software layer, which provides the actual scientific software installations.</p> <p>To install the software we include in our stack, we use EasyBuild, a framework for installing scientific software on HPC systems. These installations are optimized for a particular system architecture (specific CPU and GPU generation).</p> <p>To access these software installation we provide environment module files and use Lmod, a modern environment modules tool which has been widely adopted in the HPC community in recent years.</p> <p>We leverage the archspec Python library to automatically select the best suited part of the software stack for a particular host, based on its system architecture.</p> <p>The software layer is maintained through our https://github.com/EESSI/software-layer GitHub repository.</p>"},{"location":"software_testing/","title":"Software testing","text":"<p>This page has been replaced with test-suite, update your bookmarks!</p>"},{"location":"support/","title":"Getting support for EESSI","text":"<p>Thanks to the MultiXscale EuroHPC project we are able to provide support to the users of EESSI. </p> <p>The EESSI support portal is hosted in GitLab: https://gitlab.com/eessi/support.</p>"},{"location":"support/#open-issue","title":"How to report a problem or ask a question","text":"<p>We recommend you to use a GitLab account if you want to get help from the EESSI support team.</p> <p>If you have a GitLab account you can submit your problems or questions on  EESSI via the issue tracker of the EESSI support portal at https://gitlab.com/eessi/support/-/issues. Please use one of the provided templates (report a problem, software request, question, ...) when creating an issue.</p> <p>You can also contact us via our e-mail address <code>support (@) eessi.io</code>, which will automatically create a (private) issue in the EESSI support portal. When you send us an email, please provide us with as much information as possible on your question or problem. You can find an overview of the information that we would like to receive in the README of the EESSI support portal.</p>"},{"location":"support/#level-of-support","title":"Level of Support","text":"<p>We provide support for EESSI according to a \"reasonable effort\" standard. That means we will go into reasonable effort to help you, but we may not have the time to explore every potential cause, and it may not lead to a (quick) solution. You can compare this to the level of support you typically get from other active open source projects.</p> <p>Note that the more complete your reported issue is (e.g. description of the error, what you ran, the software environment in which you ran, minimal reproducer, etc.) the bigger the chance is that we can help you with \"reasonable effort\".</p>"},{"location":"support/#what-do-we-provide-support-for","title":"What do we provide support for","text":""},{"location":"support/#accessing-and-using-the-eessi-software-stack","title":"Accessing and using the EESSI software stack","text":"<p>If you have trouble connecting to the software stack, such as trouble related to installing or configuring CernVM-FS to access the EESSI filesystem layer, or running the software installations included in the EESSI compatibility layer or software layer, please contact us.</p> <p>Note that we can only help with problems related to the software installations (getting the software to run, to perform as expected, etc.). We do not provide support for using specific features of the provided software, nor can we fix (known or unknown) bugs in the software included in EESSI. We can only help with diagnosing and fixing problems that are caused by how the software was built and installed in EESSI.</p>"},{"location":"support/#software-requests","title":"Software requests","text":"<p>We are open to software requests for software that is not included in EESSI yet.</p> <p>The quickest way to add additional software to EESSI is by contributing it yourself as a community contribution, please see the documentation on adding software.</p> <p>Alternatively, you can send in a request to our support team. Please try to provide as much information on the software as possible: preferably use the issue template (which requires you to log in to GitLab), or make sure to cover the items listed here.</p> <p>Be aware that we can only provide software that has an appropriate open source license.</p>"},{"location":"support/#eessi-test-suite","title":"EESSI test suite","text":"<p>If you are using the EESSI test suite, you can get help via the EESSI support portal.</p>"},{"location":"support/#build-and-deploy-bot","title":"Build-and-deploy bot","text":"<p>If you are using the EESSI build-and-deploy bot, you can get help via the EESSI support portal.</p>"},{"location":"support/#what-do-we-not-provide-support-for","title":"What do we not provide support for","text":"<p>Do not contact the EESSI support team to get help with using software that is included in EESSI, unless you think the problems you are seeing are related to how the software was built and installed.</p> <p>Please consult the documentation of the software you are using, or contact the developers of the software directly, if you have questions regarding using the software, or if you think you have found a bug.</p> <p>Funded by the European Union. This work has received funding from the European High Performance Computing Joint Undertaking (JU) and countries participating in the project under grant agreement No 101093169.</p>"},{"location":"systems/","title":"Systems on which EESSI is available natively","text":"<p>This page lists the HPC systems (that we know of) on which EESSI is available system-wide.</p> <p>On these systems, you should be able to initialise your session environment for using EESSI as documented here, and you can try running our demos.</p> <p>Please report additional systems on which EESSI is available</p> <p>If you know of one or more systems on which EESSI is available system-wide that are not listed here yet, please let us know by contacting the EESSI support team, so we can update this page (or open a pull request).</p> <p>What if EESSI is not available system-wide yet?</p> <p>If EESSI is not available yet on the HPC system(s) that you use, contact the corresponding support team and submit a request to make it available.</p> <p>You can point them to our documentation:</p> <ul> <li>How to install and configure CernVM-FS to provide native access to EESSI;</li> <li>Best Practices for CernVM-FS in HPC tutorial;</li> </ul> <p>If they have any questions, please suggest to contact the EESSI support team.</p> <p>In the meantime, you can try using one of the alternative ways of accessing EESSI, like using a container.</p>"},{"location":"systems/#eurohpc-ju-systems","title":"EuroHPC JU systems","text":"<p>EESSI is available on several of the EuroHPC JU supercomputers.</p>"},{"location":"systems/#karolina-czech-republic","title":"Karolina (Czech Republic)","text":"<p>Karolina is the EuroHPC JU supercomputer hosted by IT4Innovations.</p> <ul> <li>General documentation</li> <li>EESSI @ Karolina</li> </ul>"},{"location":"systems/#vega-slovenia","title":"Vega (Slovenia)","text":"<p>Vega is the EuroHPC JU supercomputer hosted by the Institute for Information Science (IZUM).</p> <ul> <li>General documentation</li> <li>EESSI @ Vega</li> </ul>"},{"location":"systems/#deucalion-portugal","title":"Deucalion (Portugal)","text":"<p>Deucalion is the EuroHPC JU supercomputer hosted by the Minho Advanced Computing Center (MACC). EESSI is supported in the ARM and GPU-accelerated partitions of Deucalion with plans to expand to the non-accelerated x86 partition soon.</p> <ul> <li>General documentation</li> <li>EESSI @ Deucalion</li> </ul>"},{"location":"systems/#marenostrum-5-spain","title":"MareNostrum 5 (Spain)","text":"<p>MareNostrum 5 is the EuroHPC JU supercomputer hosted by the Barcelona Supercomputing Center (BSC).</p> <ul> <li>General documentation</li> </ul>"},{"location":"systems/#other-european-systems","title":"Other European systems","text":""},{"location":"systems/#belgium","title":"Belgium","text":""},{"location":"systems/#ghent-university","title":"Ghent University","text":"<ul> <li>Tier-2 clusters: General documentation</li> <li>VSC Tier-1 Hortense: General documentation</li> </ul>"},{"location":"systems/#vrije-universiteit-brussel","title":"Vrije Universiteit Brussel","text":"<ul> <li>Hydra: General documentation | EESSI @ Hydra</li> </ul>"},{"location":"systems/#germany","title":"Germany","text":""},{"location":"systems/#embl-heidelberg","title":"EMBL Heidelberg","text":"<ul> <li>HPC cluster: General documentation</li> </ul>"},{"location":"systems/#julich-supercomputing-centre","title":"J\u00fclich Supercomputing Centre","text":"<ul> <li>JUSUF: General documentation</li> </ul>"},{"location":"systems/#university-of-stuttgart","title":"University of Stuttgart","text":"<ul> <li>Ant: General documentation | EESSI @ Ant</li> </ul>"},{"location":"systems/#greece","title":"Greece","text":""},{"location":"systems/#aristotle-university-of-thessaloniki","title":"Aristotle University of Thessaloniki","text":"<ul> <li>Aristotle: General documentation | EESSI @ Aristotle</li> </ul>"},{"location":"systems/#luxembourg","title":"Luxembourg","text":""},{"location":"systems/#university-of-luxembourg","title":"University of Luxembourg","text":"<ul> <li>ULHPC platform: General documentation | EESSI @ ULHPC</li> </ul>"},{"location":"systems/#netherlands","title":"Netherlands","text":""},{"location":"systems/#surf","title":"SURF","text":"<ul> <li>Snellius: General documentation | EESSI @ Snellius</li> <li>Spider: General documentation | EESSI @ Spider</li> <li>Research Cloud: General documentation | EESSI @ Research Cloud</li> </ul>"},{"location":"systems/#university-of-groningen","title":"University of Groningen","text":"<ul> <li>H\u00e1br\u00f3k: General documentation</li> <li>Managed Linux workspace (LWP): General documentation | EESSI @ LWP</li> </ul>"},{"location":"systems/#norway","title":"Norway","text":""},{"location":"systems/#sigma2-as-norwegian-research-infrastructure-services","title":"Sigma2 AS / Norwegian Research Infrastructure Services","text":"<ul> <li>Betzy: General documentation | EESSI @ Betzy</li> <li>Fram: General documentation | EESSI @ Fram</li> <li>Saga: General documentation | EESSI @ Saga</li> <li>Norwegian AI Cloud - Offers a provisioning system for virtual machines (VM) with preconfigured access to EESSI. Users can launch VMs on a local OpenStack-based cloud and on the commercial clouds Google and Azure.</li> </ul>"},{"location":"systems/#spain","title":"Spain","text":""},{"location":"systems/#barcelona-supercomputing-center","title":"Barcelona Supercomputing Center","text":"<ul> <li>thunder</li> <li>arriesgado-fedora37: General documentation This is a RISC-V cluster that uses <code>riscv.eessi.io</code></li> <li>arriesgado-hirsute: General documentation This is a RISC-V cluster that uses <code>riscv.eessi.io</code></li> </ul>"},{"location":"systems/#galicia-supercomputing-center-cesga","title":"Galicia Supercomputing Center (CESGA)","text":"<ul> <li>FinisTerrae III: General documentation | EESSI @ FinisTerrae III</li> </ul>"},{"location":"systems/#czech-republic","title":"Czech Republic","text":""},{"location":"systems/#czech-technical-university-in-prague","title":"Czech Technical University in Prague","text":"<ul> <li>Sunrise: General documentation</li> </ul>"},{"location":"systems/#systems-outside-of-europe","title":"Systems outside of Europe","text":""},{"location":"systems/#united-states-of-america","title":"United States of America","text":""},{"location":"systems/#michigan-state-university","title":"Michigan State University","text":"<ul> <li>Institute for Cyber-Enabled Research (ICER): General documentation</li> </ul>"},{"location":"systems/#other-infrastructures","title":"Other infrastructures","text":""},{"location":"systems/#aws","title":"AWS","text":"<ul> <li>AWS ParallelCluster: General documentation | EESSI @ AWS ParallelCluster</li> </ul>"},{"location":"systems/#lexis","title":"LEXIS","text":"<ul> <li>LEXIS Platform: General documentation | EESSI @ LEXIS</li> </ul>"},{"location":"talks/","title":"Talks related to EESSI","text":""},{"location":"talks/#2023","title":"2023","text":"<ul> <li>Streaming Optimised Scientific Software: an Introduction to EESSI (online tutorial, 5 Dec 2023)</li> <li>Best Practices for CernVM-FS in HPC (online tutorial, 4 Dec 2023)</li> <li>Streaming optimized scientific software installations on any Linux distro with EESSI (PackagingCon 2023, 27 Oct 2023)</li> <li>Making scientific software EESSI - and fast (8-min AWS HPC Tech Short, 15 June 2023)</li> </ul>"},{"location":"adding_software/adding_development_software/","title":"Adding software to <code>dev.eessi.io</code>","text":"<p><code>dev.eessi.io</code> is still in active development and focused on MultiXscale</p> <p>The <code>dev.eessi.io</code> repository and functionality is still in its early stages. The repository itself and build + deploy procedure for it are functional, but may change often for the time being. </p> <p>Our focus is currently on including and supporting developers and applications in the  MultiXscale CoE.</p>"},{"location":"adding_software/adding_development_software/#what-is-deveessiio","title":"What is <code>dev.eessi.io</code>?","text":"<p><code>dev.eessi.io</code> is the development repository of EESSI.</p>"},{"location":"adding_software/adding_development_software/#adding-software","title":"Adding software","text":"<p>Using <code>dev.eessi.io</code> is similar to using EESSI's production repository <code>software.eessi.io</code>. Software builds are triggered by a bot listening to pull  requests in GitHub repositories.  These builds require custom easyconfig and easystack files, which should be in specific directories.</p> <p>To see this in practice, refer to the dev.eessi.io-example GitHub repository.  In this GitHub repository you will find templates for some software installations with the appropriate directory structure, that is:</p> <pre><code>dev.eessi.io-example\n\u251c\u2500\u2500 easyconfigs\n\u2514\u2500\u2500 easystacks\n</code></pre>"},{"location":"adding_software/adding_development_software/#quick-steps-to-build-for-deveessiio","title":"Quick steps to build for <code>dev.eessi.io</code>","text":"<ul> <li>Obtain commit ID from GitHub or GitLab repository with source to build.</li> <li>Fork the project's <code>dev.eessi.io</code> repository on GitHub, or checkout to a new branch if you can do so.</li> <li>If needed, prepare an easyconfig template using <code>--software-commit</code> and add it to <code>easyconfigs/</code></li> <li>Add an easystack file in <code>easystacks/</code> that with the easyconfig file above, add the commit ID to <code>software-commit</code> under <code>options</code>.</li> <li>Open a PR from the fork or branch to the main branch of the application's <code>dev.eessi.io</code> GitHub repository.</li> <li>Instruct the bot to start a build by adding a comment with <code>bot: build</code>.</li> <li>Confirm the build worked correctly. If so, you can deploy the software by adding the label <code>bot:build</code> to the pull request.</li> <li>Once the staging PR is approved, the development build will become available on <code>dev.eessi.io</code> in a few minutes!</li> </ul>"},{"location":"adding_software/adding_development_software/#installation-details","title":"Installation details","text":""},{"location":"adding_software/adding_development_software/#easyconfig-files-and-software-commit","title":"easyconfig files and <code>--software-commit</code>","text":"<p>The approach to build and install software is similar to that of <code>software.eessi.io</code>.  It requires one or more easyconfig files. Easyconfig files used for building for <code>dev.eessi.io</code> do not need to be a part of an EasyBuild release, unlike builds for  <code>software.eessi.io</code>. In this case, the development easyconfigs can be located under <code>easyconfigs/</code> in the <code>dev.eessi.io</code> repository being used.</p> <p>To allow for development builds, we leverage the <code>--software-commit</code> functionality (requires EasyBuild v4.9.3 or higher). This lets us build a given application from a specific commit in repository. This can also be done from a fork, by changing the <code>github_account</code> field in the easyconfig file.  We've created a template for <code>ESPResSo</code> based on the standard eaasyconfig of the most recent version. The relevant fields are:</p> <pre><code>easyblock = 'CMakeMake'\n\nname = 'ESPResSo'\nversion = 'devel'\nversionsuffix = '-%(software_commit)s'\n\nhomepage = 'https://espressomd.org/wordpress'\ndescription = \"\"\"A software package for performing and analyzing scientific Molecular Dynamics simulations.\"\"\"\n\ngithub_account = 'espressomd'\nsource_urls = ['https://github.com/%(github_account)s/%(name)s/archive/']\n\nsources = ['%(software_commit)s.tar.gz']\n</code></pre> <p><code>--software-commit</code> disables <code>--robot</code></p> <p>Using <code>--software-commit</code> disables the use of <code>--robot</code>, so make sure that you explicitly include new dependencies that might need to be installed. Otherwise, the easyconfig files won't be found.</p> <p>You can also make additional changes to the easyconfig file, for example, if the new functionality requires new build or runtime dependencies, patches, configuration options, etc. It's a good idea to try installing from a specific commit locally first, to at least see if everything is parsed correctly and confirm that the right sources are being downloaded.</p> <p>While the process to build for <code>dev.eessi.io</code> is similar to the one for the production repository, there  are a few additional details to keep in mind.</p>"},{"location":"adding_software/adding_development_software/#software-version","title":"Software version","text":"<p>Installations to the EESSI production repository refer to specific versions of applications. However, development builds can't follow the same  approach as they are most often not pegged to a release. Because of this, it is possible to include a descriptive \"version\" label to the <code>version</code> parameter in the easyconfig file for a given (set of) installations. </p> <p>Note that some applications are built with custom easyblocks, which may use the <code>version</code> parameter to determine how the installation is meant to work (for example, recent versions need to copy files from to a new directory). Make sure that you account for this, otherwise you may install software differently than intended. If you encounter issues, you can open an issue in our support portal.</p>"},{"location":"adding_software/adding_development_software/#installing-dependencies","title":"Installing dependencies","text":"<p>Installations in <code>dev.eessi.io</code> are done on top of <code>software.eessi.io</code>. That means if your development build depends on some application that is already installed in <code>software.eessi.io</code>, then that will simply be used. However, if you need to add a new dependency, then this must included as  part of the build. That means including an easyconfig file for it, and adding it to the right easystack file.</p>"},{"location":"adding_software/adding_development_software/#using-commit-ids-or-tags-for-software-commit","title":"Using commit IDs or tags for <code>--software-commit</code>","text":"<p>Installing with <code>--software-commit</code> requires that you include either a commit ID or a tag. The installation procedure will use this to obtain the sources for the build. Because tags can be changed to point to a different commit ID, we recommend you avoid using them and sticking to the commit ID itself. You can then include this in the <code>versionsuffix</code> on your easyconfig file, to generate a unique (though \"ugly\") module name.</p>"},{"location":"adding_software/adding_development_software/#patch-files","title":"Patch files","text":"<p>If your specific development build requires patch files, you should add these to the <code>easyconfigs/</code> directory. If the necessary patch is part of an EasyBuild release, then this may not be necessary, as these will be directly taken from EasyBuild. If it is a new patch that is not on an EasyBuild release, then include it in the <code>easyconfigs/</code> directory.</p>"},{"location":"adding_software/adding_development_software/#checksums","title":"Checksums","text":"<p>EasyBuild's easyconfig files typically contain checksums  as their use is highly recommended. By default, EasyBuild will compute the checksums of sources and patch files it needs for   a given installation, and compare them with the values in the easyconfig file. Because builds for <code>dev.eessi.io</code> change much    more often, hard coded checksums become a problem, as they'd need to be updated with every new build. For this reason, we     recommend not including checksums in your development easyconfig files (unless you need to, for a specific reason).</p>"},{"location":"adding_software/adding_development_software/#easystack-files","title":"Easystack files","text":"<p>After an easyconfig file has been created and added to the <code>easyconfigs</code> subdirectory, an easystack file that picks it up needs to be in place so that a build can be triggered.</p> <p>Naming convention for easystack files</p> <p>The easystack files must follow a naming convention and be named something like: <code>software-eb-X.Y.Z-dev.yml</code>, where X.Y.Z correspond to the EasyBuild version used to install the software. Following our example for  <code>ESPREsSo</code>, it would look like: </p> <pre><code>easyconfigs:\n  - ESPResSo-devel-foss-2023a-software-commit.eb:\n      options:\n        software-commit: 2ba17de6096933275abec0550981d9122e4e5f28 # release 4.2.2\n</code></pre> <p><code>ESPResSo-devel-foss-2023a-software-commit.eb</code> would be the name of the easyconfig file added in our example step above.  Note the option passing the <code>software-commit</code> for the development version that should be built. For the sake of this example, the chosen commit actually corresponds to the 4.2.2 release of ESPResSo.</p>"},{"location":"adding_software/adding_development_software/#triggering-builds","title":"Triggering builds","text":"<p>We use the EESSI build-test-deploy bot to handle software builds. All one needs to do is open a PR with the changes adding the easyconfig and easystack  files and commenting <code>bot: build</code>. This can only be done by previously authorized users.  The current build cluster for <code>dev.eessi.io</code> builds only for the <code>zen2</code> CPU microarchitecture, but this is likely to change.</p> <p>Once a build is complete and the <code>bot:deploy</code> label is added, a staging PR can be merged to deploy the application to the <code>dev.eessi.io</code> cvmfs repository. On a system with <code>dev.eessi.io</code> mounted, then all that is left is to <code>module use /cvmfs/dev.eessi.io/versions/2023.06/modules/all</code> and try out the software!</p> <p>There is currently no initialisation script or module for <code>dev.eessi.io</code>, but this feature is coming soon.</p>"},{"location":"adding_software/building_software/","title":"Building software","text":"<p>(for maintainers)</p>"},{"location":"adding_software/building_software/#bot_build","title":"Instructing the bot to build","text":"<p>Once the pull request is open, you can instruct the bot  to build the software by posting a comment.</p> <p>For more information, see the building section in the bot documentation.</p> <p>Warning</p> <p>Permission to trigger building of software must be granted to your GitHub account first!</p> <p>See bot permissions for more information.</p>"},{"location":"adding_software/building_software/#guidelines","title":"Guidelines","text":"<ul> <li> <p>It may be wise to let the bot perform a test build first, rather than letting it build for a wide range   of CPU targets.</p> </li> <li> <p>If one of the builds failed, you can let the bot retry that specific build.</p> </li> <li> <p>Make sure that the software has been built correctly for all CPU targets before you deploy!</p> </li> </ul>"},{"location":"adding_software/building_software/#checking-the-builds","title":"Checking the builds","text":"<p>If all goes well, you should see <code>SUCCESS</code>  for each build, along with button  to get more information about the checks that were performed, and metadata information on the resulting artefact .</p> <p>Note</p> <p>Make sure the result is what you expect it to be for all builds before you deploy!</p>"},{"location":"adding_software/building_software/#failing-builds","title":"Failing builds","text":"<p>Warning</p> <p>The bot will currently not give you any information on how or why a build is failing.</p> <p>Ask for help in the <code>#software-layer</code> channel of the EESSI Slack if needed!</p>"},{"location":"adding_software/building_software/#instructing-the-bot-to-deploy","title":"Instructing the bot to deploy","text":"<p>To make the bot  deploy the successfully built software, you should issue the corresponding instruction to the bot.</p> <p>For more information, see the deploying section in the bot documentation.</p> <p>Warning</p> <p>Permission to trigger deployment of software installations must be granted to your GitHub account first!</p> <p>See bot permissions for more information.</p>"},{"location":"adding_software/building_software/#merging-the-pull-request","title":"Merging the pull request","text":"<p>You should be able to verify in the pull request that the ingestion has been done, since the CI should fail  initially to indicate that some software installations listed in your modified easystack are missing.</p> <p>Once the ingestion has been done, simply re-triggering the CI workflow should be sufficient to make it pass , and then the pull request can be merged.</p> <p>Note</p> <p>This assumes that the easystack file being modified is considered by the CI workflow file (<code>.github/workflows/test_eessi.yml</code>) that checks for missing installations, in the correct branch (for example <code>2023.06</code>) of the software-layer.</p> <p>If that's not the case yet, update this workflow in your pull request as well to add the missing easystack file!</p> <p>Warning</p> <p>You need permissions to re-trigger CI workflows and merge pull requests in the software-layer repository.</p> <p>Ask for help in the <code>#software-layer</code> channel of the EESSI Slack if needed!</p>"},{"location":"adding_software/building_software/#getting-help","title":"Getting help","text":"<p>If you have any questions, or if you need help with something, don't hesitate to contact us via the <code>#software-layer</code> channel of the EESSI Slack.</p>"},{"location":"adding_software/contribution_policy/","title":"Contribution policy","text":"<p>(version v0.1.0 - updated 9 Nov 2023)</p> <p>Note</p> <p>This policy is subject to change, please check back regularly.</p>"},{"location":"adding_software/contribution_policy/#purpose","title":"Purpose","text":"<p>The purpose of this contribution policy is to provide guidelines for adding software to EESSI.</p> <p>It informs about what requirements must be met in order for software to be eligible for inclusion in the EESSI software layer.</p>"},{"location":"adding_software/contribution_policy/#requirements","title":"Requirements","text":"<p>The following requirements must be taken into account when adding software to EESSI.</p> <p>Note that additional restrictions may apply in specific cases that are currently not covered explicitly by this policy.</p>"},{"location":"adding_software/contribution_policy/#freely_redistributable_software","title":"i) Freely redistributable software","text":"<p>Only freely redistributable software can be added to the EESSI repository, and we strongly prefer including only open source software in EESSI.</p> <p>Make sure that you are aware of the relevant software licenses, and that redistribution of the software you want to add to EESSI is allowed.</p> <p>For more information about a specific software license, see the SPDX license list.</p> <p>Note</p> <p>We intend to automatically verify that this requirement is met, by requiring that the SPDX license identifier is provided for all software included in EESSI.</p>"},{"location":"adding_software/contribution_policy/#built_by_bot","title":"ii) Built by the bot","text":"<p>All software included in the EESSI repository must be built autonomously by our bot .</p> <p>For more information, see our semi-automatic software installation procedure.</p>"},{"location":"adding_software/contribution_policy/#easybuild","title":"iii) Built and installed with EasyBuild","text":"<p>We currently require that all software installations in EESSI are built and installed using EasyBuild.</p> <p>We strongly prefer that the latest release of EasyBuild that is available at the time is used to add software to EESSI.</p> <p>The use of <code>--from-pr</code> and <code>--include-easyblocks-from-pr</code> to pull in changes to EasyBuild that are required to make the installation work correctly in EESSI is allowed, but only if that is strictly required (that is, if those changes are not included yet in the latest EasyBuild release).</p>"},{"location":"adding_software/contribution_policy/#supported_toolchain","title":"iv) Supported compiler toolchain","text":"<p>A compiler toolchain that is still supported by the latest EasyBuild release must be used for building the software.</p> <p>For more information on supported toolchains, see the EasyBuild toolchain support policy.</p>"},{"location":"adding_software/contribution_policy/#recent_toolchains","title":"v) Recent toolchain versions","text":"<p>We strongly prefer adding software to EESSI that was built with a recent compiler toolchain.</p> <p>When adding software to a particular version of EESSI, you should use a toolchain version that is already installed.</p> <p>If you would like to see an additional toolchain version being added to a particular version of EESSI, please open a support request for this, and motivate your request.</p>"},{"location":"adding_software/contribution_policy/#recent_software_versions","title":"vi) Recent software versions","text":"<p>We strongly prefer adding sufficiently recent software versions to EESSI.</p> <p>If you would like to add older software versions, please clearly motivate the need for this in your contribution.</p>"},{"location":"adding_software/contribution_policy/#cpu_targets","title":"vii) CPU targets","text":"<p>Software that is added to EESSI should work on all supported CPU targets.</p> <p>Exceptions to this requirement are allowed if technical problems that can not be resolved with reasonable effort prevent the installation of the software for specific CPU targets.</p>"},{"location":"adding_software/contribution_policy/#testing","title":"viii) Testing","text":"<p>We should be able to test the software installations via the EESSI test suite, in particular for software applications and user-facing tools.</p> <p>Ideally one or more tests are available that verify that the software is functionally correct, and that it (still) performs well.</p> <p>Tests that are run during the software installation procedure as performed by EasyBuild must pass. Exceptions can be made if only a small subset of tests fail for specific CPU targets, as long as these exceptions are tracked and an effort is made to assess the impact of those failing tests.</p> <p>It should be possible to run a minimal smoke test for the software included in EESSI, for example using EasyBuild's <code>--sanity-check-only</code> feature.</p> <p>Note</p> <p>The EESSI test suite is still in active development, and currently only has a minimal set of tests available.</p> <p>When the test suite is more mature, this requirement will be enforced more strictly.</p>"},{"location":"adding_software/contribution_policy/#changelog","title":"Changelog","text":""},{"location":"adding_software/contribution_policy/#v010-9-nov-2023","title":"v0.1.0 (9 Nov 2023)","text":"<ul> <li>initial contribution policy</li> </ul>"},{"location":"adding_software/debugging_failed_builds/","title":"Debugging failed builds","text":"<p>(for contributors + maintainers)</p> <p>Unfortunately, software does not always build successfully. Since EESSI targets novel CPU architectures as well, build failures on such platforms are quite common, as the software and/or the software build systems have not always been adjusted to support these architectures yet.</p> <p>In EESSI, all software packages are built by a bot. This is great for builds that complete successfully as we can build many software packages for a wide range of hardware with little human intervention. However, it does mean that you, as contributor, can not easily access the build directory and build logs to figure out build issues.</p> <p>This page describes how you can interactively reproduce failed builds, so that you can more easily debug the issue.</p> <p>Throughout this page, we will use this PR as an example. It intends to add LAMMPS to EESSI. Among other issues, it failed on a building Plumed.</p>"},{"location":"adding_software/debugging_failed_builds/#prerequisites","title":"Prerequisites","text":"<p>You will need to have:</p> <ul> <li>Access to a machine with the hardware for which the build that you want to debug failed. </li> <li>On that machine, meet the requirements for running the EESSI container, as described on this page.</li> </ul>"},{"location":"adding_software/debugging_failed_builds/#preparing-the-environment","title":"Preparing the environment","text":"<p>A number of steps are needed to create the same environment in which the bot builds.</p> <ul> <li>Fetching the feature branch from which you want to replicate a build.</li> <li>Starting a shell in the EESSI container.</li> <li>Start the Gentoo Prefix environment.</li> <li>Start the EESSI software environment.</li> <li>Configure EasyBuild.</li> </ul>"},{"location":"adding_software/debugging_failed_builds/#fetching-the-feature-branch","title":"Fetching the feature branch","text":"<p>Looking at the example PR, we see the PR is created from this fork. First, we clone the fork, then checkout the feature branch (<code>LAMMPS_23Jun2022</code>) <pre><code>git clone https://github.com/laraPPr/software-layer/\ncd software-layer\ngit checkout LAMMPS_23Jun2022\n</code></pre> Alternatively, if you already have a clone of the <code>software-layer</code> you can add it as a new remote <pre><code>cd software-layer\ngit remote add laraPPr https://github.com/laraPPr/software-layer/\ngit fetch laraPPr\ngit checkout LAMMPS_23Jun2022\n</code></pre></p>"},{"location":"adding_software/debugging_failed_builds/#starting-a-shell-in-the-eessi-container","title":"Starting a shell in the EESSI container","text":"<p>Simply run the EESSI container (<code>eessi_container.sh</code>), which should be in the root of the <code>software-layer</code> repository. Use <code>-r</code> to specify which EESSI repository (e.g. <code>software.eessi.io</code>, <code>dev.eessi.io</code>, ...) should be mounted in the container <pre><code>./eessi_container.sh --access rw -r software.eessi.io\n</code></pre></p> <p>If you want to install NVIDIA GPU software, make sure to also add the <code>--nvidia all</code> argument, to insure that your GPU drivers get mounted inside the container: <pre><code>./eessi_container.sh --access rw -r software.eessi.io --nvidia all\n</code></pre></p> <p>Note</p> <p>You may have to press enter to clearly see the prompt as some messages beginning with <code>CernVM-FS:</code> have been printed after the first prompt <code>Apptainer&gt;</code> was shown.</p>"},{"location":"adding_software/debugging_failed_builds/#more-efficient-approach-for-multiplecontinued-debugging-sessions","title":"More efficient approach for multiple/continued debugging sessions","text":"<p>While the above works perfectly well, you might not be able to complete your debugging session in one go. With the above approach, several steps will just be repeated every time you start a debugging session:</p> <ul> <li>Downloading the container</li> <li>Installing <code>CUDA</code> in your host injections directory (only if you use the <code>EESSI-install-software.sh</code> script, see below)</li> <li>Installing all dependencies (before you get to the package that actually fails to build)</li> </ul> <p>To avoid this, we create two directories. One holds the container &amp; <code>host_injections</code>, which are (typically) common between multiple PRs and thus you don't have to redownload the container / reinstall the <code>host_injections</code> if you start working on another PR. The other will hold the PR-specific data: a tarball storing the software you'll build in your interactive debugging session. The paths we pick here are just example, you can pick any persistent, writeable location for this: <pre><code>eessi_common_dir=${HOME}/eessi-manual-builds\neessi_pr_dir=${HOME}/pr360\n</code></pre></p> <p>Now, we start the container <pre><code>SINGULARITY_CACHEDIR=${eessi_common_dir}/container_cache ./eessi_container.sh --access rw -r software.eessi.io --nvidia all --host-injections ${eessi_common_dir}/host_injections --save ${eessi_pr_dir}\n</code></pre></p> <p>Here, the <code>SINGULARITY_CACHEDIR</code> makes sure that if the container was already downloaded, and is present in the cache, it is not redownloaded. The host injections will just be picked up from <code>${eessi_common_dir}/host_injections</code> (if those were already installed before). And finally, the <code>--save</code> makes sure that everything that you build in the container gets stored in a tarball as soon as you exit the container.</p> <p>Note that the first <code>exit</code> command will first make you exit the Gentoo prefix environment. Only the second will take you out of the container, and print where the tarball will be stored:</p> <pre><code>[EESSI 2023.06] $ exit\nlogout\nLeaving Gentoo Prefix with exit status 1\nApptainer&gt; exit\nexit\nSaved contents of tmp directory '/tmp/eessi-debug.VgLf1v9gf0' to tarball '${HOME}/pr360/EESSI-1698056784.tgz' (to resume session add '--resume ${HOME}/pr360/EESSI-1698056784.tgz')\n</code></pre> <p>Note that the tarballs can be quite sizeable, so make sure to pick a filesystem where you have a large enough quotum.</p> <p>Next time you want to continue investigating this issue, you can start the container with <code>--resume DIR/TGZ</code> and continue where you left off, having all dependencies already built and available. <pre><code>SINGULARITY_CACHEDIR=${eessi_common_dir}/container_cache ./eessi_container.sh --access rw -r software.eessi.io --nvidia all --host-injections ${eessi_common_dir}/host_injections --save ${eessi_pr_dir}/EESSI-1698056784.tgz\n</code></pre></p> <p>For a detailed description on using the script <code>eessi_container.sh</code>, see here.</p> <p>Note</p> <p>Reusing a previously downloaded container, or existing CUDA installation from a <code>host_injections</code> is not be a good approach if those could be the cause of your issues. If you are unsure if this is the case, simply follow the regular approach to starting the EESSI container.</p> <p>Note</p> <p>It is recommended to clean the container cache and <code>host_injections</code> directories every now and again, to make sure you pick up the latest changes for those two components.</p>"},{"location":"adding_software/debugging_failed_builds/#start-the-gentoo-prefix-environment","title":"Start the Gentoo Prefix environment","text":"<p>The next step is to start the Gentoo Prefix environment. </p> <p>First, you'll have to set which repository and version of EESSI you are building for. For example: <pre><code>export EESSI_CVMFS_REPO=/cvmfs/software.eessi.io\nexport EESSI_VERSION=2023.06\n</code></pre></p> <p>Then, we set <code>EESSI_OS_TYPE</code> and <code>EESSI_CPU_FAMILY</code> and run the <code>startprefix</code> command to start the Gentoo Prefix environment: <pre><code>export EESSI_OS_TYPE=linux  # We only support Linux for now\nexport EESSI_CPU_FAMILY=$(uname -m)\n${EESSI_CVMFS_REPO}/versions/${EESSI_VERSION}/compat/${EESSI_OS_TYPE}/${EESSI_CPU_FAMILY}/startprefix\n</code></pre></p> <p>Unfortunately, there is no way to retain the <code>${EESSI_CVMFS_REPO}</code> and <code>${EESSI_VERSION}</code> in your prefix environment, so we have to set them again. For example: <pre><code>export EESSI_CVMFS_REPO=/cvmfs/software.eessi.io\nexport EESSI_VERSION=2023.06\n</code></pre></p> <p>Note</p> <p>By activating the Gentoo Prefix environment, the system tools (e.g. <code>ls</code>) you would normally use are now provided by Gentoo Prefix, instead of the container OS. E.g. running <code>which ls</code> after starting the prefix environment as above will return <code>/cvmfs/software.eessi.io/versions/2023.06/compat/linux/x86_64/bin/ls</code>. This makes the builds completely independent from the container OS.</p>"},{"location":"adding_software/debugging_failed_builds/#building-for-the-generic-optimization-target","title":"Building for the <code>generic</code> optimization target","text":"<p>If you want to replicate a build with <code>generic</code> optimization (i.e. in <code>$EESSI_CVMFS_REPO/versions/${EESSI_VERSION}/software/${EESSI_OS_TYPE}/${EESSI_CPU_FAMILY}/generic</code>) you will need to set the following environment variable: <pre><code>export EESSI_CPU_FAMILY=$(uname -m) &amp;&amp; export EESSI_SOFTWARE_SUBDIR_OVERRIDE=${EESSI_CPU_FAMILY}/generic\n</code></pre></p>"},{"location":"adding_software/debugging_failed_builds/#building-software-with-the-eessi-install-softwaresh-script","title":"Building software with the <code>EESSI-install-software.sh</code> script","text":"<p>The Automatic build and deploy bot installs software by executing the <code>EESSI-install-software.sh</code> script. The advantage is that running this script is the closest you can get to replicating the bot's behaviour - and thus the failure. The downside is that if a PR adds a lot of software, it may take quite a long time to run - even if you might already know what the problematic software package is. In that case, you might be better off following the steps under Building software from an easystack file or Building an individual package.</p> <p>Note that you could also combine approaches: first build everything using the <code>EESSI-install-software.sh</code> script, until you reproduce the failure. Then, start making modifications (e.g. changes to the EasyConfig, patches, etc) and trying to rebuild that package individually to test your changes.</p> <p>To build software using the <code>EESSI-install-software.sh</code> script, you'll first need to get the diff file for the PR. This is used by the <code>EESSI-install-software.sh</code> script to see what is changed in this PR - and thus what needs to be build for this PR. To download the diff for PR 360, we would e.g. do <pre><code>wget https://github.com/EESSI/software-layer/pull/360.diff\n</code></pre></p> <p>Now, we run the <code>EESSI-install-software.sh</code> script:</p> <pre><code>./EESSI-install-software.sh\n</code></pre>"},{"location":"adding_software/debugging_failed_builds/#building-software-from-an-easystack-file","title":"Building software from an easystack file","text":""},{"location":"adding_software/debugging_failed_builds/#starting-the-eessi-software-environment","title":"Starting the EESSI software environment","text":"<p>To activate the software environment, run <pre><code>source ${EESSI_CVMFS_REPO}/versions/${EESSI_VERSION}/init/bash\n</code></pre></p> <p>Note</p> <p>If you get an error <code>bash: /versions//init/bash: No such file or directory</code>, you forgot to reset the <code>${EESSI_CVMFS_REPO}</code> and <code>${EESSI_VERSION}</code> environment variables at the end of the previous step.</p> <p>Note</p> <p>If you want to build with generic optimization, you should run <code>export EESSI_CPU_FAMILY=$(uname -m) &amp;&amp; export EESSI_SOFTWARE_SUBDIR_OVERRIDE=${EESSI_CPU_FAMILY}/generic</code> before sourcing.</p> <p>For more info on starting the EESSI software environment, see here</p>"},{"location":"adding_software/debugging_failed_builds/#configure-easybuild","title":"Configure EasyBuild","text":"<p>It is important that we configure EasyBuild in the same way as the bot uses it, with one small exceptions: our working directory will be different. Typically, that doesn't matter, but it's good to be aware of this one difference, in case you fail to replicate the build failure.</p> <p>In this example, we create a unique temporary directory inside <code>/tmp</code> to serve both as our workdir. Finally, we will source the <code>configure_easybuild</code> script, which will configure EasyBuild by setting environment variables.</p> <p><pre><code>export WORKDIR=$(mktemp --directory --tmpdir=/tmp  -t eessi-debug.XXXXXXXXXX)\nsource scripts/utils.sh &amp;&amp; source configure_easybuild\n</code></pre> Among other things, the <code>configure_easybuild</code> script sets the install path for EasyBuild to point to the correct installation directory in (to <code>${EESSI_CVMFS_REPO}/versions/${EESSI_VERSION}/software/${EESSI_OS_TYPE}/${EESSI_SOFTWARE_SUBDIR}</code>). This is the exact same path the <code>bot</code> uses to build, and uses a writeable overlay filesystem in the container to write to a path in <code>/cvmfs</code> (which normally is read-only). This is identical to what the <code>bot</code> does.</p> <p>Note</p> <p>If you started the container using --resume, you may want WORKDIR to point to the workdir you created previously (instead of creating a new, temporary directory with <code>mktemp</code>).</p> <p>Note</p> <p>If you want to replicate a build with <code>generic</code> optimization (i.e. in <code>$EESSI_CVMFS_REPO/versions/${EESSI_VERSION}/software/${EESSI_OS_TYPE}/${EESSI_CPU_FAMILY}/generic</code>) you will need to set <code>export EASYBUILD_OPTARCH=GENERIC</code> after sourcing <code>configure_easybuild</code>.</p> <p>Next, we need to determine the correct version of EasyBuild to load. Since the example PR changes the file <code>eessi-2023.06-eb-4.8.1-2021b.yml</code>, this tells us the bot was using version <code>4.8.1</code> of EasyBuild to build this. Thus, we load that version of the EasyBuild module and check if everything was configured correctly: <pre><code>module load EasyBuild/4.8.1\neb --show-config\n</code></pre> You should get something similar to</p> <pre><code>#\n# Current EasyBuild configuration\n# (C: command line argument, D: default value, E: environment variable, F: configuration file)\n#\nbuildpath            (E) = /tmp/easybuild/easybuild/build\ncontainerpath        (E) = /tmp/easybuild/easybuild/containers\ndebug                (E) = True\nexperimental         (E) = True\nfilter-deps          (E) = Autoconf, Automake, Autotools, binutils, bzip2, DBus, flex, gettext, gperf, help2man, intltool, libreadline, libtool, Lua, M4, makeinfo, ncurses, util-linux, XZ, zlib, Yasm\nfilter-env-vars      (E) = LD_LIBRARY_PATH\nhooks                (E) = ${HOME}/software-layer/eb_hooks.py\nignore-osdeps        (E) = True\ninstallpath          (E) = /tmp/easybuild/software/linux/aarch64/neoverse_n1\nmodule-extensions    (E) = True\npackagepath          (E) = /tmp/easybuild/easybuild/packages\nprefix               (E) = /tmp/easybuild/easybuild\nread-only-installdir (E) = True\nrepositorypath       (E) = /tmp/easybuild/easybuild/ebfiles_repo\nrobot-paths          (D) = /cvmfs/software.eessi.io/versions/2023.06/software/linux/aarch64/neoverse_n1/software/EasyBuild/4.8.1/easybuild/easyconfigs\nrpath                (E) = True\nsourcepath           (E) = /tmp/easybuild/easybuild/sources:\nsysroot              (E) = /cvmfs/software.eessi.io/versions/2023.06/compat/linux/aarch64\ntrace                (E) = True\nzip-logs             (E) = bzip2\n</code></pre>"},{"location":"adding_software/debugging_failed_builds/#building-everything-in-the-easystack-file","title":"Building everything in the easystack file","text":"<p>In our example PR, the easystack file that was changed was <code>eessi-2023.06-eb-4.8.1-2021b.yml</code>. To build this, we run (in the directory that contains the checkout of this feature branch): <pre><code>eb --easystack eessi-2023.06-eb-4.8.1-2021b.yml --robot\n</code></pre> After some time, this build fails while trying to build <code>Plumed</code>, and we can access the build log to look for clues on why it failed.</p>"},{"location":"adding_software/debugging_failed_builds/#building-an-individual-package","title":"Building an individual package","text":"<p>First, prepare the environment by following the [Starting the EESSI software environment][#starting-the-eessi-software-environment] and Configure EasyBuild above.</p> <p>In our example PR, the individual package that was added to <code>eessi-2023.06-eb-4.8.1-2021b.yml</code> was <code>LAMMPS-23Jun2022-foss-2021b-kokkos.eb</code>. To mimic the build behaviour, we'll also have to (re)use any options that are listed in the easystack file for <code>LAMMPS-23Jun2022-foss-2021b-kokkos.eb</code>, in this case the option <code>--from-pr 19000</code>. Thus, to build, we run: <pre><code>eb LAMMPS-23Jun2022-foss-2021b-kokkos.eb --robot --from-pr 19000\n</code></pre> After some time, this build fails while trying to build <code>Plumed</code>, and we can access the build log to look for clues on why it failed.</p> <p>Note</p> <p>While this might be faster than the easystack-based approach, this is not how the bot builds. So why it may reproduce the failure the bot encounters, it may not reproduce the bug at all (no failure) or run into different bugs. If you want to be sure, use the easystack-based approach.</p>"},{"location":"adding_software/debugging_failed_builds/#rebuilding-software","title":"Rebuilding software","text":"<p>Rebuilding software requires an additional step at the beginning: the software first needs to be removed. We assume you've already checked out the feature branch. Then, you need to start the container with the additional <code>--fakeroot</code> argument, otherwise you will not be able to remove files from the <code>/cvmfs</code> prefix. Make sure to also include the <code>--save</code> argument, as we will need the tarball later on. E.g. <pre><code>SINGULARITY_CACHEDIR=${eessi_common_dir}/container_cache ./eessi_container.sh --access rw -r software.eessi.io --nvidia all --host-injections ${eessi_common_dir}/host_injections --save ${eessi_pr_dir} --fakeroot\n</code></pre> Then, initialize the EESSI environment <pre><code>source ${EESSI_CVMFS_REPO}/versions/${EESSI_VERSION}/init/bash\n</code></pre> and get the diff file for the corresponding PR, e.g. for PR 123: <pre><code>wget https://github.com/EESSI/software-layer/pull/123.diff\n</code></pre> Finally, run the <code>EESSI-remove-software.sh</code> script <pre><code>./EESSI-remove-software.sh`\n</code></pre></p> <p>This should remove any software specified in a rebuild easystack that got added in your current feature branch.</p> <p>Now, exit the container, paying attention to the instructions that are printed to resume later, e.g.:</p> <pre><code>Saved contents of tmp directory '/tmp/eessi.WZxeFUemH2' to tarball '/home/myuser/pr507/EESSI-1711538681.tgz' (to resume session add '--resume /home/myuser/pr507/EESSI-1711538681.tgz')\n</code></pre> <p>Now, continue with the original instructions to start the container (i.e. either here or with this alternate approach) and make sure to add the <code>--resume</code> flag. This way, you are resuming from the tarball (i.e. with the software removed that has to be rebuilt), but in a new container in which you have regular (i.e. no root) permissions.</p>"},{"location":"adding_software/debugging_failed_builds/#running-the-test-step","title":"Running the test step","text":"<p>If you are still in the prefix layer (i.e. after previously building something), exit it first: <pre><code>$ exit\nlogout\nLeaving Gentoo Prefix with exit status 0\n</code></pre> Then, source the EESSI init script (again): <pre><code>Apptainer&gt; source ${EESSI_CVMFS_REPO}/versions/${EESSI_VERSION}/init/bash\nEnvironment set up to use EESSI (2023.06), have fun!\n{EESSI 2023.06} Apptainer&gt;\n</code></pre></p> <p>Note</p> <p>If you are in a SLURM environment, make sure to run <code>for i in $(env | grep SLURM); do unset \"${i%=*}\"; done</code> to unset any SLURM environment variables. Failing to do so will cause <code>mpirun</code> to pick up on these and e.g. infer how many slots are available. If you run into errors of the form \"There are not enough slots available in the system to satisfy the X slots that were requested by the application:\", you probably forgot this step.</p> <p>Then, execute the <code>run_tests.sh</code> script. We are assuming you are still in the root of the <code>software-layer</code> repository that you cloned earlier: <pre><code>./run_tests.sh\n</code></pre> if all goes well, you should see (part of) the EESSI test suite being run by ReFrame, finishing with something like</p> <pre><code>[  PASSED  ] Ran X/Y test case(s) from Z check(s) (0 failure(s), 0 skipped, 0 aborted)\n</code></pre> <p>Note</p> <p>If you are running on a system with hyperthreading enabled, you may still run into the \"There are not enough slots available in the system to satisfy the X slots that were requested by the application:\" error from <code>mpirun</code>, because hardware threads are not considered to be slots by default by OpenMPIs <code>mpirun</code>. In this case, run with <code>OMPI_MCA_hwloc_base_use_hwthreads_as_cpus=1 ./run_tests.sh</code> (for OpenMPI 4.X) or <code>PRTE_MCA_rmaps_default_mapping_policy=:hwtcpus ./run_tests.sh</code> (for OpenMPI 5.X).</p>"},{"location":"adding_software/debugging_failed_builds/#known-causes-of-issues-in-eessi","title":"Known causes of issues in EESSI","text":""},{"location":"adding_software/debugging_failed_builds/#the-custom-system-prefix-of-the-compatibility-layer","title":"The custom system prefix of the compatibility layer","text":"<p>Some installations might expect the system root (sysroot, for short) to be in <code>/</code>. However, in case of EESSI, we are building against the OS in the compatibility layer. Thus, our sysroot is something like <code>${EESSI_CVMFS_REPO}/versions/${EESSI_VERSION}/compat/${EESSI_OS_TYPE}/${EESSI_CPU_FAMILY}</code>. This can cause issues if installation procedures assume the sysroot is in <code>/</code>.</p> <p>One example of a sysroot issue was in installing <code>wget</code>. The EasyConfig for <code>wget</code> defined <pre><code># make sure pkg-config picks up system packages (OpenSSL &amp; co)\npreconfigopts = \"export PKG_CONFIG_PATH=/usr/lib64/pkgconfig:/usr/lib/pkgconfig:/usr/lib/x86_64-linux-gnu/pkgconfig &amp;&amp; \"\nconfigopts = '--with-ssl=openssl '\n</code></pre> This will not work in EESSI, since the OpenSSL should be picked up from the compatibility layer. This was fixed by changing the EasyConfig to read <pre><code>preconfigopts = \"export PKG_CONFIG_PATH=%(sysroot)s/usr/lib64/pkgconfig:%(sysroot)s/usr/lib/pkgconfig:%(sysroot)s/usr/lib/x86_64-linux-gnu/pkgconfig &amp;&amp; \"\nconfigopts = '--with-ssl=openssl\n</code></pre> The <code>%(sysroot)s</code> is a template value which EasyBuild will resolve to the value that has been configured in EasyBuild for <code>sysroot</code> (it is one of the fields printed by <code>eb --show-config</code> if a non-standard sysroot is configured).</p> <p>If you encounter issues where the installation can not find something that is normally provided by the OS (i.e. not one of the dependencies in your module environment), you may need to resort to a similar approach.</p>"},{"location":"adding_software/debugging_failed_builds/#the-writeable-overlay","title":"The writeable overlay","text":"<p>The writeable overlay in the container is known to be a bit slow sometimes. Thus, we have seen tests failing because they exceed some timeout (e.g. this issue).</p> <p>To investigate if the writeable overlay is somehow the issue, you can make sure the installation gets done somewhere else, e.g. in the temporary directory in <code>/tmp</code> that you created as workdir. To do this, set</p> <pre><code>export EASYBUILD_INSTALLPATH=${WORKDIR}\n</code></pre> <p>after the step in which you have sourced the <code>configure_easybuild</code> script. Note that in order to find (with <code>module av</code>) any modules that get installed here, you will need to add this path to the <code>MODULEPATH</code>:</p> <pre><code>module use ${EASYBUILD_INSTALLPATH}/modules/all\n</code></pre> <p>Then, retry building the software (as described above). If the build now succeeds, you know that indeed the writeable overlay caused the issue. We have to build in this writeable overlay when we do real deployments. Thus, if you hit such a timeout, try to see if you can (temporarily) modify the timeout value in the test so that it passes.</p>"},{"location":"adding_software/deploying_software/","title":"Deploying software","text":"<p>(for maintainers)</p>"},{"location":"adding_software/deploying_software/#instructing-the-bot-to-deploy","title":"Instructing the bot to deploy","text":"<p>To make the bot  deploy the successfully built software, you should issue the corresponding instruction to the bot.</p> <p>For more information, see the deploying section in the bot documentation.</p> <p>Warning</p> <p>Permission to trigger deployment of software installations must be granted to your GitHub account first!</p> <p>See bot permissions for more information.</p>"},{"location":"adding_software/deploying_software/#merging-the-pull-request","title":"Merging the pull request","text":"<p>You should be able to verify in the pull request that the ingestion has been done, since the CI should fail  initially to indicate that some software installations listed in your modified easystack are missing.</p> <p>Once the ingestion has been done, simply re-triggering the CI workflow should be sufficient to make it pass , and then the pull request can be merged.</p> <p>Note</p> <p>This assumes that the easystack file being modified is considered by the CI workflow file (<code>.github/workflows/test_eessi.yml</code>) that checks for missing installations, in the correct branch (for example <code>2023.06</code>) of the software-layer.</p> <p>If that's not the case yet, update this workflow in your pull request as well to add the missing easystack file!</p> <p>Warning</p> <p>You need permissions to re-trigger CI workflows and merge pull requests in the software-layer repository.</p> <p>Ask for help in the <code>#software-layer</code> channel of the EESSI Slack if needed!</p>"},{"location":"adding_software/deploying_software/#getting-help","title":"Getting help","text":"<p>If you have any questions, or if you need help with something, don't hesitate to contact us via the <code>#software-layer</code> channel of the EESSI Slack.</p>"},{"location":"adding_software/opening_pr/","title":"Opening a pull request","text":"<p>(for contributors)</p> <p>To add software to EESSI, you should go through the semi-automatic software installation procedure by:</p> <ul> <li>1) Making a pull request to the software-layer repository      to (add or) update an easystack file  that is used by      EasyBuild to install software;</li> <li>2) Instructing the bot  to build the software on all supported CPU microarchitectures;</li> <li>3) Instructing the bot  to deploy the built software for ingestion into the EESSI repository;</li> <li>4) Merging the pull request once CI indicates that the software has been ingested. </li> </ul> <p>Warning</p> <p>Make sure you are also aware of our contribution policy when adding software to EESSI.</p>"},{"location":"adding_software/opening_pr/#preparation","title":"Preparation","text":"<p>Before you can make a pull request to the software-layer, you should fork the repository in your GitHub account.</p> <p>For the remainder of these instructions, we assume that your GitHub account is <code>@koala</code> .</p> <p>Note</p> <p>Don't forget to replace <code>koala</code>  with the name of your GitHub account in the commands below!</p> <p>1) Clone the EESSI/software-layer repository:</p> <pre><code>mkdir EESSI\ncd EESSI\ngit clone https://github.com/EESSI/software-layer\ncd software-layer\n</code></pre> <p>2) Add your fork  as a remote</p> <pre><code>git remote add koala git@github.com:koala/software-layer.git\n</code></pre> <p>3) Check out the branch that corresponds to the version of EESSI repository you want to add software to,    for example <code>2023.06-software.eessi.io</code>:</p> <pre><code>git checkout 2023.06-software.eessi.io\n</code></pre> <p>Note</p> <p>The commands above only need to be run once, to prepare your setup for making pull requests.</p>"},{"location":"adding_software/opening_pr/#software_layer_pull_request","title":"Creating a pull request","text":"<p>1) Make sure that your <code>2023.06-software.eessi.io</code> branch in the checkout of the   <code>EESSI/software-layer</code> repository is up-to-date</p> <pre><code>cd EESSI/software-layer\ngit checkout 2023.06-software.eessi.io \ngit pull origin 2023.06-software.eessi.io \n</code></pre> <p>2) Create a new branch (use a sensible name, not <code>example_branch</code> as below), and check it out</p> <pre><code>git checkout -b example_branch\n</code></pre> <p>3) Determine the correct easystack file to change, and add one or more lines to it that specify which    easyconfigs should be installed</p> <p><pre><code>echo '  - example-1.2.3-GCC-12.3.0.eb' &gt;&gt; easystacks/software.eessi.io/2023.06/eessi-2023.06-eb-4.8.2-2023a.yml\n</code></pre> Note that the naming scheme is standardized and should be <code>eessi-&lt;eessi_version&gt;-eb-&lt;eb_version&gt;-&lt;toolchain_version&gt;.yml</code>. See the official EasyBuild documentation on easystack files for more information on the syntax.</p> <p>4) Stage and commit the changes into your your branch with a sensible message</p> <pre><code>git add easystacks/software.eessi.io/2023.06/eessi-2023.06-eb-4.8.2-2023a.yml\ngit commit -m \"{2023.06}[GCC/12.3.0] example 1.2.3\"\n</code></pre> <p>5) Push your branch to your fork  of the software-layer repository</p> <pre><code>git push koala example_branch\n</code></pre> <p>6) Go to the GitHub web interface to open your pull request,    or use the helpful link that should show up in the output of the <code>git push</code> command.</p> <p>Make sure you target the correct branch: the one that corresponds to the version of EESSI you want to add    software to (like <code>2023.06-software.eessi.io</code>).</p> <p>If all goes well, one or more bots  should almost instantly create a comment in your pull request    with an overview of how it is configured - you will need this information when providing build instructions.</p>"},{"location":"adding_software/opening_pr/#rebuilding_software","title":"Rebuilding software","text":"<p>We typically do not rebuild software, since (strictly speaking) this breaks reproducibility for anyone using the software. However, there are certain situations in which it is difficult or impossible to avoid.</p> <p>To do a rebuild, you add the software you want to rebuild to a dedicated easystack file in the <code>rebuilds</code> directory. Use the following naming convention: <code>YYYYMMDD-eb-&lt;EB_VERSION&gt;-&lt;APPLICATION_NAME&gt;-&lt;APPLICATION_VERSION&gt;-&lt;SHORT_DESCRIPTION&gt;.yml</code>, where <code>YYYYMMDD</code> is the opening date of your PR. E.g. <code>2024.05.06-eb-4.9.1-CUDA-12.1.1-ship-full-runtime.yml</code> was added in a PR on the 6th of May 2024 and used to rebuild CUDA-12.1.1 using EasyBuild 4.9.1 to resolve an issue with some runtime libraries missing from the initial CUDA 12.1.1 installation.</p> <p>At the top of your easystack file, please use comments to include a short description, and make sure to include any relevant links to related issues (e.g. from the GitHub repositories of EESSI, EasyBuild, or the software you are rebuilding).</p> <p>As an example, consider the full easystack file (<code>2024.05.06-eb-4.9.1-CUDA-12.1.1-ship-full-runtime.yml</code>) used for the aforementioned CUDA rebuild: </p> <pre><code># 2024.05.06\n# Original matching of files we could ship was not done correctly. We were\n# matching the basename for files (e.g., libcudart.so from libcudart.so.12)\n# rather than the name stub (libcudart)\n# See https://github.com/EESSI/software-layer/pull/559\neasyconfigs:\n  - CUDA-12.1.1.eb:\n        options:\n                accept-eula-for: CUDA\n</code></pre> <p>By separating rebuilds in dedicated files, we still maintain a complete software bill of materials: it is transparent what got rebuilt, for which reason, and when.</p>"},{"location":"adding_software/overview/","title":"Overview of adding software to EESSI","text":"<p>We welcome contributions to the EESSI software stack. This page shows the procedure and provides links to the contribution policy and the technical details of making a contribution. </p>"},{"location":"adding_software/overview/#contribute-a-software-to-the-eessi-software-stack","title":"Contribute a software to the EESSI software stack","text":"<pre>\n%%{init: { 'theme':'forest', 'sequence': {'useMaxWidth':false} } }%%\nflowchart TB\n    I(contributor)  \n    K(reviewer)\n    A(Is there an EasyConfig for software) --&gt;|No|B(Create an EasyConfig and contribute it to EasyBuild)\n    A --&gt; |Yes|D(Create a PR to software-layer)\n    B --&gt; C(Evaluate and merge pull request)\n    C --&gt; D\n    D --&gt; E(Review PR &amp; trigger builds)\n    E --&gt; F(Debug build issue if needed)\n    F --&gt; G(Deploy tarballs to S3 bucket)\n    G --&gt; H(Ingest tarballs in EESSI by merging staging PRs)\n     classDef blue fill:#9abcff,stroke:#333,stroke-width:2px;\n     class A,B,D,F,I blue\n     click B \"https://easybuild.io/\"\n     click D \"../opening_pr/\"\n     click F \"../debugging_failed_builds/\"\n</pre>"},{"location":"adding_software/overview/#contributing-a-reframe-test-to-the-eessi-test-suite","title":"Contributing a ReFrame test to the EESSI test suite","text":"<p>Ideally, a contributor prepares a ReFrame test for the software to be added to the EESSI software stack. </p> <pre>\n%%{init: { 'theme':'forest', 'sequence': {'useMaxWidth':false} } }%%\nflowchart TB\n\n    Z(Create ReFrame test &amp; PR to tests-suite) --&gt; Y(Review PR &amp; run new test)\n    Y --&gt; W(Debug issue if needed) \n    W --&gt; V(Review PR if needed)\n    V --&gt; U(Merge PR)\n     classDef blue fill:#9abcff,stroke:#333,stroke-width:2px;\n     class Z,W blue\n</pre>"},{"location":"adding_software/overview/#more-about-adding-software-to-eessi","title":"More about adding software to EESSI","text":"<ul> <li>Contribution policy</li> <li>Opening a pull request (for contributors)</li> <li>Building software (for maintainers)</li> <li>Debugging failed builds (for contributors + maintainers)</li> <li>Deploying software (for maintainers)</li> </ul> <p>If you need help with adding software to EESSI, please open a support request.</p>"},{"location":"available_software/overview/","title":"Available software (via modules)","text":"<p>This table gives an overview of all the available software in EESSI per specific CPU target.</p> <p></p> Name aarch64 x86_64 nvidia amd intel"},{"location":"available_software/detail/ALL/","title":"ALL","text":"<p>A Load Balancing Library (ALL) aims to provide an easy way to include dynamicdomain-based load balancing into particle based simulation codes. The libraryis developed in the Simulation Laboratory Molecular Systems of the J\u00fclichSupercomputing Centre at Forschungszentrum J\u00fclich.</p> <p>https://gitlab.jsc.fz-juelich.de/SLMS/loadbalancing</p>"},{"location":"available_software/detail/ALL/#available-modules","title":"Available modules","text":"<p>The overview below shows which ALL installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ALL, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ALL/0.9.2-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ALL/0.9.2-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/AOFlagger/","title":"AOFlagger","text":"<p>The AOFlagger is a tool that can find and remove radio-frequency interference (RFI)in radio astronomical observations. It can make use of Lua scripts to make flagging strategies flexible,and the tools are applicable to a wide set of telescopes.</p> <p>https://aoflagger.readthedocs.io/</p>"},{"location":"available_software/detail/AOFlagger/#available-modules","title":"Available modules","text":"<p>The overview below shows which AOFlagger installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using AOFlagger, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load AOFlagger/3.4.0-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 AOFlagger/3.4.0-foss-2023b x x x x x x x x x x x"},{"location":"available_software/detail/ASE/","title":"ASE","text":"<p>ASE is a python package providing an open source Atomic Simulation Environment in the Python scripting language.From version 3.20.1 we also include the ase-ext package, it contains optional reimplementationsin C of functions in ASE.  ASE uses it automatically when installed.</p> <p>https://wiki.fysik.dtu.dk/ase</p>"},{"location":"available_software/detail/ASE/#available-modules","title":"Available modules","text":"<p>The overview below shows which ASE installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ASE, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ASE/3.22.1-gfbf-2022b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ASE/3.22.1-gfbf-2022b x x x x x x x x x x x"},{"location":"available_software/detail/ASE/#ase3221-gfbf-2022b","title":"ASE/3.22.1-gfbf-2022b","text":"<p>This is a list of extensions included in the module:</p> <p>ase-3.22.1, ase-ext-20.9.0, pytest-mock-3.8.2</p>"},{"location":"available_software/detail/ATK/","title":"ATK","text":"<p>ATK provides the set of accessibility interfaces that are implemented by other toolkits and applications. Using the ATK interfaces, accessibility tools have full access to view and control running applications.</p> <p>https://developer.gnome.org/atk/</p>"},{"location":"available_software/detail/ATK/#available-modules","title":"Available modules","text":"<p>The overview below shows which ATK installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ATK, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ATK/2.38.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ATK/2.38.0-GCCcore-13.2.0 x x x x x x x x x x x ATK/2.38.0-GCCcore-12.3.0 x x x x x x x x x x x ATK/2.38.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Abseil/","title":"Abseil","text":"<p>Abseil is an open-source collection of C++ library code designed to augment theC++ standard library. The Abseil library code is collected from Google's ownC++ code base, has been extensively tested and used in production, and is thesame code we depend on in our daily coding lives.</p> <p>https://abseil.io/</p>"},{"location":"available_software/detail/Abseil/#available-modules","title":"Available modules","text":"<p>The overview below shows which Abseil installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Abseil, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Abseil/20240116.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Abseil/20240116.1-GCCcore-13.2.0 x x x x x x x x x x x Abseil/20230125.3-GCCcore-12.3.0 x x x x x x x x x x x Abseil/20230125.2-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Archive-Zip/","title":"Archive-Zip","text":"<p>Provide an interface to ZIP archive files.</p> <p>https://metacpan.org/pod/Archive::Zip</p>"},{"location":"available_software/detail/Archive-Zip/#available-modules","title":"Available modules","text":"<p>The overview below shows which Archive-Zip installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Archive-Zip, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Archive-Zip/1.68-GCCcore-12.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Archive-Zip/1.68-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Armadillo/","title":"Armadillo","text":"<p>Armadillo is an open-source C++ linear algebra library (matrix maths) aiming towards a good balance between speed and ease of use. Integer, floating point and complex numbers are supported, as well as a subset of trigonometric and statistics functions.</p> <p>https://arma.sourceforge.net/</p>"},{"location":"available_software/detail/Armadillo/#available-modules","title":"Available modules","text":"<p>The overview below shows which Armadillo installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Armadillo, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Armadillo/12.8.0-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Armadillo/12.8.0-foss-2023b x x x x x x x x x x x Armadillo/12.6.2-foss-2023a x x x x x x x x x x x Armadillo/11.4.3-foss-2022b x x x x x x x x x x x"},{"location":"available_software/detail/Arrow/","title":"Arrow","text":"<p>Apache Arrow (incl. PyArrow Python bindings), a cross-language development platform for in-memory data.</p> <p>https://arrow.apache.org</p>"},{"location":"available_software/detail/Arrow/#available-modules","title":"Available modules","text":"<p>The overview below shows which Arrow installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Arrow, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Arrow/16.1.0-gfbf-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Arrow/16.1.0-gfbf-2023b x x x x x x x x x x x Arrow/14.0.1-gfbf-2023a x x x x x x x x x x x Arrow/11.0.0-gfbf-2022b x x x x x x x x x x x"},{"location":"available_software/detail/Arrow/#arrow1610-gfbf-2023b","title":"Arrow/16.1.0-gfbf-2023b","text":"<p>This is a list of extensions included in the module:</p> <p>pyarrow-16.1.0</p>"},{"location":"available_software/detail/Arrow/#arrow1401-gfbf-2023a","title":"Arrow/14.0.1-gfbf-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>pyarrow-14.0.1</p>"},{"location":"available_software/detail/BCFtools/","title":"BCFtools","text":"<p>Samtools is a suite of programs for interacting with high-throughput sequencing data. BCFtools - Reading/writing BCF2/VCF/gVCF files and calling/filtering/summarising SNP and short indel sequence variants</p> <p>https://www.htslib.org/</p>"},{"location":"available_software/detail/BCFtools/#available-modules","title":"Available modules","text":"<p>The overview below shows which BCFtools installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using BCFtools, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load BCFtools/1.18-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 BCFtools/1.18-GCC-12.3.0 x x x x x x x x x x x BCFtools/1.17-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/BLAST%2B/","title":"BLAST+","text":"<p>Basic Local Alignment Search Tool, or BLAST, is an algorithm for comparing primary biological sequence information, such as the amino-acid sequences of different proteins or the nucleotides of DNA sequences.</p> <p>https://blast.ncbi.nlm.nih.gov/</p>"},{"location":"available_software/detail/BLAST%2B/#available-modules","title":"Available modules","text":"<p>The overview below shows which BLAST+ installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using BLAST+, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load BLAST+/2.14.1-gompi-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 BLAST+/2.14.1-gompi-2023a x x x x x x x x x x x BLAST+/2.14.0-gompi-2022b x x x x x x x x x x x"},{"location":"available_software/detail/BLIS/","title":"BLIS","text":"<p>BLIS is a portable software framework for instantiating high-performanceBLAS-like dense linear algebra libraries.</p> <p>https://github.com/flame/blis/</p>"},{"location":"available_software/detail/BLIS/#available-modules","title":"Available modules","text":"<p>The overview below shows which BLIS installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using BLIS, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load BLIS/0.9.0-GCC-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 BLIS/0.9.0-GCC-13.2.0 x x x x x x x x x x x BLIS/0.9.0-GCC-12.3.0 x x x x x x x x x x x BLIS/0.9.0-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/BWA/","title":"BWA","text":"<p>Burrows-Wheeler Aligner (BWA) is an efficient program that aligns relatively short nucleotide sequences against a long reference sequence such as the human genome.</p> <p>http://bio-bwa.sourceforge.net/</p>"},{"location":"available_software/detail/BWA/#available-modules","title":"Available modules","text":"<p>The overview below shows which BWA installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using BWA, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load BWA/0.7.18-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 BWA/0.7.18-GCCcore-12.3.0 x x x x x x x x x x x BWA/0.7.17-20220923-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/BamTools/","title":"BamTools","text":"<p>BamTools provides both a programmer's API and an end-user's toolkit for handling BAM files.</p> <p>https://github.com/pezmaster31/bamtools</p>"},{"location":"available_software/detail/BamTools/#available-modules","title":"Available modules","text":"<p>The overview below shows which BamTools installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using BamTools, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load BamTools/2.5.2-GCC-12.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 BamTools/2.5.2-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Bazel/","title":"Bazel","text":"<p>Bazel is a build tool that builds code quickly and reliably.It is used to build the majority of Google's software.</p> <p>https://bazel.io/</p>"},{"location":"available_software/detail/Bazel/#available-modules","title":"Available modules","text":"<p>The overview below shows which Bazel installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Bazel, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Bazel/6.3.1-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Bazel/6.3.1-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/BeautifulSoup/","title":"BeautifulSoup","text":"<p>Beautiful Soup is a Python library designed for quick turnaround projects like screen-scraping.</p> <p>https://www.crummy.com/software/BeautifulSoup</p>"},{"location":"available_software/detail/BeautifulSoup/#available-modules","title":"Available modules","text":"<p>The overview below shows which BeautifulSoup installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using BeautifulSoup, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load BeautifulSoup/4.12.2-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 BeautifulSoup/4.12.2-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/BeautifulSoup/#beautifulsoup4122-gcccore-1230","title":"BeautifulSoup/4.12.2-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>BeautifulSoup-4.12.2, soupsieve-2.4.1</p>"},{"location":"available_software/detail/Bio-DB-HTS/","title":"Bio-DB-HTS","text":"<p>Read files using HTSlib including BAM/CRAM, Tabix and BCF database files</p> <p>https://metacpan.org/release/Bio-DB-HTS</p>"},{"location":"available_software/detail/Bio-DB-HTS/#available-modules","title":"Available modules","text":"<p>The overview below shows which Bio-DB-HTS installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Bio-DB-HTS, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Bio-DB-HTS/3.01-GCC-12.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Bio-DB-HTS/3.01-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Bio-SearchIO-hmmer/","title":"Bio-SearchIO-hmmer","text":"<p>Code to parse output from hmmsearch, hmmscan, phmmer and nhmmer, compatiblewith both version 2 and version 3 of the HMMER package from http://hmmer.org.</p> <p>https://metacpan.org/pod/Bio::SearchIO::hmmer3</p>"},{"location":"available_software/detail/Bio-SearchIO-hmmer/#available-modules","title":"Available modules","text":"<p>The overview below shows which Bio-SearchIO-hmmer installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Bio-SearchIO-hmmer, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Bio-SearchIO-hmmer/1.7.3-GCC-12.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Bio-SearchIO-hmmer/1.7.3-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/BioPerl/","title":"BioPerl","text":"<p>Bioperl is the product of a community effort to produce Perl code which is useful in biology. Examples include Sequence objects, Alignment objects and database searching objects.</p> <p>https://bioperl.org/</p>"},{"location":"available_software/detail/BioPerl/#available-modules","title":"Available modules","text":"<p>The overview below shows which BioPerl installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using BioPerl, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load BioPerl/1.7.8-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 BioPerl/1.7.8-GCCcore-12.3.0 x x x x x x x x x x x BioPerl/1.7.8-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/BioPerl/#bioperl178-gcccore-1230","title":"BioPerl/1.7.8-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>Bio::Procedural-1.7.4, BioPerl-1.7.8, XML::Writer-0.900</p>"},{"location":"available_software/detail/BioPerl/#bioperl178-gcccore-1220","title":"BioPerl/1.7.8-GCCcore-12.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>Bio::Procedural-1.7.4, BioPerl-1.7.8, XML::Writer-0.900</p>"},{"location":"available_software/detail/Biopython/","title":"Biopython","text":"<p>Biopython is a set of freely available tools for biological computation written in Python by an international team of developers. It is a distributed collaborative effort to develop Python libraries and applications which address the needs of current and future work in bioinformatics.</p> <p>https://www.biopython.org</p>"},{"location":"available_software/detail/Biopython/#available-modules","title":"Available modules","text":"<p>The overview below shows which Biopython installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Biopython, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Biopython/1.83-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Biopython/1.83-foss-2023a x x x x x x x x x x x Biopython/1.81-foss-2022b x x x x x x x x x x x"},{"location":"available_software/detail/Bison/","title":"Bison","text":"<p>Bison is a general-purpose parser generator that converts an annotated context-free grammar into a deterministic LR or generalized LR (GLR) parser employing LALR(1) parser tables.</p> <p>https://www.gnu.org/software/bison</p>"},{"location":"available_software/detail/Bison/#available-modules","title":"Available modules","text":"<p>The overview below shows which Bison installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Bison, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Bison/3.8.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Bison/3.8.2-GCCcore-13.2.0 x x x x x x x x x x x Bison/3.8.2-GCCcore-12.3.0 x x x x x x x x x x x Bison/3.8.2-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Boost.MPI/","title":"Boost.MPI","text":"<p>Boost provides free peer-reviewed portable C++ source libraries.</p> <p>https://www.boost.org/</p>"},{"location":"available_software/detail/Boost.MPI/#available-modules","title":"Available modules","text":"<p>The overview below shows which Boost.MPI installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Boost.MPI, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Boost.MPI/1.83.0-gompi-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Boost.MPI/1.83.0-gompi-2023b x x x x x x x x x x x Boost.MPI/1.82.0-gompi-2023a x x x x x x x x x x x Boost.MPI/1.81.0-gompi-2022b x x x x x x x x x x x"},{"location":"available_software/detail/Boost.Python/","title":"Boost.Python","text":"<p>Boost.Python is a C++ library which enables seamless interoperability between C++ and the Python programming language.</p> <p>https://boostorg.github.io/python</p>"},{"location":"available_software/detail/Boost.Python/#available-modules","title":"Available modules","text":"<p>The overview below shows which Boost.Python installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Boost.Python, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Boost.Python/1.83.0-GCC-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Boost.Python/1.83.0-GCC-13.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Boost/","title":"Boost","text":"<p>Boost provides free peer-reviewed portable C++ source libraries.</p> <p>https://www.boost.org/</p>"},{"location":"available_software/detail/Boost/#available-modules","title":"Available modules","text":"<p>The overview below shows which Boost installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Boost, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Boost/1.83.0-GCC-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Boost/1.83.0-GCC-13.2.0 x x x x x x x x x x x Boost/1.82.0-GCC-12.3.0 x x x x x x x x x x x Boost/1.81.0-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Bowtie2/","title":"Bowtie2","text":"<p>Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters, and particularly good at aligning to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an FM Index to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 GB. Bowtie 2 supports gapped, local, and paired-end alignment modes.</p> <p>https://bowtie-bio.sourceforge.net/bowtie2/index.shtml</p>"},{"location":"available_software/detail/Bowtie2/#available-modules","title":"Available modules","text":"<p>The overview below shows which Bowtie2 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Bowtie2, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Bowtie2/2.5.1-GCC-12.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Bowtie2/2.5.1-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Brotli/","title":"Brotli","text":"<p>Brotli is a generic-purpose lossless compression algorithm that compresses data using a combination of a modern variant of the LZ77 algorithm, Huffman coding and 2nd order context modeling, with a compression ratio comparable to the best currently available general-purpose compression methods. It is similar in speed with deflate but offers more dense compression.The specification of the Brotli Compressed Data Format is defined in RFC 7932.</p> <p>https://github.com/google/brotli</p>"},{"location":"available_software/detail/Brotli/#available-modules","title":"Available modules","text":"<p>The overview below shows which Brotli installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Brotli, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Brotli/1.1.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Brotli/1.1.0-GCCcore-13.2.0 x x x x x x x x x x x Brotli/1.0.9-GCCcore-12.3.0 x x x x x x x x x x x Brotli/1.0.9-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Brunsli/","title":"Brunsli","text":"<p>Brunsli is a lossless JPEG repacking library.</p> <p>https://github.com/google/brunsli/</p>"},{"location":"available_software/detail/Brunsli/#available-modules","title":"Available modules","text":"<p>The overview below shows which Brunsli installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Brunsli, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Brunsli/0.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Brunsli/0.1-GCCcore-13.2.0 x x x x x x x x x x x Brunsli/0.1-GCCcore-12.3.0 x x x x x x x x x x x Brunsli/0.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/CD-HIT/","title":"CD-HIT","text":"<p>CD-HIT is a very widely used program for clustering and  comparing protein or nucleotide sequences.</p> <p>http://weizhongli-lab.org/cd-hit/</p>"},{"location":"available_software/detail/CD-HIT/#available-modules","title":"Available modules","text":"<p>The overview below shows which CD-HIT installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using CD-HIT, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load CD-HIT/4.8.1-GCC-12.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 CD-HIT/4.8.1-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/CDO/","title":"CDO","text":"<p>CDO is a collection of command line Operators to manipulate and analyse Climate and NWP model Data.</p> <p>https://code.zmaw.de/projects/cdo</p>"},{"location":"available_software/detail/CDO/#available-modules","title":"Available modules","text":"<p>The overview below shows which CDO installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using CDO, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load CDO/2.2.2-gompi-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 CDO/2.2.2-gompi-2023b x x x x x x x x x x x CDO/2.2.2-gompi-2023a x x x x x x x x x x x"},{"location":"available_software/detail/CFITSIO/","title":"CFITSIO","text":"<p>CFITSIO is a library of C and Fortran subroutines for reading and writing data files inFITS (Flexible Image Transport System) data format.</p> <p>https://heasarc.gsfc.nasa.gov/fitsio/</p>"},{"location":"available_software/detail/CFITSIO/#available-modules","title":"Available modules","text":"<p>The overview below shows which CFITSIO installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using CFITSIO, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load CFITSIO/4.3.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 CFITSIO/4.3.1-GCCcore-13.2.0 x x x x x x x x x x x CFITSIO/4.3.0-GCCcore-12.3.0 x x x x x x x x x x x CFITSIO/4.2.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/CGAL/","title":"CGAL","text":"<p>The goal of the CGAL Open Source Project is to provide easy access to efficient and reliable geometric algorithms in the form of a C++ library.</p> <p>https://www.cgal.org/</p>"},{"location":"available_software/detail/CGAL/#available-modules","title":"Available modules","text":"<p>The overview below shows which CGAL installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using CGAL, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load CGAL/5.6-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 CGAL/5.6-GCCcore-12.3.0 x x x x x x x x x x x CGAL/5.5.2-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/CMake/","title":"CMake","text":"<p>CMake, the cross-platform, open-source build system.  CMake is a family of tools designed to build, test and package software.</p> <p>https://www.cmake.org</p>"},{"location":"available_software/detail/CMake/#available-modules","title":"Available modules","text":"<p>The overview below shows which CMake installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using CMake, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load CMake/3.27.6-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 CMake/3.27.6-GCCcore-13.2.0 x x x x x x x x x x x CMake/3.26.3-GCCcore-12.3.0 x x x x x x x x x x x CMake/3.24.3-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/CP2K/","title":"CP2K","text":"<p>CP2K is a freely available (GPL) program, written in Fortran 95, to perform atomistic and molecular simulations of solid state, liquid, molecular and biological systems. It provides a general framework for different methods such as e.g. density functional theory (DFT) using a mixed Gaussian and plane waves approach (GPW), and classical pair and many-body potentials.</p> <p>https://www.cp2k.org/</p>"},{"location":"available_software/detail/CP2K/#available-modules","title":"Available modules","text":"<p>The overview below shows which CP2K installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using CP2K, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load CP2K/2023.1-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 CP2K/2023.1-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/CapnProto/","title":"CapnProto","text":"<p>Cap\u2019n Proto is an insanely fast data interchange format and capability-based RPC system.</p> <p>https://capnproto.org</p>"},{"location":"available_software/detail/CapnProto/#available-modules","title":"Available modules","text":"<p>The overview below shows which CapnProto installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using CapnProto, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load CapnProto/1.0.1-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 CapnProto/1.0.1-GCCcore-12.3.0 x x x x x x x x x x x CapnProto/0.10.3-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Cartopy/","title":"Cartopy","text":"<p>Cartopy is a Python package designed to make drawing maps for data analysis and visualisation easy.</p> <p>https://scitools.org.uk/cartopy/docs/latest/</p>"},{"location":"available_software/detail/Cartopy/#available-modules","title":"Available modules","text":"<p>The overview below shows which Cartopy installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Cartopy, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Cartopy/0.22.0-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Cartopy/0.22.0-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/Cartopy/#cartopy0220-foss-2023a","title":"Cartopy/0.22.0-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>Cartopy-0.22.0, OWSLib-0.29.3, pyepsg-0.4.0, pykdtree-1.3.10, pyshp-2.3.1</p>"},{"location":"available_software/detail/Cassiopeia/","title":"Cassiopeia","text":"<p>A Package for Cas9-Enabled Single Cell Lineage Tracing Tree Reconstruction.</p> <p>https://github.com/YosefLab/Cassiopeia</p>"},{"location":"available_software/detail/Cassiopeia/#available-modules","title":"Available modules","text":"<p>The overview below shows which Cassiopeia installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Cassiopeia, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Cassiopeia/2.0.0-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Cassiopeia/2.0.0-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/Cassiopeia/#cassiopeia200-foss-2023a","title":"Cassiopeia/2.0.0-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>bleach-6.1.0, Cassiopeia-2.0.0, comm-0.2.2, defusedxml-0.7.1, deprecation-2.1.0, fastjsonschema-2.19.1, hits-0.4.0, ipywidgets-8.1.2, itolapi-4.1.4, jupyter_client-8.6.1, jupyter_core-5.7.2, jupyter_packaging-0.12.3, jupyterlab_pygments-0.3.0, jupyterlab_widgets-3.0.10, Levenshtein-0.22.0, mistune-3.0.2, nbclient-0.10.0, nbconvert-7.16.3, nbformat-5.10.3, ngs-tools-1.8.5, pandocfilters-1.5.1, python-Levenshtein-0.22.0, shortuuid-1.0.13, tinycss2-1.2.1, traitlets-5.14.2, widgetsnbextension-4.0.10</p>"},{"location":"available_software/detail/Catch2/","title":"Catch2","text":"<p>A modern, C++-native, header-only, test framework for unit-tests, TDD and BDD - using C++11, C++14, C++17 and later</p> <p>https://github.com/catchorg/Catch2</p>"},{"location":"available_software/detail/Catch2/#available-modules","title":"Available modules","text":"<p>The overview below shows which Catch2 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Catch2, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Catch2/2.13.9-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Catch2/2.13.9-GCCcore-13.2.0 x x x x x x x x x x x Catch2/2.13.9-GCCcore-12.3.0 x x x x x x x x x x x Catch2/2.13.9-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Cbc/","title":"Cbc","text":"<p>Cbc (Coin-or branch and cut) is an open-source mixed integer linear programmingsolver written in C++. It can be used as a callable library or using astand-alone executable.</p> <p>https://github.com/coin-or/Cbc</p>"},{"location":"available_software/detail/Cbc/#available-modules","title":"Available modules","text":"<p>The overview below shows which Cbc installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Cbc, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Cbc/2.10.11-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Cbc/2.10.11-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/Cgl/","title":"Cgl","text":"<p>The COIN-OR Cut Generation Library (Cgl) is a collection of cut generators thatcan be used with other COIN-OR packages that make use of cuts, such as, amongothers, the linear solver Clp or the mixed integer linear programming solversCbc or BCP. Cgl uses the abstract class OsiSolverInterface (see Osi) to use orcommunicate with a solver. It does not directly call a solver.</p> <p>https://github.com/coin-or/Cgl</p>"},{"location":"available_software/detail/Cgl/#available-modules","title":"Available modules","text":"<p>The overview below shows which Cgl installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Cgl, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Cgl/0.60.8-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Cgl/0.60.8-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/Clp/","title":"Clp","text":"<p>Clp (Coin-or linear programming) is an open-source linear programming solver.It is primarily meant to be used as a callable library, but a basic,stand-alone executable version is also available.</p> <p>https://github.com/coin-or/Clp</p>"},{"location":"available_software/detail/Clp/#available-modules","title":"Available modules","text":"<p>The overview below shows which Clp installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Clp, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Clp/1.17.9-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Clp/1.17.9-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/CoinUtils/","title":"CoinUtils","text":"<p>CoinUtils (Coin-OR Utilities) is an open-source collection of classes andfunctions that are generally useful to more than one COIN-OR project.</p> <p>https://github.com/coin-or/CoinUtils</p>"},{"location":"available_software/detail/CoinUtils/#available-modules","title":"Available modules","text":"<p>The overview below shows which CoinUtils installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using CoinUtils, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load CoinUtils/2.11.10-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 CoinUtils/2.11.10-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Critic2/","title":"Critic2","text":"<p>Critic2 is a program for the analysis of quantum mechanicalcalculation results in molecules and periodic solids.</p> <p>https://aoterodelaroza.github.io/critic2/</p>"},{"location":"available_software/detail/Critic2/#available-modules","title":"Available modules","text":"<p>The overview below shows which Critic2 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Critic2, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Critic2/1.2-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Critic2/1.2-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/CubeLib/","title":"CubeLib","text":"<p>Cube, which is used as performance report explorer for Scalasca and Score-P, is a generic tool for displaying a multi-dimensional performance space consisting of the dimensions (i) performance metric, (ii) call path, and (iii) system resource. Each dimension can be represented as a tree, where non-leaf nodes of the tree can be collapsed or expanded to achieve the desired level of granularity. This module provides the Cube general purpose C++ library component and command-line tools.</p> <p>https://www.scalasca.org/software/cube-4.x/download.html</p>"},{"location":"available_software/detail/CubeLib/#available-modules","title":"Available modules","text":"<p>The overview below shows which CubeLib installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using CubeLib, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load CubeLib/4.8.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 CubeLib/4.8.2-GCCcore-13.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/CubeWriter/","title":"CubeWriter","text":"<p>Cube, which is used as performance report explorer for Scalasca and Score-P, is a generic tool for displaying a multi-dimensional performance space consisting of the dimensions (i) performance metric, (ii) call path, and (iii) system resource. Each dimension can be represented as a tree, where non-leaf nodes of the tree can be collapsed or expanded to achieve the desired level of granularity. This module provides the Cube high-performance C writer library component.</p> <p>https://www.scalasca.org/software/cube-4.x/download.html</p>"},{"location":"available_software/detail/CubeWriter/#available-modules","title":"Available modules","text":"<p>The overview below shows which CubeWriter installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using CubeWriter, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load CubeWriter/4.8.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 CubeWriter/4.8.2-GCCcore-13.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Cython/","title":"Cython","text":"<p>Cython is an optimising static compiler for both the Python programminglanguage and the extended Cython programming language (based on Pyrex).</p> <p>https://cython.org/</p>"},{"location":"available_software/detail/Cython/#available-modules","title":"Available modules","text":"<p>The overview below shows which Cython installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Cython, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Cython/3.0.10-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Cython/3.0.10-GCCcore-13.2.0 x x x x x x x x x x x Cython/3.0.8-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/DB/","title":"DB","text":"<p>Berkeley DB enables the development of custom data management solutions, without the overhead traditionally associated with such custom projects.</p> <p>https://www.oracle.com/technetwork/products/berkeleydb</p>"},{"location":"available_software/detail/DB/#available-modules","title":"Available modules","text":"<p>The overview below shows which DB installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using DB, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load DB/18.1.40-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 DB/18.1.40-GCCcore-12.3.0 x x x x x x x x x x x DB/18.1.40-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/DB_File/","title":"DB_File","text":"<p>Perl5 access to Berkeley DB version 1.x.</p> <p>https://perldoc.perl.org/DB_File.html</p>"},{"location":"available_software/detail/DB_File/#available-modules","title":"Available modules","text":"<p>The overview below shows which DB_File installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using DB_File, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load DB_File/1.859-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 DB_File/1.859-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/DIAMOND/","title":"DIAMOND","text":"<p>Accelerated BLAST compatible local sequence aligner</p> <p>https://github.com/bbuchfink/diamond</p>"},{"location":"available_software/detail/DIAMOND/#available-modules","title":"Available modules","text":"<p>The overview below shows which DIAMOND installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using DIAMOND, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load DIAMOND/2.1.8-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 DIAMOND/2.1.8-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/DP3/","title":"DP3","text":"<p>DP3: streaming processing pipeline for radio interferometric data.</p> <p>https://dp3.readthedocs.io/</p>"},{"location":"available_software/detail/DP3/#available-modules","title":"Available modules","text":"<p>The overview below shows which DP3 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using DP3, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load DP3/6.2-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 DP3/6.2-foss-2023b x x x x x x x x x x x DP3/6.0-foss-2023b x x x x x x x x x x x"},{"location":"available_software/detail/DendroPy/","title":"DendroPy","text":"<p>A Python library for phylogenetics and phylogenetic computing: reading, writing, simulation, processing and manipulation of phylogenetic trees (phylogenies) and characters.</p> <p>https://dendropy.org/</p>"},{"location":"available_software/detail/DendroPy/#available-modules","title":"Available modules","text":"<p>The overview below shows which DendroPy installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using DendroPy, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load DendroPy/4.6.1-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 DendroPy/4.6.1-GCCcore-12.3.0 x x x x x x x x x x x DendroPy/4.5.2-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Doxygen/","title":"Doxygen","text":"<p>Doxygen is a documentation system for C++, C, Java, Objective-C, Python, IDL (Corba and Microsoft flavors), Fortran, VHDL, PHP, C#, and to some extent D.</p> <p>https://www.doxygen.org</p>"},{"location":"available_software/detail/Doxygen/#available-modules","title":"Available modules","text":"<p>The overview below shows which Doxygen installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Doxygen, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Doxygen/1.9.8-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Doxygen/1.9.8-GCCcore-13.2.0 x x x x x x x x x x x Doxygen/1.9.7-GCCcore-12.3.0 x x x x x x x x x x x Doxygen/1.9.5-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/EESSI-extend/","title":"EESSI-extend","text":"<p>The goal of the European Environment for Scientific Software Installations (EESSI, pronounced as \"easy\") is to build a common stack of scientific software installations for HPC systems and beyond, including laptops, personal workstations and cloud infrastructure. This module allows you to extend EESSI using the same configuration for EasyBuild as EESSI itself uses. A number of environment variables control the behaviour of the module: - EESSI_USER_INSTALL can be set to a location to install modules for use by   the user only. The location must already exist on the filesystem. - EESSI_PROJECT_INSTALL can be set to a location to install modules for use by   a project. The location must already exist on the filesystem and you should   ensure that the location has the correct Linux group and the SGID permission   is set on that directory (<code>chmod g+s $EESSI_PROJECT_INSTALL</code>) so that all   members of the group have permission to read and write installations. - EESSI_SITE_INSTALL is either defined or not and cannot be used with another   environment variable. A site installation is done in a defined location and   any installations there are (by default) world readable. - EESSI_CVMFS_INSTALL is either defined or not and cannot be used with another   environment variable. A CVMFS installation targets a defined location which   will be ingested into CVMFS and is only useful for CVMFS administrators. - If none of the environment variables above are defined, an EESSI_USER_INSTALL   is assumed with a value of $HOME/EESSI If both EESSI_USER_INSTALL and EESSI_PROJECT_INSTALL are defined, both sets of installations are exposed, but new installations are created as user installations.</p> <p>https://eessi.io/docs/</p>"},{"location":"available_software/detail/EESSI-extend/#available-modules","title":"Available modules","text":"<p>The overview below shows which EESSI-extend installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using EESSI-extend, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load EESSI-extend/2023.06-easybuild\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 EESSI-extend/2023.06-easybuild x x x x x x x x x x x"},{"location":"available_software/detail/ELPA/","title":"ELPA","text":"<p>Eigenvalue SoLvers for Petaflop-Applications.</p> <p>https://elpa.mpcdf.mpg.de/</p>"},{"location":"available_software/detail/ELPA/#available-modules","title":"Available modules","text":"<p>The overview below shows which ELPA installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ELPA, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ELPA/2023.05.001-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ELPA/2023.05.001-foss-2023a x x x x x x x x x x x ELPA/2022.05.001-foss-2022b x x x x x x x x x x x"},{"location":"available_software/detail/ESPResSo/","title":"ESPResSo","text":"<p>A software package for performing and analyzing scientific Molecular Dynamics simulations.</p> <p>https://espressomd.org/wordpress</p>"},{"location":"available_software/detail/ESPResSo/#available-modules","title":"Available modules","text":"<p>The overview below shows which ESPResSo installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ESPResSo, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ESPResSo/4.2.2-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ESPResSo/4.2.2-foss-2023b x x x x x x x x x x x ESPResSo/4.2.2-foss-2023a x x x x x x x x x x x ESPResSo/4.2.1-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/ETE/","title":"ETE","text":"<p>A Python framework for the analysis and visualization of trees</p> <p>http://etetoolkit.org</p>"},{"location":"available_software/detail/ETE/#available-modules","title":"Available modules","text":"<p>The overview below shows which ETE installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ETE, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ETE/3.1.3-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ETE/3.1.3-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/EasyBuild/","title":"EasyBuild","text":"<p>EasyBuild is a software build and installation framework written in Python that allows you to install software in a structured, repeatable and robust way.</p> <p>https://easybuilders.github.io/easybuild</p>"},{"location":"available_software/detail/EasyBuild/#available-modules","title":"Available modules","text":"<p>The overview below shows which EasyBuild installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using EasyBuild, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load EasyBuild/5.0.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 EasyBuild/5.0.0 x x x x x x x x x x x EasyBuild/4.9.4 x x x x x x x x x x x EasyBuild/4.9.3 x x x x x x x x x x x EasyBuild/4.9.2 x x x x x x x x x x x EasyBuild/4.9.1 x x x x x x x x x x x EasyBuild/4.9.0 x x x x x x x x x x x EasyBuild/4.8.2 x x x x x x x x x x x"},{"location":"available_software/detail/Eigen/","title":"Eigen","text":"<p>Eigen is a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms.</p> <p>https://eigen.tuxfamily.org</p>"},{"location":"available_software/detail/Eigen/#available-modules","title":"Available modules","text":"<p>The overview below shows which Eigen installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Eigen, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Eigen/3.4.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Eigen/3.4.0-GCCcore-13.2.0 x x x x x x x x x x x Eigen/3.4.0-GCCcore-12.3.0 x x x x x x x x x x x Eigen/3.4.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/EveryBeam/","title":"EveryBeam","text":"<p>Library that provides the antenna response pattern for several instruments,such as LOFAR (and LOBES), SKA (OSKAR), MWA, JVLA, etc.</p> <p>https://everybeam.readthedocs.io/</p>"},{"location":"available_software/detail/EveryBeam/#available-modules","title":"Available modules","text":"<p>The overview below shows which EveryBeam installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using EveryBeam, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load EveryBeam/0.6.1-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 EveryBeam/0.6.1-foss-2023b x x x x x x x x x x x EveryBeam/0.5.2-foss-2023b x x x x x x x x x x x"},{"location":"available_software/detail/Extrae/","title":"Extrae","text":"<p>Extrae is the package devoted to generate Paraver trace-files for a post-mortem analysis.Extrae is a tool that uses different interposition mechanisms to inject probes into the target applicationso as to gather information regarding the application performance.</p> <p>https://tools.bsc.es/extrae</p>"},{"location":"available_software/detail/Extrae/#available-modules","title":"Available modules","text":"<p>The overview below shows which Extrae installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Extrae, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Extrae/4.2.0-gompi-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Extrae/4.2.0-gompi-2023b x x x x x x x x x x x"},{"location":"available_software/detail/FALL3D/","title":"FALL3D","text":"<p>FALL3D is an open-source volcanic ash dispersal model.</p> <p>https://gitlab.com/fall3d-suite/fall3d</p>"},{"location":"available_software/detail/FALL3D/#available-modules","title":"Available modules","text":"<p>The overview below shows which FALL3D installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using FALL3D, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load FALL3D/9.0.1-gompi-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 FALL3D/9.0.1-gompi-2023a x x x x x x x x x x x"},{"location":"available_software/detail/FFTW.MPI/","title":"FFTW.MPI","text":"<p>FFTW is a C subroutine library for computing the discrete Fourier transform (DFT)in one or more dimensions, of arbitrary input size, and of both real and complex data.</p> <p>https://www.fftw.org</p>"},{"location":"available_software/detail/FFTW.MPI/#available-modules","title":"Available modules","text":"<p>The overview below shows which FFTW.MPI installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using FFTW.MPI, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load FFTW.MPI/3.3.10-gompi-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 FFTW.MPI/3.3.10-gompi-2023b x x x x x x x x x x x FFTW.MPI/3.3.10-gompi-2023a x x x x x x x x x x x FFTW.MPI/3.3.10-gompi-2022b x x x x x x x x x x x"},{"location":"available_software/detail/FFTW/","title":"FFTW","text":"<p>FFTW is a C subroutine library for computing the discrete Fourier transform (DFT)in one or more dimensions, of arbitrary input size, and of both real and complex data.</p> <p>https://www.fftw.org</p>"},{"location":"available_software/detail/FFTW/#available-modules","title":"Available modules","text":"<p>The overview below shows which FFTW installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using FFTW, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load FFTW/3.3.10-GCC-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 FFTW/3.3.10-GCC-13.2.0 x x x x x x x x x x x FFTW/3.3.10-GCC-12.3.0 x x x x x x x x x x x FFTW/3.3.10-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/FFmpeg/","title":"FFmpeg","text":"<p>A complete, cross-platform solution to record, convert and stream audio and video.</p> <p>https://www.ffmpeg.org/</p>"},{"location":"available_software/detail/FFmpeg/#available-modules","title":"Available modules","text":"<p>The overview below shows which FFmpeg installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using FFmpeg, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load FFmpeg/6.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 FFmpeg/6.0-GCCcore-13.2.0 x x x x x x x x x x x FFmpeg/6.0-GCCcore-12.3.0 x x x x x x x x x x x FFmpeg/5.1.2-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/FLAC/","title":"FLAC","text":"<p>FLAC stands for Free Lossless Audio Codec, an audio format similar to MP3, but lossless, meaningthat audio is compressed in FLAC without any loss in quality.</p> <p>https://xiph.org/flac/</p>"},{"location":"available_software/detail/FLAC/#available-modules","title":"Available modules","text":"<p>The overview below shows which FLAC installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using FLAC, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load FLAC/1.4.3-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 FLAC/1.4.3-GCCcore-13.2.0 x x x x x x x x x x x FLAC/1.4.2-GCCcore-12.3.0 x x x x x x x x x x x FLAC/1.4.2-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/FLTK/","title":"FLTK","text":"<p>FLTK is a cross-platform C++ GUI toolkit for UNIX/Linux (X11), Microsoft Windows, and MacOS X. FLTK provides modern GUI functionality without the bloat and supports 3D graphics via OpenGL and its built-in GLUT emulation.</p> <p>https://www.fltk.org</p>"},{"location":"available_software/detail/FLTK/#available-modules","title":"Available modules","text":"<p>The overview below shows which FLTK installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using FLTK, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load FLTK/1.3.8-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 FLTK/1.3.8-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/FastME/","title":"FastME","text":"<p>FastME: a comprehensive, accurate and fast distance-based phylogeny inference program.</p> <p>http://www.atgc-montpellier.fr/fastme/</p>"},{"location":"available_software/detail/FastME/#available-modules","title":"Available modules","text":"<p>The overview below shows which FastME installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using FastME, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load FastME/2.1.6.3-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 FastME/2.1.6.3-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Fiona/","title":"Fiona","text":"<p>Fiona is designed to be simple and dependable. It focuses on reading and writing datain standard Python IO style and relies upon familiar Python types and protocols such as files, dictionaries,mappings, and iterators instead of classes specific to OGR. Fiona can read and write real-world data usingmulti-layered GIS formats and zipped virtual file systems and integrates readily with other Python GISpackages such as pyproj, Rtree, and Shapely.</p> <p>https://github.com/Toblerity/Fiona</p>"},{"location":"available_software/detail/Fiona/#available-modules","title":"Available modules","text":"<p>The overview below shows which Fiona installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Fiona, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Fiona/1.9.5-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Fiona/1.9.5-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/Fiona/#fiona195-foss-2023a","title":"Fiona/1.9.5-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>click-plugins-1.1.1, cligj-0.7.2, fiona-1.9.5, munch-4.0.0</p>"},{"location":"available_software/detail/Flask/","title":"Flask","text":"<p>Flask is a lightweight WSGI web application framework. It is designed to makegetting started quick and easy, with the ability to scale up to complexapplications.This module includes the Flask extensions: Flask-Cors</p> <p>https://www.palletsprojects.com/p/flask/</p>"},{"location":"available_software/detail/Flask/#available-modules","title":"Available modules","text":"<p>The overview below shows which Flask installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Flask, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Flask/2.2.3-GCCcore-12.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Flask/2.2.3-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Flask/#flask223-gcccore-1220","title":"Flask/2.2.3-GCCcore-12.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>asgiref-3.6.0, cachelib-0.10.2, Flask-2.2.3, Flask-Cors-3.0.10, Flask-Session-0.4.0, itsdangerous-2.1.2, Werkzeug-2.2.3</p>"},{"location":"available_software/detail/FlexiBLAS/","title":"FlexiBLAS","text":"<p>FlexiBLAS is a wrapper library that enables the exchange of the BLAS and LAPACK implementationused by a program without recompiling or relinking it.</p> <p>https://gitlab.mpi-magdeburg.mpg.de/software/flexiblas-release</p>"},{"location":"available_software/detail/FlexiBLAS/#available-modules","title":"Available modules","text":"<p>The overview below shows which FlexiBLAS installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using FlexiBLAS, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load FlexiBLAS/3.3.1-GCC-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 FlexiBLAS/3.3.1-GCC-13.2.0 x x x x x x x x x x x FlexiBLAS/3.3.1-GCC-12.3.0 x x x x x x x x x x x FlexiBLAS/3.2.1-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/FragGeneScan/","title":"FragGeneScan","text":"<p>FragGeneScan is an application for finding (fragmented) genes in short reads.</p> <p>https://omics.informatics.indiana.edu/FragGeneScan/</p>"},{"location":"available_software/detail/FragGeneScan/#available-modules","title":"Available modules","text":"<p>The overview below shows which FragGeneScan installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using FragGeneScan, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load FragGeneScan/1.31-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 FragGeneScan/1.31-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/FreeImage/","title":"FreeImage","text":"<p>FreeImage is an Open Source library project for developers who would like to support popular graphicsimage formats like PNG, BMP, JPEG, TIFF and others as needed by today's multimedia applications. FreeImage is easy touse, fast, multithreading safe.</p> <p>http://freeimage.sourceforge.net</p>"},{"location":"available_software/detail/FreeImage/#available-modules","title":"Available modules","text":"<p>The overview below shows which FreeImage installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using FreeImage, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load FreeImage/3.18.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 FreeImage/3.18.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/FriBidi/","title":"FriBidi","text":"<p>The Free Implementation of the Unicode Bidirectional Algorithm.</p> <p>https://github.com/fribidi/fribidi</p>"},{"location":"available_software/detail/FriBidi/#available-modules","title":"Available modules","text":"<p>The overview below shows which FriBidi installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using FriBidi, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load FriBidi/1.0.13-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 FriBidi/1.0.13-GCCcore-13.2.0 x x x x x x x x x x x FriBidi/1.0.12-GCCcore-12.3.0 x x x x x x x x x x x FriBidi/1.0.12-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/GATK/","title":"GATK","text":"<p>The Genome Analysis Toolkit or GATK is a software package developed at the Broad Institute to analyse next-generation resequencing data. The toolkit offers a wide variety of tools, with a primary focus on variant discovery and genotyping as well as strong emphasis on data quality assurance. Its robust architecture, powerful processing engine and high-performance computing features make it capable of taking on projects of any size.</p> <p>https://www.broadinstitute.org/gatk/</p>"},{"location":"available_software/detail/GATK/#available-modules","title":"Available modules","text":"<p>The overview below shows which GATK installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GATK, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GATK/4.5.0.0-GCCcore-12.3.0-Java-17\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GATK/4.5.0.0-GCCcore-12.3.0-Java-17 x x x x x x x x x x x"},{"location":"available_software/detail/GCC/","title":"GCC","text":"<p>The GNU Compiler Collection includes front ends for C, C++, Objective-C, Fortran, Java, and Ada, as well as libraries for these languages (libstdc++, libgcj,...).</p> <p>https://gcc.gnu.org/</p>"},{"location":"available_software/detail/GCC/#available-modules","title":"Available modules","text":"<p>The overview below shows which GCC installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GCC, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GCC/13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GCC/13.2.0 x x x x x x x x x x x GCC/12.3.0 x x x x x x x x x x x GCC/12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/GCCcore/","title":"GCCcore","text":"<p>The GNU Compiler Collection includes front ends for C, C++, Objective-C, Fortran, Java, and Ada, as well as libraries for these languages (libstdc++, libgcj,...).</p> <p>https://gcc.gnu.org/</p>"},{"location":"available_software/detail/GCCcore/#available-modules","title":"Available modules","text":"<p>The overview below shows which GCCcore installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GCCcore, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GCCcore/13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GCCcore/13.2.0 x x x x x x x x x x x GCCcore/12.3.0 x x x x x x x x x x x GCCcore/12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/GDAL/","title":"GDAL","text":"<p>GDAL is a translator library for raster geospatial data formats that is released under an X/MIT style Open Source license by the Open Source Geospatial Foundation. As a library, it presents a single abstract data model to the calling application for all supported formats. It also comes with a variety of useful commandline utilities for data translation and processing.</p> <p>https://www.gdal.org</p>"},{"location":"available_software/detail/GDAL/#available-modules","title":"Available modules","text":"<p>The overview below shows which GDAL installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GDAL, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GDAL/3.9.0-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GDAL/3.9.0-foss-2023b x x x x x x x x x x x GDAL/3.7.1-foss-2023a x x x x x x x x x x x GDAL/3.6.2-foss-2022b x x x x x x x x x x x"},{"location":"available_software/detail/GDB/","title":"GDB","text":"<p>The GNU Project Debugger</p> <p>https://www.gnu.org/software/gdb/gdb.html</p>"},{"location":"available_software/detail/GDB/#available-modules","title":"Available modules","text":"<p>The overview below shows which GDB installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GDB, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GDB/13.2-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GDB/13.2-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/GDRCopy/","title":"GDRCopy","text":"<p>A low-latency GPU memory copy library based on NVIDIA GPUDirect RDMA technology.</p> <p>https://github.com/NVIDIA/gdrcopy</p>"},{"location":"available_software/detail/GDRCopy/#available-modules","title":"Available modules","text":"<p>The overview below shows which GDRCopy installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GDRCopy, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GDRCopy/2.4-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GDRCopy/2.4-GCCcore-13.2.0 x x x x x x x x x x x GDRCopy/2.3.1-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/GEOS/","title":"GEOS","text":"<p>GEOS (Geometry Engine - Open Source) is a C++ port of the Java Topology Suite (JTS)</p> <p>https://trac.osgeo.org/geos</p>"},{"location":"available_software/detail/GEOS/#available-modules","title":"Available modules","text":"<p>The overview below shows which GEOS installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GEOS, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GEOS/3.12.1-GCC-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GEOS/3.12.1-GCC-13.2.0 x x x x x x x x x x x GEOS/3.12.0-GCC-12.3.0 x x x x x x x x x x x GEOS/3.11.1-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/GL2PS/","title":"GL2PS","text":"<p>GL2PS: an OpenGL to PostScript printing library</p> <p>https://www.geuz.org/gl2ps/</p>"},{"location":"available_software/detail/GL2PS/#available-modules","title":"Available modules","text":"<p>The overview below shows which GL2PS installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GL2PS, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GL2PS/1.4.2-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GL2PS/1.4.2-GCCcore-12.3.0 x x x x x x x x x x x GL2PS/1.4.2-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/GLPK/","title":"GLPK","text":"<p>The GLPK (GNU Linear Programming Kit) package is intended for solving large-scale linear programming (LP), mixed integer programming (MIP), and other related problems. It is a set of routines written in ANSI C and organized in the form of a callable library.</p> <p>https://www.gnu.org/software/glpk/</p>"},{"location":"available_software/detail/GLPK/#available-modules","title":"Available modules","text":"<p>The overview below shows which GLPK installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GLPK, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GLPK/5.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GLPK/5.0-GCCcore-13.2.0 x x x x x x x x x x x GLPK/5.0-GCCcore-12.3.0 x x x x x x x x x x x GLPK/5.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/GLib/","title":"GLib","text":"<p>GLib is one of the base libraries of the GTK+ project</p> <p>https://www.gtk.org/</p>"},{"location":"available_software/detail/GLib/#available-modules","title":"Available modules","text":"<p>The overview below shows which GLib installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GLib, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GLib/2.78.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GLib/2.78.1-GCCcore-13.2.0 x x x x x x x x x x x GLib/2.77.1-GCCcore-12.3.0 x x x x x x x x x x x GLib/2.75.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/GMP/","title":"GMP","text":"<p>GMP is a free library for arbitrary precision arithmetic, operating on signed integers, rational numbers, and floating point numbers.</p> <p>https://gmplib.org/</p>"},{"location":"available_software/detail/GMP/#available-modules","title":"Available modules","text":"<p>The overview below shows which GMP installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GMP, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GMP/6.3.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GMP/6.3.0-GCCcore-13.2.0 x x x x x x x x x x x GMP/6.2.1-GCCcore-12.3.0 x x x x x x x x x x x GMP/6.2.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/GObject-Introspection/","title":"GObject-Introspection","text":"<p>GObject introspection is a middleware layer between C libraries (using GObject) and language bindings. The C library can be scanned at compile time and generate a metadata file, in addition to the actual native C library. Then at runtime, language bindings can read this metadata and automatically provide bindings to call into the C library.</p> <p>https://gi.readthedocs.io/en/latest/</p>"},{"location":"available_software/detail/GObject-Introspection/#available-modules","title":"Available modules","text":"<p>The overview below shows which GObject-Introspection installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GObject-Introspection, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GObject-Introspection/1.78.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GObject-Introspection/1.78.1-GCCcore-13.2.0 x x x x x x x x x x x GObject-Introspection/1.76.1-GCCcore-12.3.0 x x x x x x x x x x x GObject-Introspection/1.74.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/GROMACS/","title":"GROMACS","text":"<p>GROMACS is a versatile package to perform molecular dynamics, i.e. simulate theNewtonian equations of motion for systems with hundreds to millions ofparticles.This is a CPU only build, containing both MPI and threadMPI binariesfor both single and double precision.It also contains the gmxapi extension for the single precision MPI build.</p> <p>https://www.gromacs.org</p>"},{"location":"available_software/detail/GROMACS/#available-modules","title":"Available modules","text":"<p>The overview below shows which GROMACS installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GROMACS, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GROMACS/2024.4-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GROMACS/2024.4-foss-2023b x x x x x x x x x x x GROMACS/2024.3-foss-2023b x x x x x x x x x x x GROMACS/2024.1-foss-2023b x x x x x x x x x x x"},{"location":"available_software/detail/GROMACS/#gromacs20244-foss-2023b","title":"GROMACS/2024.4-foss-2023b","text":"<p>This is a list of extensions included in the module:</p> <p>gmxapi-0.4.2</p>"},{"location":"available_software/detail/GROMACS/#gromacs20243-foss-2023b","title":"GROMACS/2024.3-foss-2023b","text":"<p>This is a list of extensions included in the module:</p> <p>gmxapi-0.4.2</p>"},{"location":"available_software/detail/GROMACS/#gromacs20241-foss-2023b","title":"GROMACS/2024.1-foss-2023b","text":"<p>This is a list of extensions included in the module:</p> <p>gmxapi-0.5.0</p>"},{"location":"available_software/detail/GSL/","title":"GSL","text":"<p>The GNU Scientific Library (GSL) is a numerical library for C and C++ programmers. The library provides a wide range of mathematical routines such as random number generators, special functions and least-squares fitting.</p> <p>https://www.gnu.org/software/gsl/</p>"},{"location":"available_software/detail/GSL/#available-modules","title":"Available modules","text":"<p>The overview below shows which GSL installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GSL, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GSL/2.7-GCC-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GSL/2.7-GCC-13.2.0 x x x x x x x x x x x GSL/2.7-GCC-12.3.0 x x x x x x x x x x x GSL/2.7-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/GST-plugins-bad/","title":"GST-plugins-bad","text":"<p>GStreamer is a library for constructing graphs of media-handling components. The applications it supports range from simple Ogg/Vorbis playback, audio/video streaming to complex audio (mixing) and video (non-linear editing) processing.</p> <p>https://gstreamer.freedesktop.org/</p>"},{"location":"available_software/detail/GST-plugins-bad/#available-modules","title":"Available modules","text":"<p>The overview below shows which GST-plugins-bad installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GST-plugins-bad, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GST-plugins-bad/1.22.5-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GST-plugins-bad/1.22.5-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/GST-plugins-base/","title":"GST-plugins-base","text":"<p>GStreamer is a library for constructing graphs of media-handling components. The applications it supports range from simple Ogg/Vorbis playback, audio/video streaming to complex audio (mixing) and video (non-linear editing) processing.</p> <p>https://gstreamer.freedesktop.org/</p>"},{"location":"available_software/detail/GST-plugins-base/#available-modules","title":"Available modules","text":"<p>The overview below shows which GST-plugins-base installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GST-plugins-base, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GST-plugins-base/1.24.8-GCC-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GST-plugins-base/1.24.8-GCC-13.2.0 x x x x x x x x x x x GST-plugins-base/1.22.5-GCC-12.3.0 x x x x x x x x x x x GST-plugins-base/1.22.1-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/GStreamer/","title":"GStreamer","text":"<p>GStreamer is a library for constructing graphs of media-handling components. The applications it supports range from simple Ogg/Vorbis playback, audio/video streaming to complex audio (mixing) and video (non-linear editing) processing.</p> <p>https://gstreamer.freedesktop.org/</p>"},{"location":"available_software/detail/GStreamer/#available-modules","title":"Available modules","text":"<p>The overview below shows which GStreamer installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GStreamer, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GStreamer/1.24.8-GCC-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GStreamer/1.24.8-GCC-13.2.0 x x x x x x x x x x x GStreamer/1.22.5-GCC-12.3.0 x x x x x x x x x x x GStreamer/1.22.1-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/GTK3/","title":"GTK3","text":"<p>GTK+ is the primary library used to construct user interfaces in GNOME. It provides all the user interface controls, or widgets, used in a common graphical application. Its object-oriented API allows you to construct user interfaces without dealing with the low-level details of drawing and device interaction.</p> <p>https://developer.gnome.org/gtk3/stable/</p>"},{"location":"available_software/detail/GTK3/#available-modules","title":"Available modules","text":"<p>The overview below shows which GTK3 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GTK3, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GTK3/3.24.39-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GTK3/3.24.39-GCCcore-13.2.0 x x x x x x x x x x x GTK3/3.24.37-GCCcore-12.3.0 x x x x x x x x x x x GTK3/3.24.35-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/GTK4/","title":"GTK4","text":"<p>GTK+ is the primary library used to construct user interfaces in GNOME. It provides all the user interface controls, or widgets, used in a common graphical application. Its object-oriented API allows you to construct user interfaces without dealing with the low-level details of drawing and device interaction.</p> <p>https://docs.gtk.org/gtk4/</p>"},{"location":"available_software/detail/GTK4/#available-modules","title":"Available modules","text":"<p>The overview below shows which GTK4 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GTK4, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GTK4/4.13.1-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GTK4/4.13.1-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Gblocks/","title":"Gblocks","text":"<p>Selection of conserved blocks from multiple alignments for their use in phylogenetic analysis</p> <p>https://www.biologiaevolutiva.org/jcastresana/Gblocks.html</p>"},{"location":"available_software/detail/Gblocks/#available-modules","title":"Available modules","text":"<p>The overview below shows which Gblocks installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Gblocks, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Gblocks/0.91b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Gblocks/0.91b x x x x x x x x x x x"},{"location":"available_software/detail/Gdk-Pixbuf/","title":"Gdk-Pixbuf","text":"<p>The Gdk Pixbuf is a toolkit for image loading and pixel buffer manipulation. It is used by GTK+ 2 and GTK+ 3 to load and manipulate images. In the past it was distributed as part of GTK+ 2 but it was split off into a separate package in preparation for the change to GTK+ 3.</p> <p>https://docs.gtk.org/gdk-pixbuf/</p>"},{"location":"available_software/detail/Gdk-Pixbuf/#available-modules","title":"Available modules","text":"<p>The overview below shows which Gdk-Pixbuf installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Gdk-Pixbuf, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Gdk-Pixbuf/2.42.10-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Gdk-Pixbuf/2.42.10-GCCcore-13.2.0 x x x x x x x x x x x Gdk-Pixbuf/2.42.10-GCCcore-12.3.0 x x x x x x x x x x x Gdk-Pixbuf/2.42.10-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/GenomeTools/","title":"GenomeTools","text":"<p>A comprehensive software library for efficient processing of structured genome annotations.</p> <p>http://genometools.org</p>"},{"location":"available_software/detail/GenomeTools/#available-modules","title":"Available modules","text":"<p>The overview below shows which GenomeTools installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GenomeTools, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GenomeTools/1.6.2-GCC-12.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GenomeTools/1.6.2-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Ghostscript/","title":"Ghostscript","text":"<p>Ghostscript is a versatile processor for PostScript data with the ability to render PostScript to different targets. It used to be part of the cups printing stack, but is no longer used for that.</p> <p>https://ghostscript.com</p>"},{"location":"available_software/detail/Ghostscript/#available-modules","title":"Available modules","text":"<p>The overview below shows which Ghostscript installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Ghostscript, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Ghostscript/10.02.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Ghostscript/10.02.1-GCCcore-13.2.0 x x x x x x x x x x x Ghostscript/10.01.2-GCCcore-12.3.0 x x x x x x x x x x x Ghostscript/10.0.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/GitPython/","title":"GitPython","text":"<p>GitPython is a python library used to interact with Git repositories</p> <p>https://gitpython.readthedocs.org</p>"},{"location":"available_software/detail/GitPython/#available-modules","title":"Available modules","text":"<p>The overview below shows which GitPython installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using GitPython, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load GitPython/3.1.40-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 GitPython/3.1.40-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/GitPython/#gitpython3140-gcccore-1230","title":"GitPython/3.1.40-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>gitdb-4.0.11, GitPython-3.1.40, smmap-5.0.1</p>"},{"location":"available_software/detail/Graphene/","title":"Graphene","text":"<p>Graphene is a thin layer of types for graphic libraries</p> <p>https://ebassi.github.io/graphene/</p>"},{"location":"available_software/detail/Graphene/#available-modules","title":"Available modules","text":"<p>The overview below shows which Graphene installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Graphene, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Graphene/1.10.8-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Graphene/1.10.8-GCCcore-13.2.0 x x x x x x x x x x x Graphene/1.10.8-GCCcore-12.3.0 x x x x x x x x x x x Graphene/1.10.8-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/HDBSCAN/","title":"HDBSCAN","text":"<p>The hdbscan library is a suite of tools to use unsupervised learning to find clusters, or dense regions, of a dataset. The primary algorithm is HDBSCAN* as proposed by Campello, Moulavi, and Sander. The library provides a high performance implementation of this algorithm, along with tools for analysing the resulting clustering.</p> <p>http://hdbscan.readthedocs.io/en/latest/</p>"},{"location":"available_software/detail/HDBSCAN/#available-modules","title":"Available modules","text":"<p>The overview below shows which HDBSCAN installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using HDBSCAN, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load HDBSCAN/0.8.38.post1-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 HDBSCAN/0.8.38.post1-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/HDF/","title":"HDF","text":"<p>HDF (also known as HDF4) is a library and multi-object file format for storing and managing data between machines.</p> <p>https://www.hdfgroup.org/products/hdf4/</p>"},{"location":"available_software/detail/HDF/#available-modules","title":"Available modules","text":"<p>The overview below shows which HDF installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using HDF, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load HDF/4.2.16-2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 HDF/4.2.16-2-GCCcore-13.2.0 x x x x x x x x x x x HDF/4.2.16-2-GCCcore-12.3.0 x x x x x x x x x x x HDF/4.2.15-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/HDF5/","title":"HDF5","text":"<p>HDF5 is a data model, library, and file format for storing and managing data. It supports an unlimited variety of datatypes, and is designed for flexible and efficient I/O and for high volume and complex data.</p> <p>https://portal.hdfgroup.org/display/support</p>"},{"location":"available_software/detail/HDF5/#available-modules","title":"Available modules","text":"<p>The overview below shows which HDF5 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using HDF5, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load HDF5/1.14.3-gompi-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 HDF5/1.14.3-gompi-2023b x x x x x x x x x x x HDF5/1.14.0-gompi-2023a x x x x x x x x x x x HDF5/1.14.0-gompi-2022b x x x x x x x x x x x"},{"location":"available_software/detail/HMMER/","title":"HMMER","text":"<p>HMMER is used for searching sequence databases for homologs of protein sequences, and for making protein sequence alignments. It implements methods using probabilistic models called profile hidden Markov models (profile HMMs).  Compared to BLAST, FASTA, and other sequence alignment and database search tools based on older scoring methodology, HMMER aims to be significantly more accurate and more able to detect remote homologs because of the strength of its underlying mathematical models. In the past, this strength came at significant computational expense, but in the new HMMER3 project, HMMER is now essentially as fast as BLAST.</p> <p>http://hmmer.org/</p>"},{"location":"available_software/detail/HMMER/#available-modules","title":"Available modules","text":"<p>The overview below shows which HMMER installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using HMMER, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load HMMER/3.4-gompi-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 HMMER/3.4-gompi-2023a x x x x x x x x x x x"},{"location":"available_software/detail/HPL/","title":"HPL","text":"<p>HPL is a software package that solves a (random) dense linear system in double precision (64 bits) arithmetic on distributed-memory computers. It can thus be regarded as a portable as well as freely available implementation of the High Performance Computing Linpack Benchmark.</p> <p>https://www.netlib.org/benchmark/hpl/</p>"},{"location":"available_software/detail/HPL/#available-modules","title":"Available modules","text":"<p>The overview below shows which HPL installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using HPL, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load HPL/2.3-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 HPL/2.3-foss-2023b x x x x x x x x x x x"},{"location":"available_software/detail/HTSlib/","title":"HTSlib","text":"<p>A C library for reading/writing high-throughput sequencing data. This package includes the utilities bgzip and tabix</p> <p>https://www.htslib.org/</p>"},{"location":"available_software/detail/HTSlib/#available-modules","title":"Available modules","text":"<p>The overview below shows which HTSlib installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using HTSlib, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load HTSlib/1.19.1-GCC-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 HTSlib/1.19.1-GCC-13.2.0 x x x x x x x x x x x HTSlib/1.18-GCC-12.3.0 x x x x x x x x x x x HTSlib/1.17-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/HarfBuzz/","title":"HarfBuzz","text":"<p>HarfBuzz is an OpenType text shaping engine.</p> <p>https://www.freedesktop.org/wiki/Software/HarfBuzz</p>"},{"location":"available_software/detail/HarfBuzz/#available-modules","title":"Available modules","text":"<p>The overview below shows which HarfBuzz installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using HarfBuzz, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load HarfBuzz/8.2.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 HarfBuzz/8.2.2-GCCcore-13.2.0 x x x x x x x x x x x HarfBuzz/5.3.1-GCCcore-12.3.0 x x x x x x x x x x x HarfBuzz/5.3.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/HepMC3/","title":"HepMC3","text":"<p>HepMC is a standard for storing Monte Carlo event data.</p> <p>http://hepmc.web.cern.ch/hepmc/</p>"},{"location":"available_software/detail/HepMC3/#available-modules","title":"Available modules","text":"<p>The overview below shows which HepMC3 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using HepMC3, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load HepMC3/3.2.6-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 HepMC3/3.2.6-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Highway/","title":"Highway","text":"<p>Highway is a C++ library for SIMD (Single Instruction, Multiple Data), i.e. applying the sameoperation to 'lanes'.</p> <p>https://github.com/google/highway</p>"},{"location":"available_software/detail/Highway/#available-modules","title":"Available modules","text":"<p>The overview below shows which Highway installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Highway, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Highway/1.0.4-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Highway/1.0.4-GCCcore-12.3.0 x x x x x x x x x x x Highway/1.0.3-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Hypre/","title":"Hypre","text":"<p>Hypre is a library for solving large, sparse linear systems of equations on massively parallel computers. The problems of interest arise in the simulation codes being developed at LLNL and elsewhere to study physical phenomena in the defense, environmental, energy, and biological sciences.</p> <p>https://computation.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods</p>"},{"location":"available_software/detail/Hypre/#available-modules","title":"Available modules","text":"<p>The overview below shows which Hypre installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Hypre, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Hypre/2.29.0-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Hypre/2.29.0-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/ICU/","title":"ICU","text":"<p>ICU is a mature, widely used set of C/C++ and Java libraries providing Unicode and Globalization support for software applications.</p> <p>https://icu.unicode.org</p>"},{"location":"available_software/detail/ICU/#available-modules","title":"Available modules","text":"<p>The overview below shows which ICU installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ICU, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ICU/74.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ICU/74.1-GCCcore-13.2.0 x x x x x x x x x x x ICU/73.2-GCCcore-12.3.0 x x x x x x x x x x x ICU/72.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/IDG/","title":"IDG","text":"<p>Image Domain Gridding (IDG) is a fast method for convolutional resampling (gridding/degridding)of radio astronomical data (visibilities). Direction dependent effects (DDEs) or A-tems can be appliedin the gridding process.The algorithm is described in \"Image Domain Gridding: a fast method for convolutional resampling of visibilities\",Van der Tol (2018).The implementation is described in \"Radio-astronomical imaging on graphics processors\", Veenboer (2020).Please cite these papers in publications using IDG.</p> <p>https://idg.readthedocs.io/</p>"},{"location":"available_software/detail/IDG/#available-modules","title":"Available modules","text":"<p>The overview below shows which IDG installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using IDG, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load IDG/1.2.0-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 IDG/1.2.0-foss-2023b x x x x x x x x x x x"},{"location":"available_software/detail/IPython/","title":"IPython","text":"<p>IPython provides a rich architecture for interactive computing with: Powerful interactive shells (terminal and Qt-based). A browser-based notebook with support for code, text, mathematical expressions, inline plots and other rich media. Support for interactive data visualization and use of GUI toolkits. Flexible, embeddable interpreters to load into your own projects. Easy to use, high performance tools for parallel computing.</p> <p>https://ipython.org/index.html</p>"},{"location":"available_software/detail/IPython/#available-modules","title":"Available modules","text":"<p>The overview below shows which IPython installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using IPython, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load IPython/8.17.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 IPython/8.17.2-GCCcore-13.2.0 x x x x x x x x x x x IPython/8.14.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/IPython/#ipython8172-gcccore-1320","title":"IPython/8.17.2-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>asttokens-2.4.1, backcall-0.2.0, executing-2.0.1, ipython-8.17.2, matplotlib-inline-0.1.6, pickleshare-0.7.5, prompt_toolkit-3.0.41, pure_eval-0.2.2, stack_data-0.6.3, traitlets-5.13.0</p>"},{"location":"available_software/detail/IPython/#ipython8140-gcccore-1230","title":"IPython/8.14.0-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>asttokens-2.2.1, backcall-0.2.0, executing-1.2.0, ipython-8.14.0, jedi-0.19.0, matplotlib-inline-0.1.6, parso-0.8.3, pickleshare-0.7.5, prompt_toolkit-3.0.39, pure_eval-0.2.2, stack_data-0.6.2, traitlets-5.9.0</p>"},{"location":"available_software/detail/IQ-TREE/","title":"IQ-TREE","text":"<p>Efficient phylogenomic software by maximum likelihood</p> <p>http://www.iqtree.org/</p>"},{"location":"available_software/detail/IQ-TREE/#available-modules","title":"Available modules","text":"<p>The overview below shows which IQ-TREE installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using IQ-TREE, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load IQ-TREE/2.3.5-gompi-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 IQ-TREE/2.3.5-gompi-2023a x x x x x x x x x x x"},{"location":"available_software/detail/ISA-L/","title":"ISA-L","text":"<p>Intelligent Storage Acceleration Library</p> <p>https://github.com/intel/isa-l</p>"},{"location":"available_software/detail/ISA-L/#available-modules","title":"Available modules","text":"<p>The overview below shows which ISA-L installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ISA-L, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ISA-L/2.30.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ISA-L/2.30.0-GCCcore-12.3.0 x x x x x x x x x x x ISA-L/2.30.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/ISL/","title":"ISL","text":"<p>isl is a library for manipulating sets and relations of integer points bounded by linear constraints.</p> <p>https://libisl.sourceforge.io</p>"},{"location":"available_software/detail/ISL/#available-modules","title":"Available modules","text":"<p>The overview below shows which ISL installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ISL, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ISL/0.26-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ISL/0.26-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/ITSTool/","title":"ITSTool","text":"<p>ITS Tool allows you to translate your XML documents with PO files</p> <p>http://itstool.org/</p>"},{"location":"available_software/detail/ITSTool/#available-modules","title":"Available modules","text":"<p>The overview below shows which ITSTool installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ITSTool, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ITSTool/2.0.7-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ITSTool/2.0.7-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/ImageMagick/","title":"ImageMagick","text":"<p>ImageMagick is a software suite to create, edit, compose, or convert bitmap images</p> <p>https://www.imagemagick.org/</p>"},{"location":"available_software/detail/ImageMagick/#available-modules","title":"Available modules","text":"<p>The overview below shows which ImageMagick installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ImageMagick, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ImageMagick/7.1.1-34-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ImageMagick/7.1.1-34-GCCcore-13.2.0 x x x x x x x x x x x ImageMagick/7.1.1-15-GCCcore-12.3.0 x x x x x x x x x x x ImageMagick/7.1.0-53-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Imath/","title":"Imath","text":"<p>Imath is a C++ and python library of 2D and 3D vector, matrix, and math operations for computer graphics</p> <p>https://imath.readthedocs.io/en/latest/</p>"},{"location":"available_software/detail/Imath/#available-modules","title":"Available modules","text":"<p>The overview below shows which Imath installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Imath, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Imath/3.1.9-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Imath/3.1.9-GCCcore-13.2.0 x x x x x x x x x x x Imath/3.1.7-GCCcore-12.3.0 x x x x x x x x x x x Imath/3.1.6-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/JasPer/","title":"JasPer","text":"<p>The JasPer Project is an open-source initiative to provide a free software-based reference implementation of the codec specified in the JPEG-2000 Part-1 standard.</p> <p>https://www.ece.uvic.ca/~frodo/jasper/</p>"},{"location":"available_software/detail/JasPer/#available-modules","title":"Available modules","text":"<p>The overview below shows which JasPer installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using JasPer, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load JasPer/4.0.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 JasPer/4.0.0-GCCcore-13.2.0 x x x x x x x x x x x JasPer/4.0.0-GCCcore-12.3.0 x x x x x x x x x x x JasPer/4.0.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Java/","title":"Java","text":""},{"location":"available_software/detail/Java/#available-modules","title":"Available modules","text":"<p>The overview below shows which Java installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Java, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Java/21.0.5\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Java/21.0.5 x x x x x x x x x x x Java/21(@Java/21.0.5) x x x x x x x x x x x Java/17.0.6 x x x x x x x x x x x Java/17(@Java/17.0.6) x x x x x x x x x x x Java/11.0.20 x x x x x x x x x x x Java/11(@Java/11.0.20) x x x x x x x x x x x"},{"location":"available_software/detail/JsonCpp/","title":"JsonCpp","text":"<p>JsonCpp is a C++ library that allows manipulating JSON values, including serialization and deserialization to and from strings. It can also preserve existing comment in unserialization/serialization steps, making it a convenient format to store user input files.</p> <p>https://open-source-parsers.github.io/jsoncpp-docs/doxygen/index.html</p>"},{"location":"available_software/detail/JsonCpp/#available-modules","title":"Available modules","text":"<p>The overview below shows which JsonCpp installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using JsonCpp, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load JsonCpp/1.9.5-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 JsonCpp/1.9.5-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Judy/","title":"Judy","text":"<p>A C library that implements a dynamic array.</p> <p>http://judy.sourceforge.net/</p>"},{"location":"available_software/detail/Judy/#available-modules","title":"Available modules","text":"<p>The overview below shows which Judy installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Judy, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Judy/1.0.5-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Judy/1.0.5-GCCcore-12.3.0 x x x x x x x x x x x Judy/1.0.5-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/JupyterLab/","title":"JupyterLab","text":"<p>JupyterLab is the next-generation user interface for Project Jupyter offering all the familiar building blocks of the classic Jupyter Notebook (notebook, terminal, text editor, file browser, rich outputs, etc.) in a flexible and powerful user interface. JupyterLab will eventually replace the classic Jupyter Notebook.</p> <p>https://jupyter.org/</p>"},{"location":"available_software/detail/JupyterLab/#available-modules","title":"Available modules","text":"<p>The overview below shows which JupyterLab installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using JupyterLab, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load JupyterLab/4.0.5-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 JupyterLab/4.0.5-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/JupyterLab/#jupyterlab405-gcccore-1230","title":"JupyterLab/4.0.5-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>async-lru-2.0.4, json5-0.9.14, jupyter-lsp-2.2.0, jupyterlab-4.0.5, jupyterlab_server-2.24.0</p>"},{"location":"available_software/detail/JupyterNotebook/","title":"JupyterNotebook","text":"<p>The Jupyter Notebook is the original web application for creating and sharing computational documents. It offers a simple, streamlined, document-centric experience.</p> <p>https://jupyter.org/</p>"},{"location":"available_software/detail/JupyterNotebook/#available-modules","title":"Available modules","text":"<p>The overview below shows which JupyterNotebook installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using JupyterNotebook, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load JupyterNotebook/7.0.2-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 JupyterNotebook/7.0.2-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/KaHIP/","title":"KaHIP","text":"<p>The graph partitioning framework KaHIP -- Karlsruhe High Quality Partitioning.</p> <p>https://kahip.github.io/</p>"},{"location":"available_software/detail/KaHIP/#available-modules","title":"Available modules","text":"<p>The overview below shows which KaHIP installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using KaHIP, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load KaHIP/3.16-gompi-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 KaHIP/3.16-gompi-2023a x x x x x x x x x x x KaHIP/3.14-gompi-2022b x x x x x x x x x x x"},{"location":"available_software/detail/KronaTools/","title":"KronaTools","text":"<p>Krona Tools is a set of scripts to create Krona charts from several Bioinformatics tools as well as from text and XML files.</p> <p>https://github.com/marbl/Krona/wiki/KronaTools</p>"},{"location":"available_software/detail/KronaTools/#available-modules","title":"Available modules","text":"<p>The overview below shows which KronaTools installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using KronaTools, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load KronaTools/2.8.1-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 KronaTools/2.8.1-GCCcore-12.3.0 x x x x x x x x x x x KronaTools/2.8.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/LAME/","title":"LAME","text":"<p>LAME is a high quality MPEG Audio Layer III (MP3) encoder licensed under the LGPL.</p> <p>http://lame.sourceforge.net/</p>"},{"location":"available_software/detail/LAME/#available-modules","title":"Available modules","text":"<p>The overview below shows which LAME installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using LAME, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load LAME/3.100-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 LAME/3.100-GCCcore-13.2.0 x x x x x x x x x x x LAME/3.100-GCCcore-12.3.0 x x x x x x x x x x x LAME/3.100-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/LAMMPS/","title":"LAMMPS","text":"<p>LAMMPS is a classical molecular dynamics code, and an acronymfor Large-scale Atomic/Molecular Massively Parallel Simulator. LAMMPS haspotentials for solid-state materials (metals, semiconductors) and soft matter(biomolecules, polymers) and coarse-grained or mesoscopic systems. It can beused to model atoms or, more generically, as a parallel particle simulator atthe atomic, meso, or continuum scale. LAMMPS runs on single processors or inparallel using message-passing techniques and a spatial-decomposition of thesimulation domain. The code is designed to be easy to modify or extend with newfunctionality.</p> <p>https://www.lammps.org</p>"},{"location":"available_software/detail/LAMMPS/#available-modules","title":"Available modules","text":"<p>The overview below shows which LAMMPS installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using LAMMPS, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load LAMMPS/29Aug2024-foss-2023b-kokkos\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 LAMMPS/29Aug2024-foss-2023b-kokkos x x x x x x x x x x x LAMMPS/2Aug2023_update2-foss-2023a-kokkos x x x x x x x x x x x"},{"location":"available_software/detail/LERC/","title":"LERC","text":"<p>LERC is an open-source image or raster format which supports rapid encoding and decodingfor any pixel type (not just RGB or Byte). Users set the maximum compression error per pixel while encoding,so the precision of the original input image is preserved (within user defined error bounds).</p> <p>https://github.com/Esri/lerc</p>"},{"location":"available_software/detail/LERC/#available-modules","title":"Available modules","text":"<p>The overview below shows which LERC installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using LERC, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load LERC/4.0.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 LERC/4.0.0-GCCcore-13.2.0 x x x x x x x x x x x LERC/4.0.0-GCCcore-12.3.0 x x x x x x x x x x x LERC/4.0.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/LHAPDF/","title":"LHAPDF","text":"<p>Les Houches Parton Density FunctionLHAPDF is the standard tool for evaluating parton distribution functions (PDFs) in high-energy physics.</p> <p>http://lhapdf.hepforge.org/</p>"},{"location":"available_software/detail/LHAPDF/#available-modules","title":"Available modules","text":"<p>The overview below shows which LHAPDF installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using LHAPDF, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load LHAPDF/6.5.4-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 LHAPDF/6.5.4-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/LLVM/","title":"LLVM","text":"<p>The LLVM Core libraries provide a modern source- and target-independent optimizer, along with code generation support for many popular CPUs (as well as some less common ones!) These libraries are built around a well specified code representation known as the LLVM intermediate representation (\"LLVM IR\"). The LLVM Core libraries are well documented, and it is particularly easy to invent your own language (or port an existing compiler) to use LLVM as an optimizer and code generator.</p> <p>https://llvm.org/</p>"},{"location":"available_software/detail/LLVM/#available-modules","title":"Available modules","text":"<p>The overview below shows which LLVM installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using LLVM, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load LLVM/16.0.6-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 LLVM/16.0.6-GCCcore-13.2.0 x x x x x x x x x x x LLVM/16.0.6-GCCcore-12.3.0 x x x x x x x x x x x LLVM/15.0.5-GCCcore-12.2.0 x x x x x x x x x x x LLVM/14.0.6-GCCcore-12.3.0-llvmlite x x x x x x x x x x x"},{"location":"available_software/detail/LMDB/","title":"LMDB","text":"<p>LMDB is a fast, memory-efficient database. With memory-mapped files, it has the read performance of a pure in-memory database while retaining the persistence of standard disk-based databases.</p> <p>https://symas.com/lmdb</p>"},{"location":"available_software/detail/LMDB/#available-modules","title":"Available modules","text":"<p>The overview below shows which LMDB installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using LMDB, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load LMDB/0.9.31-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 LMDB/0.9.31-GCCcore-12.3.0 x x x x x x x x x x x LMDB/0.9.29-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/LRBinner/","title":"LRBinner","text":"<p>LRBinner is a long-read binning tool published in WABI 2021 proceedings and AMB.</p> <p>https://github.com/anuradhawick/LRBinner</p>"},{"location":"available_software/detail/LRBinner/#available-modules","title":"Available modules","text":"<p>The overview below shows which LRBinner installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using LRBinner, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load LRBinner/0.1-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 LRBinner/0.1-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/LRBinner/#lrbinner01-foss-2023a","title":"LRBinner/0.1-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>LRBinner-0.1, tabulate-0.9.0</p>"},{"location":"available_software/detail/LSD2/","title":"LSD2","text":"<p>Least-squares methods to estimate rates and dates from phylogenies</p> <p>https://github.com/tothuhien/lsd2</p>"},{"location":"available_software/detail/LSD2/#available-modules","title":"Available modules","text":"<p>The overview below shows which LSD2 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using LSD2, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load LSD2/2.4.1-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 LSD2/2.4.1-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/LZO/","title":"LZO","text":"<p>Portable lossless data compression library</p> <p>https://www.oberhumer.com/opensource/lzo/</p>"},{"location":"available_software/detail/LZO/#available-modules","title":"Available modules","text":"<p>The overview below shows which LZO installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using LZO, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load LZO/2.10-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 LZO/2.10-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/LibTIFF/","title":"LibTIFF","text":"<p>tiff: Library and tools for reading and writing TIFF data files</p> <p>https://libtiff.gitlab.io/libtiff/</p>"},{"location":"available_software/detail/LibTIFF/#available-modules","title":"Available modules","text":"<p>The overview below shows which LibTIFF installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using LibTIFF, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load LibTIFF/4.6.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 LibTIFF/4.6.0-GCCcore-13.2.0 x x x x x x x x x x x LibTIFF/4.5.0-GCCcore-12.3.0 x x x x x x x x x x x LibTIFF/4.4.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Libint/","title":"Libint","text":"<p>Libint library is used to evaluate the traditional (electron repulsion) and certain novel two-body matrix elements (integrals) over Cartesian Gaussian functions used in modern atomic and molecular theory.</p> <p>https://github.com/evaleev/libint</p>"},{"location":"available_software/detail/Libint/#available-modules","title":"Available modules","text":"<p>The overview below shows which Libint installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Libint, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Libint/2.7.2-GCC-12.3.0-lmax-6-cp2k\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Libint/2.7.2-GCC-12.3.0-lmax-6-cp2k x x x x x x x x x x x"},{"location":"available_software/detail/LightGBM/","title":"LightGBM","text":"<p>A fast, distributed, high performance gradient boosting (GBT, GBDT, GBRT, GBMor MART) framework based on decision tree algorithms, used for ranking,classification and many other machine learning tasks.</p> <p>https://lightgbm.readthedocs.io</p>"},{"location":"available_software/detail/LightGBM/#available-modules","title":"Available modules","text":"<p>The overview below shows which LightGBM installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using LightGBM, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load LightGBM/4.5.0-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 LightGBM/4.5.0-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/LightGBM/#lightgbm450-foss-2023a","title":"LightGBM/4.5.0-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>lightgbm-4.5.0</p>"},{"location":"available_software/detail/LittleCMS/","title":"LittleCMS","text":"<p>Little CMS intends to be an OPEN SOURCE small-footprint color management engine, with special focus on accuracy and performance.</p> <p>https://www.littlecms.com/</p>"},{"location":"available_software/detail/LittleCMS/#available-modules","title":"Available modules","text":"<p>The overview below shows which LittleCMS installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using LittleCMS, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load LittleCMS/2.15-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 LittleCMS/2.15-GCCcore-13.2.0 x x x x x x x x x x x LittleCMS/2.15-GCCcore-12.3.0 x x x x x x x x x x x LittleCMS/2.14-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/LoopTools/","title":"LoopTools","text":"<p>LoopTools is a package for evaluation of scalar and tensor one-loop integrals.It is based on the FF package by G.J. van Oldenborgh.</p> <p>https://feynarts.de/looptools/</p>"},{"location":"available_software/detail/LoopTools/#available-modules","title":"Available modules","text":"<p>The overview below shows which LoopTools installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using LoopTools, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load LoopTools/2.15-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 LoopTools/2.15-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Lua/","title":"Lua","text":"<p>Lua is a powerful, fast, lightweight, embeddable scripting language. Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode for a register-based virtual machine, and has automatic memory management with incremental garbage collection, making it ideal for configuration, scripting, and rapid prototyping.</p> <p>https://www.lua.org/</p>"},{"location":"available_software/detail/Lua/#available-modules","title":"Available modules","text":"<p>The overview below shows which Lua installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Lua, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Lua/5.4.6-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Lua/5.4.6-GCCcore-13.2.0 x x x x x x x x x x x Lua/5.4.6-GCCcore-12.3.0 x x x x x x x x x x x Lua/5.4.4-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/MAFFT/","title":"MAFFT","text":"<p>MAFFT is a multiple sequence alignment program for unix-like operating systems.It offers a range of multiple alignment methods, L-INS-i (accurate; for alignmentof &lt;\u223c200 sequences), FFT-NS-2 (fast; for alignment of &lt;\u223c30,000 sequences), etc.</p> <p>https://mafft.cbrc.jp/alignment/software/source.html</p>"},{"location":"available_software/detail/MAFFT/#available-modules","title":"Available modules","text":"<p>The overview below shows which MAFFT installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using MAFFT, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load MAFFT/7.520-GCC-12.3.0-with-extensions\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 MAFFT/7.520-GCC-12.3.0-with-extensions x x x x x x x x x x x MAFFT/7.505-GCC-12.2.0-with-extensions x x x x x x x x x x x"},{"location":"available_software/detail/MBX/","title":"MBX","text":"<p>MBX is an energy and force calculator for data-driven many-body simulations</p> <p>https://github.com/paesanilab/MBX</p>"},{"location":"available_software/detail/MBX/#available-modules","title":"Available modules","text":"<p>The overview below shows which MBX installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using MBX, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load MBX/1.1.0-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 MBX/1.1.0-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/MCL/","title":"MCL","text":"<p>The MCL algorithm is short for the Markov Cluster Algorithm, a fastand scalable unsupervised cluster algorithm for graphs (also known as networks) basedon simulation of (stochastic) flow in graphs.</p> <p>https://micans.org/mcl/</p>"},{"location":"available_software/detail/MCL/#available-modules","title":"Available modules","text":"<p>The overview below shows which MCL installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using MCL, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load MCL/22.282-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 MCL/22.282-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/MDAnalysis/","title":"MDAnalysis","text":"<p>MDAnalysis is an object-oriented Python library to analyze trajectories from molecular dynamics (MD)simulations in many popular formats.</p> <p>https://www.mdanalysis.org/</p>"},{"location":"available_software/detail/MDAnalysis/#available-modules","title":"Available modules","text":"<p>The overview below shows which MDAnalysis installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using MDAnalysis, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load MDAnalysis/2.4.2-foss-2022b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 MDAnalysis/2.4.2-foss-2022b x x x x x x x x x x x"},{"location":"available_software/detail/MDAnalysis/#mdanalysis242-foss-2022b","title":"MDAnalysis/2.4.2-foss-2022b","text":"<p>This is a list of extensions included in the module:</p> <p>fasteners-0.18, funcsigs-1.0.2, GridDataFormats-1.0.1, gsd-2.8.0, MDAnalysis-2.4.2, mmtf-python-1.1.3, mrcfile-1.4.3, msgpack-1.0.5</p>"},{"location":"available_software/detail/MDI/","title":"MDI","text":"<p>The MolSSI Driver Interface (MDI) project provides a standardized API for fast, on-the-fly communication between computational chemistry codes. This greatly simplifies the process of implementing methods that require the cooperation of multiple software packages and enables developers to write a single implementation that works across many different codes. The API is sufficiently general to support a wide variety of techniques, including QM/MM, ab initio MD, machine learning, advanced sampling, and path integral MD, while also being straightforwardly extensible. Communication between codes is handled by the MDI Library, which enables tight coupling between codes using either the MPI or TCP/IP methods.</p> <p>https://github.com/MolSSI-MDI/MDI_Library</p>"},{"location":"available_software/detail/MDI/#available-modules","title":"Available modules","text":"<p>The overview below shows which MDI installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using MDI, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load MDI/1.4.29-gompi-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 MDI/1.4.29-gompi-2023b x x x x x x x x x x x MDI/1.4.26-gompi-2023a x x x x x x x x x x x"},{"location":"available_software/detail/METIS/","title":"METIS","text":"<p>METIS is a set of serial programs for partitioning graphs, partitioning finite element meshes, and producing fill reducing orderings for sparse matrices. The algorithms implemented in METIS are based on the multilevel recursive-bisection, multilevel k-way, and multi-constraint partitioning schemes.</p> <p>http://glaros.dtc.umn.edu/gkhome/metis/metis/overview</p>"},{"location":"available_software/detail/METIS/#available-modules","title":"Available modules","text":"<p>The overview below shows which METIS installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using METIS, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load METIS/5.1.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 METIS/5.1.0-GCCcore-12.3.0 x x x x x x x x x x x METIS/5.1.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/MMseqs2/","title":"MMseqs2","text":"<p>MMseqs2: ultra fast and sensitive search and clustering suite</p> <p>https://mmseqs.com</p>"},{"location":"available_software/detail/MMseqs2/#available-modules","title":"Available modules","text":"<p>The overview below shows which MMseqs2 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using MMseqs2, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load MMseqs2/14-7e284-gompi-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 MMseqs2/14-7e284-gompi-2023a x x x x x x x x x x x"},{"location":"available_software/detail/MODFLOW/","title":"MODFLOW","text":"<p>MODFLOW is the USGS's modular hydrologic model. MODFLOW is considered an international standard for simulating and predicting groundwater conditions and groundwater/surface-water interactions.</p> <p>https://www.usgs.gov/mission-areas/water-resources/science/modflow-and-related-programs</p>"},{"location":"available_software/detail/MODFLOW/#available-modules","title":"Available modules","text":"<p>The overview below shows which MODFLOW installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using MODFLOW, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load MODFLOW/6.4.4-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 MODFLOW/6.4.4-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/MPC/","title":"MPC","text":"<p>Gnu Mpc is a C library for the arithmetic of complex numbers with arbitrarily high precision and correct rounding of the result. It extends the principles of the IEEE-754 standard for fixed precision real floating point numbers to complex numbers, providing well-defined semantics for every operation. At the same time, speed of operation at high precision is a major design goal.</p> <p>http://www.multiprecision.org/</p>"},{"location":"available_software/detail/MPC/#available-modules","title":"Available modules","text":"<p>The overview below shows which MPC installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using MPC, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load MPC/1.3.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 MPC/1.3.1-GCCcore-13.2.0 x x x x x x x x x x x MPC/1.3.1-GCCcore-12.3.0 x x x x x x x x x x x MPC/1.3.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/MPFR/","title":"MPFR","text":"<p>The MPFR library is a C library for multiple-precision floating-point computations with correct rounding.</p> <p>https://www.mpfr.org</p>"},{"location":"available_software/detail/MPFR/#available-modules","title":"Available modules","text":"<p>The overview below shows which MPFR installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using MPFR, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load MPFR/4.2.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 MPFR/4.2.1-GCCcore-13.2.0 x x x x x x x x x x x MPFR/4.2.0-GCCcore-12.3.0 x x x x x x x x x x x MPFR/4.2.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/MUMPS/","title":"MUMPS","text":"<p>A parallel sparse direct solver</p> <p>https://graal.ens-lyon.fr/MUMPS/</p>"},{"location":"available_software/detail/MUMPS/#available-modules","title":"Available modules","text":"<p>The overview below shows which MUMPS installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using MUMPS, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load MUMPS/5.6.1-foss-2023a-metis\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 MUMPS/5.6.1-foss-2023a-metis x x x x x x x x x x x MUMPS/5.6.1-foss-2022b-metis x x x x x x x x x x x"},{"location":"available_software/detail/MUSCLE/","title":"MUSCLE","text":"<p>MUSCLE is one of the best-performing multiple alignment programs according to published benchmark tests, with accuracy and speed that are consistently better than CLUSTALW. MUSCLE can align hundreds of sequences in seconds. Most users learn everything they need to know about MUSCLE in a few minutes-only a handful of command-line options are needed to perform common alignment tasks.</p> <p>https://drive5.com/muscle/</p>"},{"location":"available_software/detail/MUSCLE/#available-modules","title":"Available modules","text":"<p>The overview below shows which MUSCLE installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using MUSCLE, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load MUSCLE/5.1.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 MUSCLE/5.1.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Mako/","title":"Mako","text":"<p>A super-fast templating language that borrows the best ideas from the existing templating languages</p> <p>https://www.makotemplates.org</p>"},{"location":"available_software/detail/Mako/#available-modules","title":"Available modules","text":"<p>The overview below shows which Mako installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Mako, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Mako/1.2.4-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Mako/1.2.4-GCCcore-13.2.0 x x x x x x x x x x x Mako/1.2.4-GCCcore-12.3.0 x x x x x x x x x x x Mako/1.2.4-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Mako/#mako124-gcccore-1320","title":"Mako/1.2.4-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>Mako-1.2.4, MarkupSafe-2.1.3</p>"},{"location":"available_software/detail/Mako/#mako124-gcccore-1230","title":"Mako/1.2.4-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>Mako-1.2.4, MarkupSafe-2.1.3</p>"},{"location":"available_software/detail/MariaDB/","title":"MariaDB","text":"<p>MariaDB is an enhanced, drop-in replacement for MySQL.Included engines: myISAM, Aria, InnoDB, RocksDB, TokuDB, OQGraph, Mroonga.</p> <p>https://mariadb.org/</p>"},{"location":"available_software/detail/MariaDB/#available-modules","title":"Available modules","text":"<p>The overview below shows which MariaDB installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using MariaDB, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load MariaDB/11.6.0-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 MariaDB/11.6.0-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Mash/","title":"Mash","text":"<p>Fast genome and metagenome distance estimation using MinHash</p> <p>http://mash.readthedocs.org</p>"},{"location":"available_software/detail/Mash/#available-modules","title":"Available modules","text":"<p>The overview below shows which Mash installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Mash, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Mash/2.3-GCC-12.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Mash/2.3-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Mesa/","title":"Mesa","text":"<p>Mesa is an open-source implementation of the OpenGL specification - a system for rendering interactive 3D graphics.</p> <p>https://www.mesa3d.org/</p>"},{"location":"available_software/detail/Mesa/#available-modules","title":"Available modules","text":"<p>The overview below shows which Mesa installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Mesa, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Mesa/23.1.9-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Mesa/23.1.9-GCCcore-13.2.0 x x x x x x x x x x x Mesa/23.1.4-GCCcore-12.3.0 x x x x x x x x x x x Mesa/22.2.4-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Meson/","title":"Meson","text":"<p>Meson is a cross-platform build system designed to be both as fast and as user friendly as possible.</p> <p>https://mesonbuild.com</p>"},{"location":"available_software/detail/Meson/#available-modules","title":"Available modules","text":"<p>The overview below shows which Meson installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Meson, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Meson/1.3.1-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Meson/1.3.1-GCCcore-12.3.0 x x x x x x x x x x x Meson/1.2.3-GCCcore-13.2.0 x x x x x x x x x x x Meson/1.1.1-GCCcore-12.3.0 x x x x x x x x x x x Meson/0.64.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/MetaEuk/","title":"MetaEuk","text":"<p>MetaEuk is a modular toolkit designed for large-scale gene discovery and annotation in eukaryotic metagenomic contigs.</p> <p>https://metaeuk.soedinglab.org</p>"},{"location":"available_software/detail/MetaEuk/#available-modules","title":"Available modules","text":"<p>The overview below shows which MetaEuk installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using MetaEuk, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load MetaEuk/6-GCC-12.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 MetaEuk/6-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/MetalWalls/","title":"MetalWalls","text":"<p>MetalWalls (MW) is a molecular dynamics code dedicated to the modelling of electrochemical systems.Its main originality is the inclusion of a series of methods allowing to apply a constant potential within theelectrode materials.</p> <p>https://gitlab.com/ampere2/metalwalls</p>"},{"location":"available_software/detail/MetalWalls/#available-modules","title":"Available modules","text":"<p>The overview below shows which MetalWalls installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using MetalWalls, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load MetalWalls/21.06.1-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 MetalWalls/21.06.1-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/MultiQC/","title":"MultiQC","text":"<p>Aggregate results from bioinformatics analyses across many samples into a single report. MultiQC searches a given directory for analysis logs and compiles an HTML report. It's a general use tool, perfect for summarising the output from numerous bioinformatics tools.</p> <p>https://multiqc.info</p>"},{"location":"available_software/detail/MultiQC/#available-modules","title":"Available modules","text":"<p>The overview below shows which MultiQC installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using MultiQC, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load MultiQC/1.14-foss-2022b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 MultiQC/1.14-foss-2022b x x x x x x x x x x x"},{"location":"available_software/detail/MultiQC/#multiqc114-foss-2022b","title":"MultiQC/1.14-foss-2022b","text":"<p>This is a list of extensions included in the module:</p> <p>coloredlogs-15.0.1, colormath-3.0.0, commonmark-0.9.1, humanfriendly-10.0, lzstring-1.0.4, Markdown-3.4.1, markdown-it-py-2.1.0, mdurl-0.1.2, multiqc-1.14, Pygments-2.14.0, rich-13.3.1, rich-click-1.6.1, spectra-0.0.11</p>"},{"location":"available_software/detail/Mustache/","title":"Mustache","text":"<p>Mustache (Multi-scale Detection of Chromatin Loops from Hi-C and Micro-C Maps usingScale-Space Representation) is a tool for multi-scale detection of chromatin loops from Hi-C and Micro-Ccontact maps in high resolutions (10kbp all the way to 500bp and even more).Mustache uses recent technical advances in scale-space theory inComputer Vision to detect chromatin loops caused by interaction of DNA segments with a variable size.</p> <p>https://github.com/ay-lab/mustache</p>"},{"location":"available_software/detail/Mustache/#available-modules","title":"Available modules","text":"<p>The overview below shows which Mustache installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Mustache, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Mustache/1.3.3-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Mustache/1.3.3-foss-2023b x x x x x x x x x x x"},{"location":"available_software/detail/NASM/","title":"NASM","text":"<p>NASM: General-purpose x86 assembler</p> <p>https://www.nasm.us/</p>"},{"location":"available_software/detail/NASM/#available-modules","title":"Available modules","text":"<p>The overview below shows which NASM installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using NASM, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load NASM/2.16.01-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 NASM/2.16.01-GCCcore-13.2.0 x x x x x x x x x x x NASM/2.16.01-GCCcore-12.3.0 x x x x x x x x x x x NASM/2.15.05-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/NLTK/","title":"NLTK","text":"<p>NLTK is a leading platform for building Python programs to work with human language data.</p> <p>https://www.nltk.org/</p>"},{"location":"available_software/detail/NLTK/#available-modules","title":"Available modules","text":"<p>The overview below shows which NLTK installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using NLTK, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load NLTK/3.8.1-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 NLTK/3.8.1-foss-2023b x x x x x x x x x x x"},{"location":"available_software/detail/NLTK/#nltk381-foss-2023b","title":"NLTK/3.8.1-foss-2023b","text":"<p>This is a list of extensions included in the module:</p> <p>NLTK-3.8.1, python-crfsuite-0.9.10, regex-2023.12.25</p>"},{"location":"available_software/detail/NLopt/","title":"NLopt","text":"<p>NLopt is a free/open-source library for nonlinear optimization, providing a common interface for a number of different free optimization routines available online as well as original implementations of various other algorithms.</p> <p>http://ab-initio.mit.edu/wiki/index.php/NLopt</p>"},{"location":"available_software/detail/NLopt/#available-modules","title":"Available modules","text":"<p>The overview below shows which NLopt installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using NLopt, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load NLopt/2.7.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 NLopt/2.7.1-GCCcore-13.2.0 x x x x x x x x x x x NLopt/2.7.1-GCCcore-12.3.0 x x x x x x x x x x x NLopt/2.7.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/NSPR/","title":"NSPR","text":"<p>Netscape Portable Runtime (NSPR) provides a platform-neutral API for system level and libc-like functions.</p> <p>https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSPR</p>"},{"location":"available_software/detail/NSPR/#available-modules","title":"Available modules","text":"<p>The overview below shows which NSPR installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using NSPR, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load NSPR/4.35-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 NSPR/4.35-GCCcore-13.2.0 x x x x x x x x x x x NSPR/4.35-GCCcore-12.3.0 x x x x x x x x x x x NSPR/4.35-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/NSS/","title":"NSS","text":"<p>Network Security Services (NSS) is a set of libraries designed to support cross-platform development of security-enabled client and server applications.</p> <p>https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS</p>"},{"location":"available_software/detail/NSS/#available-modules","title":"Available modules","text":"<p>The overview below shows which NSS installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using NSS, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load NSS/3.94-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 NSS/3.94-GCCcore-13.2.0 x x x x x x x x x x x NSS/3.89.1-GCCcore-12.3.0 x x x x x x x x x x x NSS/3.85-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Nextflow/","title":"Nextflow","text":"<p>Nextflow is a reactive workflow framework and a programming DSL that eases writing computational pipelines with complex data</p> <p>https://www.nextflow.io/</p>"},{"location":"available_software/detail/Nextflow/#available-modules","title":"Available modules","text":"<p>The overview below shows which Nextflow installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Nextflow, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Nextflow/24.10.2\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Nextflow/24.10.2 x x x x x x x x x x x Nextflow/23.10.0 x x x x x x x x x x x"},{"location":"available_software/detail/Ninja/","title":"Ninja","text":"<p>Ninja is a small build system with a focus on speed.</p> <p>https://ninja-build.org/</p>"},{"location":"available_software/detail/Ninja/#available-modules","title":"Available modules","text":"<p>The overview below shows which Ninja installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Ninja, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Ninja/1.11.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Ninja/1.11.1-GCCcore-13.2.0 x x x x x x x x x x x Ninja/1.11.1-GCCcore-12.3.0 x x x x x x x x x x x Ninja/1.11.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/OPARI2/","title":"OPARI2","text":"<p>OPARI2, the successor of Forschungszentrum Juelich's OPARI, is a source-to-source instrumentation tool for OpenMP and hybrid codes. It surrounds OpenMP directives and runtime library calls with calls to the POMP2 measurement interface.</p> <p>https://www.score-p.org</p>"},{"location":"available_software/detail/OPARI2/#available-modules","title":"Available modules","text":"<p>The overview below shows which OPARI2 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using OPARI2, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load OPARI2/2.0.8-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 OPARI2/2.0.8-GCCcore-13.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/OSU-Micro-Benchmarks/","title":"OSU-Micro-Benchmarks","text":"<p>OSU Micro-Benchmarks</p> <p>https://mvapich.cse.ohio-state.edu/benchmarks/</p>"},{"location":"available_software/detail/OSU-Micro-Benchmarks/#available-modules","title":"Available modules","text":"<p>The overview below shows which OSU-Micro-Benchmarks installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using OSU-Micro-Benchmarks, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load OSU-Micro-Benchmarks/7.2-gompi-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 OSU-Micro-Benchmarks/7.2-gompi-2023b x x x x x x x x x x x OSU-Micro-Benchmarks/7.1-1-gompi-2023a x x x x x x x x x x x"},{"location":"available_software/detail/OTF2/","title":"OTF2","text":"<p>The Open Trace Format 2 is a highly scalable, memory efficient event trace data format plus support library. It is the new standard trace format for Scalasca, Vampir, and TAU and is open for other tools.</p> <p>https://www.score-p.org</p>"},{"location":"available_software/detail/OTF2/#available-modules","title":"Available modules","text":"<p>The overview below shows which OTF2 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using OTF2, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load OTF2/3.0.3-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 OTF2/3.0.3-GCCcore-13.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/OpenBLAS/","title":"OpenBLAS","text":"<p>OpenBLAS is an optimized BLAS library based on GotoBLAS2 1.13 BSD version.</p> <p>http://www.openblas.net/</p>"},{"location":"available_software/detail/OpenBLAS/#available-modules","title":"Available modules","text":"<p>The overview below shows which OpenBLAS installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using OpenBLAS, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load OpenBLAS/0.3.24-GCC-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 OpenBLAS/0.3.24-GCC-13.2.0 x x x x x x x x x x x OpenBLAS/0.3.23-GCC-12.3.0 x x x x x x x x x x x OpenBLAS/0.3.21-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/OpenCV/","title":"OpenCV","text":"<p>OpenCV (Open Source Computer Vision Library) is an open source computer vision and machine learning software library. OpenCV was built to provide a common infrastructure for computer vision applications and to accelerate the use of machine perception in the commercial products. Includes extra modules for OpenCV from the contrib repository.</p> <p>https://opencv.org/</p>"},{"location":"available_software/detail/OpenCV/#available-modules","title":"Available modules","text":"<p>The overview below shows which OpenCV installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using OpenCV, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load OpenCV/4.8.1-foss-2023a-contrib\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 OpenCV/4.8.1-foss-2023a-contrib x x x x x x x x x x x"},{"location":"available_software/detail/OpenEXR/","title":"OpenEXR","text":"<p>OpenEXR is a high dynamic-range (HDR) image file format developed by Industrial Light &amp; Magic for use in computer imaging applications</p> <p>https://www.openexr.com/</p>"},{"location":"available_software/detail/OpenEXR/#available-modules","title":"Available modules","text":"<p>The overview below shows which OpenEXR installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using OpenEXR, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load OpenEXR/3.2.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 OpenEXR/3.2.0-GCCcore-13.2.0 x x x x x x x x x x x OpenEXR/3.1.7-GCCcore-12.3.0 x x x x x x x x x x x OpenEXR/3.1.5-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/OpenFOAM/","title":"OpenFOAM","text":"<p>OpenFOAM is a free, open source CFD software package. OpenFOAM has an extensive range of features to solve anything from complex fluid flows involving chemical reactions, turbulence and heat transfer, to solid dynamics and electromagnetics.</p> <p>https://www.openfoam.org/</p>"},{"location":"available_software/detail/OpenFOAM/#available-modules","title":"Available modules","text":"<p>The overview below shows which OpenFOAM installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using OpenFOAM, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load OpenFOAM/v2406-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 OpenFOAM/v2406-foss-2023a x x x x x x x x x x x OpenFOAM/v2312-foss-2023a x x x x x x x x x x x OpenFOAM/11-foss-2023a x x x x x x x x x x x OpenFOAM/10-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/OpenJPEG/","title":"OpenJPEG","text":"<p>OpenJPEG is an open-source JPEG 2000 codec written in C language. It has been developed in order to promote the use of JPEG 2000, a still-image compression standard from the Joint Photographic Experts Group (JPEG). Since may 2015, it is officially recognized by ISO/IEC and ITU-T as a JPEG 2000 Reference Software.</p> <p>https://www.openjpeg.org/</p>"},{"location":"available_software/detail/OpenJPEG/#available-modules","title":"Available modules","text":"<p>The overview below shows which OpenJPEG installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using OpenJPEG, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load OpenJPEG/2.5.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 OpenJPEG/2.5.0-GCCcore-13.2.0 x x x x x x x x x x x OpenJPEG/2.5.0-GCCcore-12.3.0 x x x x x x x x x x x OpenJPEG/2.5.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/OpenMPI/","title":"OpenMPI","text":"<p>The Open MPI Project is an open source MPI-3 implementation.</p> <p>https://www.open-mpi.org/</p>"},{"location":"available_software/detail/OpenMPI/#available-modules","title":"Available modules","text":"<p>The overview below shows which OpenMPI installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using OpenMPI, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load OpenMPI/4.1.6-GCC-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 OpenMPI/4.1.6-GCC-13.2.0 x x x x x x x x x x x OpenMPI/4.1.5-GCC-12.3.0 x x x x x x x x x x x OpenMPI/4.1.4-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/OpenPGM/","title":"OpenPGM","text":"<p>OpenPGM is an open source implementation of the Pragmatic General Multicast (PGM) specification in RFC 3208 available at www.ietf.org. PGM is a reliable and scalable multicast protocol that enables receivers to detect loss, request retransmission of lost data, or notify an application of unrecoverable loss. PGM is a receiver-reliable protocol, which means the receiver is responsible for ensuring all data is received, absolving the sender of reception responsibility.</p> <p>https://code.google.com/p/openpgm/</p>"},{"location":"available_software/detail/OpenPGM/#available-modules","title":"Available modules","text":"<p>The overview below shows which OpenPGM installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using OpenPGM, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load OpenPGM/5.2.122-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 OpenPGM/5.2.122-GCCcore-13.2.0 x x x x x x x x x x x OpenPGM/5.2.122-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/OpenSSL/","title":"OpenSSL","text":"<p>The OpenSSL Project is a collaborative effort to develop a robust, commercial-grade, full-featured, and Open Source toolchain implementing the Secure Sockets Layer (SSL v2/v3) and Transport Layer Security (TLS v1) protocols as well as a full-strength general purpose cryptography library.</p> <p>https://www.openssl.org/</p>"},{"location":"available_software/detail/OpenSSL/#available-modules","title":"Available modules","text":"<p>The overview below shows which OpenSSL installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using OpenSSL, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load OpenSSL/1.1\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 OpenSSL/1.1 x x x x x x x x x x x"},{"location":"available_software/detail/OrthoFinder/","title":"OrthoFinder","text":"<p>OrthoFinder is a fast, accurate and comprehensive platform for comparative genomics</p> <p>https://github.com/davidemms/OrthoFinder</p>"},{"location":"available_software/detail/OrthoFinder/#available-modules","title":"Available modules","text":"<p>The overview below shows which OrthoFinder installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using OrthoFinder, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load OrthoFinder/2.5.5-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 OrthoFinder/2.5.5-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/Osi/","title":"Osi","text":"<p>Osi (Open Solver Interface) provides an abstract base class to a generic linearprogramming (LP) solver, along with derived classes for specific solvers. Manyapplications may be able to use the Osi to insulate themselves from a specificLP solver. That is, programs written to the OSI standard may be linked to anysolver with an OSI interface and should produce correct results. The OSI hasbeen significantly extended compared to its first incarnation. Currently, theOSI supports linear programming solvers and has rudimentary support for integerprogramming.</p> <p>https://github.com/coin-or/Osi</p>"},{"location":"available_software/detail/Osi/#available-modules","title":"Available modules","text":"<p>The overview below shows which Osi installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Osi, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Osi/0.108.9-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Osi/0.108.9-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/PAPI/","title":"PAPI","text":"<p>PAPI provides the tool designer and application engineer with a consistent interface and methodology for use of the performance counter hardware found in most major microprocessors. PAPI enables software engineers to see, in near real time, the relation between software performance and processor events. In addition Component PAPI provides access to a collection of components that expose performance measurement opportunites across the hardware and software stack.</p> <p>https://icl.cs.utk.edu/projects/papi/</p>"},{"location":"available_software/detail/PAPI/#available-modules","title":"Available modules","text":"<p>The overview below shows which PAPI installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PAPI, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PAPI/7.1.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PAPI/7.1.0-GCCcore-13.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/PCRE/","title":"PCRE","text":"<p>The PCRE library is a set of functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5.</p> <p>https://www.pcre.org/</p>"},{"location":"available_software/detail/PCRE/#available-modules","title":"Available modules","text":"<p>The overview below shows which PCRE installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PCRE, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PCRE/8.45-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PCRE/8.45-GCCcore-13.2.0 x x x x x x x x x x x PCRE/8.45-GCCcore-12.3.0 x x x x x x x x x x x PCRE/8.45-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/PCRE2/","title":"PCRE2","text":"<p>The PCRE library is a set of functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5.</p> <p>https://www.pcre.org/</p>"},{"location":"available_software/detail/PCRE2/#available-modules","title":"Available modules","text":"<p>The overview below shows which PCRE2 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PCRE2, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PCRE2/10.42-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PCRE2/10.42-GCCcore-13.2.0 x x x x x x x x x x x PCRE2/10.42-GCCcore-12.3.0 x x x x x x x x x x x PCRE2/10.40-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/PDT/","title":"PDT","text":"<p>Program Database Toolkit (PDT) is a framework for analyzing source code written in several programming languages and for making rich program knowledge accessible to developers of static and dynamic analysis tools. PDT implements a standard program representation, the program database (PDB), that can be accessed in a uniform way through a class library supporting common PDB operations.</p> <p>https://www.cs.uoregon.edu/research/pdt/</p>"},{"location":"available_software/detail/PDT/#available-modules","title":"Available modules","text":"<p>The overview below shows which PDT installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PDT, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PDT/3.25.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PDT/3.25.2-GCCcore-13.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/PETSc/","title":"PETSc","text":"<p>PETSc, pronounced PET-see (the S is silent), is a suite of data structures and routines for the scalable (parallel) solution of scientific applications modeled by partial differential equations.</p> <p>https://www.mcs.anl.gov/petsc</p>"},{"location":"available_software/detail/PETSc/#available-modules","title":"Available modules","text":"<p>The overview below shows which PETSc installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PETSc, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PETSc/3.20.3-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PETSc/3.20.3-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/PGPLOT/","title":"PGPLOT","text":"<p>The PGPLOT Graphics Subroutine Library is a Fortran- or C-callable,device-independent graphics package for making simple scientific graphs. It is intendedfor making graphical images of publication quality with minimum effort on the part ofthe user. For most applications, the program can be device-independent, and the outputcan be directed to the appropriate device at run time.</p> <p>https://sites.astro.caltech.edu/~tjp/pgplot/</p>"},{"location":"available_software/detail/PGPLOT/#available-modules","title":"Available modules","text":"<p>The overview below shows which PGPLOT installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PGPLOT, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PGPLOT/5.2.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PGPLOT/5.2.2-GCCcore-13.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/PLUMED/","title":"PLUMED","text":"<p>PLUMED is an open source library for free energy calculations in molecular systems which works together with some of the most popular molecular dynamics engines. Free energy calculations can be performed as a function of many order parameters with a particular  focus on biological problems, using state of the art methods such as metadynamics, umbrella sampling and Jarzynski-equation based steered MD. The software, written in C++, can be easily interfaced with both fortran and C/C++ codes.</p> <p>https://www.plumed.org</p>"},{"location":"available_software/detail/PLUMED/#available-modules","title":"Available modules","text":"<p>The overview below shows which PLUMED installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PLUMED, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PLUMED/2.9.2-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PLUMED/2.9.2-foss-2023b x x x x x x x x x x x PLUMED/2.9.0-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/PLY/","title":"PLY","text":"<p>PLY is yet another implementation of lex and yacc for Python.</p> <p>https://www.dabeaz.com/ply/</p>"},{"location":"available_software/detail/PLY/#available-modules","title":"Available modules","text":"<p>The overview below shows which PLY installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PLY, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PLY/3.11-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PLY/3.11-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/PMIx/","title":"PMIx","text":"<p>Process Management for Exascale EnvironmentsPMI Exascale (PMIx) represents an attempt toprovide an extended version of the PMI standard specifically designedto support clusters up to and including exascale sizes. The overallobjective of the project is not to branch the existing pseudo-standarddefinitions - in fact, PMIx fully supports both of the existing PMI-1and PMI-2 APIs - but rather to (a) augment and extend those APIs toeliminate some current restrictions that impact scalability, and (b)provide a reference implementation of the PMI-server that demonstratesthe desired level of scalability.</p> <p>https://pmix.org/</p>"},{"location":"available_software/detail/PMIx/#available-modules","title":"Available modules","text":"<p>The overview below shows which PMIx installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PMIx, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PMIx/4.2.6-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PMIx/4.2.6-GCCcore-13.2.0 x x x x x x x x x x x PMIx/4.2.4-GCCcore-12.3.0 x x x x x x x x x x x PMIx/4.2.2-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/PROJ/","title":"PROJ","text":"<p>Program proj is a standard Unix filter function which convertsgeographic longitude and latitude coordinates into cartesian coordinates</p> <p>https://proj.org</p>"},{"location":"available_software/detail/PROJ/#available-modules","title":"Available modules","text":"<p>The overview below shows which PROJ installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PROJ, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PROJ/9.3.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PROJ/9.3.1-GCCcore-13.2.0 x x x x x x x x x x x PROJ/9.2.0-GCCcore-12.3.0 x x x x x x x x x x x PROJ/9.1.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Pandoc/","title":"Pandoc","text":"<p>If you need to convert files from one markup format into another, pandoc is your swiss-army knife</p> <p>https://pandoc.org</p>"},{"location":"available_software/detail/Pandoc/#available-modules","title":"Available modules","text":"<p>The overview below shows which Pandoc installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Pandoc, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Pandoc/3.6.2\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Pandoc/3.6.2 x x x x x x x x x x x"},{"location":"available_software/detail/Pango/","title":"Pango","text":"<p>Pango is a library for laying out and rendering of text, with an emphasis on internationalization.Pango can be used anywhere that text layout is needed, though most of the work on Pango so far has been done in thecontext of the GTK+ widget toolkit. Pango forms the core of text and font handling for GTK+-2.x.</p> <p>https://www.pango.org/</p>"},{"location":"available_software/detail/Pango/#available-modules","title":"Available modules","text":"<p>The overview below shows which Pango installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Pango, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Pango/1.51.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Pango/1.51.0-GCCcore-13.2.0 x x x x x x x x x x x Pango/1.50.14-GCCcore-12.3.0 x x x x x x x x x x x Pango/1.50.12-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/ParMETIS/","title":"ParMETIS","text":"<p>ParMETIS is an MPI-based parallel library that implements a variety of algorithms for partitioning unstructured graphs, meshes, and for computing fill-reducing orderings of sparse matrices. ParMETIS extends the functionality provided by METIS and includes routines that are especially suited for parallel AMR computations and large scale numerical simulations. The algorithms implemented in ParMETIS are based on the parallel multilevel k-way graph-partitioning, adaptive repartitioning, and parallel multi-constrained partitioning schemes.</p> <p>http://glaros.dtc.umn.edu/gkhome/metis/parmetis/overview</p>"},{"location":"available_software/detail/ParMETIS/#available-modules","title":"Available modules","text":"<p>The overview below shows which ParMETIS installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ParMETIS, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ParMETIS/4.0.3-gompi-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ParMETIS/4.0.3-gompi-2023a x x x x x x x x x x x"},{"location":"available_software/detail/ParaView/","title":"ParaView","text":"<p>ParaView is a scientific parallel visualizer.</p> <p>https://www.paraview.org</p>"},{"location":"available_software/detail/ParaView/#available-modules","title":"Available modules","text":"<p>The overview below shows which ParaView installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ParaView, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ParaView/5.11.2-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ParaView/5.11.2-foss-2023a x x x x x x x x x x x ParaView/5.11.1-foss-2022b x x x x x x x x x x x"},{"location":"available_software/detail/Paraver/","title":"Paraver","text":"<p>A very powerful performance visualization and analysis tool based on traces that can be used to analyse any information that is expressed on its input trace format. Traces for parallel MPI, OpenMP and other programs can be genereated with Extrae.</p> <p>https://tools.bsc.es/paraver</p>"},{"location":"available_software/detail/Paraver/#available-modules","title":"Available modules","text":"<p>The overview below shows which Paraver installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Paraver, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Paraver/4.11.4-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Paraver/4.11.4-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Perl-bundle-CPAN/","title":"Perl-bundle-CPAN","text":"<p>A set of common packages from CPAN</p> <p>https://www.perl.org/</p>"},{"location":"available_software/detail/Perl-bundle-CPAN/#available-modules","title":"Available modules","text":"<p>The overview below shows which Perl-bundle-CPAN installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Perl-bundle-CPAN, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Perl-bundle-CPAN/5.36.1-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Perl-bundle-CPAN/5.36.1-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Perl-bundle-CPAN/#perl-bundle-cpan5361-gcccore-1230","title":"Perl-bundle-CPAN/5.36.1-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>Algorithm::Dependency-1.112, Algorithm::Diff-1.201, aliased-0.34, AnyEvent-7.17, App::Cmd-0.335, App::cpanminus-1.7046, AppConfig-1.71, Archive::Extract-0.88, Array::Transpose-0.06, Array::Utils-0.5, Authen::NTLM-1.09, Authen::SASL-2.16, AutoLoader-5.74, B::COW-0.007, B::Hooks::EndOfScope-0.26, B::Lint-1.20, boolean-0.46, Business::ISBN-3.008, Business::ISBN::Data-20230516.001, Canary::Stability-2013, Capture::Tiny-0.48, Carp::Clan-6.08, Carp::Heavy-1.50, CGI-4.57, Class::Accessor-0.51, Class::Data::Inheritable-0.09, Class::DBI-v3.0.17, Class::DBI::SQLite-0.11, Class::Inspector-1.36, Class::ISA-0.36, Class::Load-0.25, Class::Load::XS-0.10, Class::Method::Modifiers-2.15, Class::Singleton-1.6, Class::Tiny-1.008, Class::Trigger-0.15, Class::XSAccessor-1.19, Clone-0.46, Clone::Choose-0.010, common::sense-3.75, Compress::Raw::Zlib-2.204, Config::General-2.65, Config::INI-0.029, Config::MVP-2.200013, Config::MVP::Reader::INI-2.101465, Config::Simple-4.58, Config::Tiny-2.29, Const::Exporter-1.2.2, Const::Fast-0.014, CPAN::Meta::Check-0.017, CPAN::Uploader-0.103018, CPANPLUS-0.9914, Crypt::DES-2.07, Crypt::Rijndael-1.16, Cwd-3.75, Cwd::Guard-0.05, Data::Dump-1.25, Data::Dumper::Concise-2.023, Data::Grove-0.08, Data::OptList-0.114, Data::Section-0.200008, Data::Section::Simple-0.07, Data::Stag-0.14, Data::Types-0.17, Data::UUID-1.226, Date::Handler-1.2, Date::Language-2.33, DateTime-1.59, DateTime::Locale-1.38, DateTime::TimeZone-2.60, DateTime::Tiny-1.07, DBD::CSV-0.60, DBD::SQLite-1.72, DBI-1.643, DBIx::Admin::CreateTable-2.11, DBIx::Admin::DSNManager-2.02, DBIx::Admin::TableInfo-3.04, DBIx::ContextualFetch-1.03, DBIx::Simple-1.37, Devel::CheckCompiler-0.07, Devel::CheckLib-1.16, Devel::Cycle-1.12, Devel::FindPerl-0.016, Devel::GlobalDestruction-0.14, Devel::OverloadInfo-0.007, Devel::Size-0.83, Devel::StackTrace-2.04, Digest::HMAC-1.04, Digest::MD5::File-0.08, Digest::SHA1-2.13, Dist::CheckConflicts-0.11, Dist::Zilla-6.030, Email::Date::Format-1.008, Encode-3.19, Encode::Locale-1.05, Error-0.17029, Eval::Closure-0.14, Exception::Class-1.45, Expect-1.35, Exporter::Declare-0.114, Exporter::Tiny-1.006002, ExtUtils::CBuilder-0.280236, ExtUtils::Config-0.008, ExtUtils::Constant-0.25, ExtUtils::CppGuess-0.26, ExtUtils::Helpers-0.026, ExtUtils::InstallPaths-0.012, ExtUtils::MakeMaker-7.70, ExtUtils::ParseXS-3.44, Fennec::Lite-0.004, File::CheckTree-4.42, File::Copy::Recursive-0.45, File::Copy::Recursive::Reduced-0.006, File::Find::Rule-0.34, File::Find::Rule::Perl-1.16, File::Grep-0.02, File::HomeDir-1.006, File::Listing-6.15, File::Next-1.18, File::pushd-1.016, File::Remove-1.61, File::ShareDir-1.118, File::ShareDir::Install-0.14, File::Slurp-9999.32, File::Slurp::Tiny-0.004, File::Slurper-0.014, File::Temp-0.2311, File::Which-1.27, Font::TTF-1.06, Getopt::Long::Descriptive-0.111, Git-0.42, GO-0.04, GO::Utils-0.15, Graph-0.9726, Graph::ReadWrite-2.10, Hash::Merge-0.302, Hash::Objectify-0.008, Heap-0.80, Hook::LexWrap-0.26, HTML::Entities::Interpolate-1.10, HTML::Form-6.11, HTML::Parser-3.81, HTML::Tagset-3.20, HTML::Template-2.97, HTML::Tree-5.07, HTTP::CookieJar-0.014, HTTP::Cookies-6.10, HTTP::Daemon-6.16, HTTP::Date-6.05, HTTP::Message-6.44, HTTP::Negotiate-6.01, HTTP::Tiny-0.082, if-0.0608, Ima::DBI-0.35, Import::Into-1.002005, Importer-0.026, Inline-0.86, IO::Compress::Zip-2.204, IO::HTML-1.004, IO::Socket::SSL-2.083, IO::String-1.08, IO::Stringy-2.113, IO::TieCombine-1.005, IO::Tty-1.17, IO::Tty-1.17, IPC::Cmd-1.04, IPC::Run-20220807.0, IPC::Run3-0.048, IPC::System::Simple-1.30, JSON-4.10, JSON::MaybeXS-1.004005, JSON::XS-4.03, Lingua::EN::PluralToSingular-0.21, List::AllUtils-0.19, List::MoreUtils-0.430, List::MoreUtils::XS-0.430, List::SomeUtils-0.59, List::UtilsBy-0.12, local::lib-2.000029, Locale::Maketext::Simple-0.21, Log::Dispatch-2.71, Log::Dispatch::Array-1.005, Log::Dispatchouli-3.002, Log::Handler-0.90, Log::Log4perl-1.57, Log::Message-0.08, Log::Message::Simple-0.10, Log::Report-1.34, Log::Report::Optional-1.07, Logger::Simple-2.0, LWP::MediaTypes-6.04, LWP::Protocol::https-6.10, LWP::Simple-6.70, Mail::Util-2.21, Math::Bezier-0.01, Math::CDF-0.1, Math::Round-0.07, Math::Utils-1.14, Math::VecStat-0.08, MCE::Mutex-1.884, Meta::Builder-0.004, MIME::Base64-3.16, MIME::Charset-v1.013.1, MIME::Lite-3.033, MIME::Types-2.24, Mixin::Linewise::Readers-0.111, Mock::Quick-1.111, Module::Build-0.4234, Module::Build::Tiny-0.045, Module::Build::XSUtil-0.19, Module::CoreList-5.20230423, Module::Implementation-0.09, Module::Install-1.21, Module::Load-0.36, Module::Load::Conditional-0.74, Module::Metadata-1.000038, Module::Path-0.19, Module::Path-0.19, Module::Pluggable-5.2, Module::Runtime-0.016, Module::Runtime::Conflicts-0.003, Moo-2.005005, Moose-2.2203, MooseX::LazyRequire-0.11, MooseX::OneArgNew-0.007, MooseX::Role::Parameterized-1.11, MooseX::SetOnce-0.203, MooseX::Types-0.50, MooseX::Types::Perl-0.101344, Mouse-v2.5.10, Mozilla::CA-20221114, MRO::Compat-0.15, namespace::autoclean-0.29, namespace::clean-0.27, Net::Domain-3.15, Net::HTTP-6.22, Net::SMTP::SSL-1.04, Net::SNMP-v6.0.1, Net::SSLeay-1.92, Number::Compare-0.03, Number::Format-1.75, Object::Accessor-0.48, Object::InsideOut-4.05, Object::InsideOut-4.05, Package::Constants-0.06, Package::DeprecationManager-0.18, Package::Stash-0.40, Package::Stash::XS-0.30, PadWalker-2.5, Parallel::ForkManager-2.02, Params::Check-0.38, Params::Util-1.102, Params::Validate-1.31, Params::ValidationCompiler-0.31, parent-0.241, Parse::RecDescent-1.967015, Parse::Yapp-1.21, Path::Tiny-0.144, PDF::API2-2.044, Perl::OSType-1.010, Perl::PrereqScanner-1.100, PerlIO::utf8_strict-0.010, Pod::Elemental-0.103006, Pod::Escapes-1.07, Pod::Eventual-0.094003, Pod::LaTeX-0.61, Pod::Man-5.01, Pod::Parser-1.66, Pod::Plainer-1.04, Pod::POM-2.01, Pod::Simple-3.45, Pod::Weaver-4.019, PPI-1.276, Readonly-2.05, Ref::Util-0.204, Regexp::Common-2017060201, Role::HasMessage-0.007, Role::Identifiable::HasIdent-0.009, Role::Tiny-2.002004, Scalar::Util-1.63, Scalar::Util::Numeric-0.40, Scope::Guard-0.21, Set::Array-0.30, Set::IntervalTree-0.12, Set::IntSpan-1.19, Set::IntSpan::Fast-1.15, Set::Object-1.42, Set::Scalar-1.29, Shell-0.73, Socket-2.036, Software::License-0.104003, Specio-0.48, Spiffy-0.46, SQL::Abstract-2.000001, SQL::Statement-1.414, Statistics::Basic-1.6611, Statistics::Descriptive-3.0800, Storable-3.25, strictures-2.000006, String::Errf-0.009, String::Flogger-1.101246, String::Formatter-1.235, String::Print-0.94, String::RewritePrefix-0.009, String::Truncate-1.100603, String::TtyLength-0.03, Sub::Exporter-0.989, Sub::Exporter::ForMethods-0.100055, Sub::Exporter::GlobExporter-0.006, Sub::Exporter::Progressive-0.001013, Sub::Identify-0.14, Sub::Info-0.002, Sub::Install-0.929, Sub::Name-0.27, Sub::Quote-2.006008, Sub::Uplevel-0.2800, SVG-2.87, Switch-2.17, Sys::Info-0.7811, Sys::Info::Base-0.7807, Sys::Info::Driver::Linux-0.7905, Sys::Info::Driver::Linux::Device::CPU-0.7905, Sys::Info::Driver::Unknown-0.79, Sys::Info::Driver::Unknown::Device::CPU-0.79, Template-3.101, Template::Plugin::Number::Format-1.06, Term::Encoding-0.03, Term::ReadKey-2.38, Term::ReadLine::Gnu-1.45, Term::Table-0.016, Term::UI-0.50, Test-1.26, Test2::Plugin::NoWarnings-0.09, Test2::Require::Module-0.000155, Test::Base-0.89, Test::CheckDeps-0.010, Test::ClassAPI-1.07, Test::CleanNamespaces-0.24, Test::Deep-1.204, Test::Differences-0.69, Test::Exception-0.43, Test::FailWarnings-0.008, Test::Fatal-0.017, Test::File-1.993, Test::File::ShareDir::Dist-1.001002, Test::Harness-3.44, Test::LeakTrace-0.17, Test::Memory::Cycle-1.06, Test::More::UTF8-0.05, Test::Most-0.38, Test::Needs-0.002010, Test::NoWarnings-1.06, Test::Object-0.08, Test::Output-1.033, Test::Pod-1.52, Test::Requires-0.11, Test::RequiresInternet-0.05, Test::Simple-1.302195, Test::SubCalls-1.10, Test::Sys::Info-0.23, Test::Version-2.09, Test::Warn-0.37, Test::Warnings-0.031, Test::Without::Module-0.21, Test::YAML-1.07, Text::Aligner-0.16, Text::Balanced-2.06, Text::CSV-2.02, Text::CSV_XS-1.50, Text::Diff-1.45, Text::Format-0.62, Text::Glob-0.11, Text::Iconv-1.7, Text::Soundex-3.05, Text::Table-1.135, Text::Table::Manifold-1.03, Text::Template-1.61, Throwable-1.001, Tie::Function-0.02, Tie::IxHash-1.23, Time::HiRes-1.9764, Time::Local-1.35, Time::Piece-1.3401, Time::Piece::MySQL-0.06, Tree::DAG_Node-1.32, Try::Tiny-0.31, Type::Tiny-2.004000, Types::Serialiser-1.01, Types::Serialiser-1.01, Unicode::EastAsianWidth-12.0, Unicode::LineBreak-2019.001, UNIVERSAL::moniker-0.08, Unix::Processors-2.046, Unix::Processors-2.046, URI-5.19, Variable::Magic-0.63, version-0.9929, Want-0.29, WWW::RobotRules-6.02, XML::Bare-0.53, XML::DOM-1.46, XML::Filter::BufferText-1.01, XML::NamespaceSupport-1.12, XML::Parser-2.46, XML::RegExp-0.04, XML::SAX-1.02, XML::SAX::Base-1.09, XML::SAX::Expat-0.51, XML::SAX::Writer-0.57, XML::Simple-2.25, XML::Tiny-2.07, XML::Twig-3.52, XML::Writer-0.900, XML::XPath-1.48, XSLoader-0.24, YAML-1.30, YAML::Tiny-1.74</p>"},{"location":"available_software/detail/Perl/","title":"Perl","text":"<p>Larry Wall's Practical Extraction and Report LanguageIncludes a small selection of extra CPAN packages for core functionality.</p> <p>https://www.perl.org/</p>"},{"location":"available_software/detail/Perl/#available-modules","title":"Available modules","text":"<p>The overview below shows which Perl installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Perl, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Perl/5.38.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Perl/5.38.0-GCCcore-13.2.0 x x x x x x x x x x x Perl/5.36.1-GCCcore-12.3.0 x x x x x x x x x x x Perl/5.36.0-GCCcore-12.2.0-minimal x x x x x x x x x x x Perl/5.36.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Perl/#perl5380-gcccore-1320","title":"Perl/5.38.0-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>Carp-1.50, constant-1.33, Data::Dumper-2.183, Exporter-5.77, File::Path-2.18, File::Spec-3.75, Getopt::Long-2.54, IO::File-1.51, Text::ParseWords-3.31, Thread::Queue-3.13, threads-2.21</p>"},{"location":"available_software/detail/Perl/#perl5361-gcccore-1230","title":"Perl/5.36.1-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>Carp-1.50, constant-1.33, Data::Dumper-2.183, Exporter-5.77, File::Path-2.18, File::Spec-3.75, Getopt::Long-2.54, IO::File-1.51, Text::ParseWords-3.31, Thread::Queue-3.13, threads-2.21</p>"},{"location":"available_software/detail/Perl/#perl5360-gcccore-1220","title":"Perl/5.36.0-GCCcore-12.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>Algorithm::Dependency-1.112, Algorithm::Diff-1.201, aliased-0.34, AnyEvent-7.17, App::Cmd-0.334, App::cpanminus-1.7046, AppConfig-1.71, Archive::Extract-0.88, Array::Transpose-0.06, Array::Utils-0.5, Authen::NTLM-1.09, Authen::SASL-2.16, AutoLoader-5.74, B::Hooks::EndOfScope-0.26, B::Lint-1.20, boolean-0.46, Business::ISBN-3.007, Business::ISBN::Data-20210112.006, Canary::Stability-2013, Capture::Tiny-0.48, Carp-1.50, Carp::Clan-6.08, Carp::Heavy-1.50, Class::Accessor-0.51, Class::Data::Inheritable-0.09, Class::DBI-v3.0.17, Class::DBI::SQLite-0.11, Class::Inspector-1.36, Class::ISA-0.36, Class::Load-0.25, Class::Load::XS-0.10, Class::Singleton-1.6, Class::Tiny-1.008, Class::Trigger-0.15, Clone-0.45, Clone::Choose-0.010, common::sense-3.75, Config::General-2.65, Config::INI-0.027, Config::MVP-2.200012, Config::Simple-4.58, Config::Tiny-2.28, constant-1.33, CPAN::Meta::Check-0.014, CPANPLUS-0.9914, Crypt::DES-2.07, Crypt::Rijndael-1.16, Cwd-3.75, Cwd::Guard-0.05, Data::Dump-1.25, Data::Dumper-2.183, Data::Dumper::Concise-2.023, Data::Grove-0.08, Data::OptList-0.112, Data::Section-0.200007, Data::Section::Simple-0.07, Data::Stag-0.14, Data::Types-0.17, Data::UUID-1.226, Date::Handler-1.2, Date::Language-2.33, DateTime-1.58, DateTime::Locale-1.36, DateTime::TimeZone-2.53, DateTime::Tiny-1.07, DBD::CSV-0.59, DBD::SQLite-1.70, DBI-1.643, DBIx::Admin::TableInfo-3.04, DBIx::ContextualFetch-1.03, DBIx::Simple-1.37, Devel::CheckCompiler-0.07, Devel::CheckLib-1.16, Devel::Cycle-1.12, Devel::GlobalDestruction-0.14, Devel::OverloadInfo-0.007, Devel::Size-0.83, Devel::StackTrace-2.04, Digest::HMAC-1.04, Digest::MD5::File-0.08, Digest::SHA1-2.13, Dist::CheckConflicts-0.11, Dist::Zilla-6.025, Email::Date::Format-1.005, Encode-3.19, Encode::Locale-1.05, Error-0.17029, Eval::Closure-0.14, Exception::Class-1.45, Expect-1.35, Exporter-5.74, Exporter::Declare-0.114, Exporter::Tiny-1.004000, ExtUtils::CBuilder-0.280236, ExtUtils::Config-0.008, ExtUtils::Constant-0.25, ExtUtils::CppGuess-0.26, ExtUtils::Helpers-0.026, ExtUtils::InstallPaths-0.012, ExtUtils::MakeMaker-7.64, ExtUtils::ParseXS-3.44, Fennec::Lite-0.004, File::CheckTree-4.42, File::Copy::Recursive-0.45, File::Copy::Recursive::Reduced-0.006, File::Find::Rule-0.34, File::Find::Rule::Perl-1.16, File::Grep-0.02, File::HomeDir-1.006, File::Listing-6.15, File::Next-1.18, File::Path-2.18, File::pushd-1.016, File::Remove-1.61, File::ShareDir-1.118, File::ShareDir::Install-0.14, File::Slurp-9999.32, File::Slurp::Tiny-0.004, File::Slurper-0.013, File::Spec-3.75, File::Temp-0.2311, File::Which-1.27, Font::TTF-1.06, Getopt::Long-2.52, Getopt::Long::Descriptive-0.110, Git-0.42, GO-0.04, GO::Utils-0.15, Graph-0.9725, Graph::ReadWrite-2.10, Hash::Merge-0.302, Heap-0.80, HTML::Entities::Interpolate-1.10, HTML::Form-6.10, HTML::Parser-3.78, HTML::Tagset-3.20, HTML::Template-2.97, HTML::Tree-5.07, HTTP::Cookies-6.10, HTTP::Daemon-6.14, HTTP::Date-6.05, HTTP::Negotiate-6.01, HTTP::Request-6.37, HTTP::Tiny-0.082, if-0.0608, Ima::DBI-0.35, Import::Into-1.002005, Importer-0.026, Inline-0.86, IO::HTML-1.004, IO::Socket::SSL-2.075, IO::String-1.08, IO::Stringy-2.113, IO::Tty-1.16, IPC::Cmd-1.04, IPC::Run-20220807.0, IPC::Run3-0.048, IPC::System::Simple-1.30, JSON-4.09, JSON::XS-4.03, Lingua::EN::PluralToSingular-0.21, List::AllUtils-0.19, List::MoreUtils-0.430, List::MoreUtils::XS-0.430, List::SomeUtils-0.58, List::Util-1.63, List::UtilsBy-0.12, local::lib-2.000029, Locale::Maketext::Simple-0.21, Log::Dispatch-2.70, Log::Dispatchouli-2.023, Log::Handler-0.90, Log::Log4perl-1.56, Log::Message-0.08, Log::Message::Simple-0.10, Log::Report-1.33, Log::Report::Optional-1.07, Logger::Simple-2.0, LWP::MediaTypes-6.04, LWP::Protocol::https-6.10, LWP::Simple-6.67, Mail::Util-2.21, Math::Bezier-0.01, Math::CDF-0.1, Math::Round-0.07, Math::Utils-1.14, Math::VecStat-0.08, MCE::Mutex-1.879, Meta::Builder-0.004, MIME::Base64-3.16, MIME::Charset-1.013.1, MIME::Lite-3.033, MIME::Types-2.22, Mixin::Linewise::Readers-0.110, Mock::Quick-1.111, Module::Build-0.4231, Module::Build::Tiny-0.039, Module::Build::XSUtil-0.19, Module::CoreList-5.20220820, Module::Implementation-0.09, Module::Install-1.19, Module::Load-0.36, Module::Load::Conditional-0.74, Module::Metadata-1.000037, Module::Path-0.19, Module::Pluggable-5.2, Module::Runtime-0.016, Module::Runtime::Conflicts-0.003, Moo-2.005004, Moose-2.2201, MooseX::LazyRequire-0.11, MooseX::OneArgNew-0.006, MooseX::Role::Parameterized-1.11, MooseX::SetOnce-0.201, MooseX::Types-0.50, MooseX::Types::Perl-0.101343, Mouse-v2.5.10, Mozilla::CA-20211001, MRO::Compat-0.15, namespace::autoclean-0.29, namespace::clean-0.27, Net::Domain-3.14, Net::HTTP-6.22, Net::SMTP::SSL-1.04, Net::SNMP-v6.0.1, Net::SSLeay-1.92, Number::Compare-0.03, Number::Format-1.75, Object::Accessor-0.48, Object::InsideOut-4.05, Package::Constants-0.06, Package::DeprecationManager-0.17, Package::Stash-0.40, Package::Stash::XS-0.30, PadWalker-2.5, Parallel::ForkManager-2.02, Params::Check-0.38, Params::Util-1.102, Params::Validate-1.30, Params::ValidationCompiler-0.30, parent-0.238, Parse::RecDescent-1.967015, Path::Tiny-0.124, PDF::API2-2.043, Perl::OSType-1.010, PerlIO::utf8_strict-0.009, Pod::Elemental-0.103005, Pod::Escapes-1.07, Pod::Eventual-0.094002, Pod::LaTeX-0.61, Pod::Man-4.14, Pod::Parser-1.66, Pod::Plainer-1.04, Pod::POM-2.01, Pod::Simple-3.43, Pod::Weaver-4.018, Readonly-2.05, Regexp::Common-2017060201, Role::HasMessage-0.006, Role::Identifiable::HasIdent-0.008, Role::Tiny-2.002004, Scalar::Util-1.63, Scalar::Util::Numeric-0.40, Scope::Guard-0.21, Set::Array-0.30, Set::IntervalTree-0.12, Set::IntSpan-1.19, Set::IntSpan::Fast-1.15, Set::Object-1.42, Set::Scalar-1.29, Shell-0.73, Socket-2.036, Software::License-0.104002, Specio-0.48, SQL::Abstract-2.000001, SQL::Statement-1.414, Statistics::Basic-1.6611, Statistics::Descriptive-3.0800, Storable-3.25, strictures-2.000006, String::Flogger-1.101245, String::Print-0.94, String::RewritePrefix-0.008, String::Truncate-1.100602, Sub::Exporter-0.988, Sub::Exporter::ForMethods-0.100054, Sub::Exporter::Progressive-0.001013, Sub::Identify-0.14, Sub::Info-0.002, Sub::Install-0.928, Sub::Name-0.26, Sub::Quote-2.006006, Sub::Uplevel-0.2800, Sub::Uplevel-0.2800, SVG-2.87, Switch-2.17, Sys::Info-0.7811, Sys::Info::Base-0.7807, Sys::Info::Driver::Linux-0.7905, Sys::Info::Driver::Unknown-0.79, Template-3.101, Template::Plugin::Number::Format-1.06, Term::Encoding-0.03, Term::ReadKey-2.38, Term::ReadLine::Gnu-1.42, Term::Table-0.016, Term::UI-0.50, Test-1.26, Test2::Plugin::NoWarnings-0.09, Test2::Require::Module-0.000145, Test::ClassAPI-1.07, Test::CleanNamespaces-0.24, Test::Deep-1.130, Test::Differences-0.69, Test::Exception-0.43, Test::Fatal-0.016, Test::File::ShareDir::Dist-1.001002, Test::Harness-3.44, Test::LeakTrace-0.17, Test::Memory::Cycle-1.06, Test::More-1.302191, Test::More::UTF8-0.05, Test::Most-0.37, Test::Needs-0.002009, Test::NoWarnings-1.06, Test::Output-1.033, Test::Pod-1.52, Test::Requires-0.11, Test::RequiresInternet-0.05, Test::Simple-1.302191, Test::Version-2.09, Test::Warn-0.37, Test::Warnings-0.031, Test::Without::Module-0.20, Text::Aligner-0.16, Text::Balanced-2.06, Text::CSV-2.02, Text::CSV_XS-1.48, Text::Diff-1.45, Text::Format-0.62, Text::Glob-0.11, Text::Iconv-1.7, Text::ParseWords-3.31, Text::Soundex-3.05, Text::Table-1.134, Text::Template-1.61, Thread::Queue-3.13, Throwable-1.000, Tie::Function-0.02, Tie::IxHash-1.23, Time::HiRes-1.9764, Time::Local-1.30, Time::Piece-1.3401, Time::Piece::MySQL-0.06, Tree::DAG_Node-1.32, Try::Tiny-0.31, Types::Serialiser-1.01, Unicode::LineBreak-2019.001, UNIVERSAL::moniker-0.08, Unix::Processors-2.046, URI-5.12, URI::Escape-5.12, Variable::Magic-0.62, version-0.9929, Want-0.29, WWW::RobotRules-6.02, XML::Bare-0.53, XML::DOM-1.46, XML::Filter::BufferText-1.01, XML::NamespaceSupport-1.12, XML::Parser-2.46, XML::RegExp-0.04, XML::SAX-1.02, XML::SAX::Base-1.09, XML::SAX::Expat-0.51, XML::SAX::Writer-0.57, XML::Simple-2.25, XML::Tiny-2.07, XML::Twig-3.52, XML::XPath-1.48, XSLoader-0.24, YAML-1.30, YAML::Tiny-1.73</p>"},{"location":"available_software/detail/Pillow-SIMD/","title":"Pillow-SIMD","text":"<p>Pillow is the 'friendly PIL fork' by Alex Clark and Contributors. PIL is the Python Imaging Library by Fredrik Lundh and Contributors.</p> <p>https://github.com/uploadcare/pillow-simd</p>"},{"location":"available_software/detail/Pillow-SIMD/#available-modules","title":"Available modules","text":"<p>The overview below shows which Pillow-SIMD installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Pillow-SIMD, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Pillow-SIMD/9.5.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Pillow-SIMD/9.5.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Pillow/","title":"Pillow","text":"<p>Pillow is the 'friendly PIL fork' by Alex Clark and Contributors. PIL is the Python Imaging Library by Fredrik Lundh and Contributors.</p> <p>https://pillow.readthedocs.org/</p>"},{"location":"available_software/detail/Pillow/#available-modules","title":"Available modules","text":"<p>The overview below shows which Pillow installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Pillow, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Pillow/10.2.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Pillow/10.2.0-GCCcore-13.2.0 x x x x x x x x x x x Pillow/10.0.0-GCCcore-12.3.0 x x x x x x x x x x x Pillow/9.4.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Pint/","title":"Pint","text":"<p>Pint is a Python package to define, operate andmanipulate physical quantities: the product of a numerical value and aunit of measurement. It allows arithmetic operations between them andconversions from and to different units.</p> <p>https://github.com/hgrecco/pint</p>"},{"location":"available_software/detail/Pint/#available-modules","title":"Available modules","text":"<p>The overview below shows which Pint installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Pint, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Pint/0.24-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Pint/0.24-GCCcore-13.2.0 x x x x x x x x x x x Pint/0.23-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Pint/#pint024-gcccore-1320","title":"Pint/0.24-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>appdirs-1.4.4, flexcache-0.3, flexparser-0.3.1, Pint-0.24</p>"},{"location":"available_software/detail/PnetCDF/","title":"PnetCDF","text":"<p>Parallel netCDF: A Parallel I/O Library for NetCDF File Access</p> <p>https://parallel-netcdf.github.io/</p>"},{"location":"available_software/detail/PnetCDF/#available-modules","title":"Available modules","text":"<p>The overview below shows which PnetCDF installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PnetCDF, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PnetCDF/1.12.3-gompi-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PnetCDF/1.12.3-gompi-2023a x x x x x x x x x x x"},{"location":"available_software/detail/PostgreSQL/","title":"PostgreSQL","text":"<p>PostgreSQL is a powerful, open source object-relational database system. It is fully ACID compliant, has full support for foreign keys, joins, views, triggers, and stored procedures (in multiple languages). It includes most SQL:2008 data types, including INTEGER, NUMERIC, BOOLEAN, CHAR, VARCHAR, DATE, INTERVAL, and TIMESTAMP. It also supports storage of binary large objects, including pictures, sounds, or video. It has native programming interfaces for C/C++, Java, .Net, Perl, Python, Ruby, Tcl, ODBC, among others, and exceptional documentation.</p> <p>https://www.postgresql.org/</p>"},{"location":"available_software/detail/PostgreSQL/#available-modules","title":"Available modules","text":"<p>The overview below shows which PostgreSQL installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PostgreSQL, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PostgreSQL/16.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PostgreSQL/16.1-GCCcore-13.2.0 x x x x x x x x x x x PostgreSQL/16.1-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/PuLP/","title":"PuLP","text":"<p>PuLP is an LP modeler written in Python. PuLP can generate MPS or LP files andcall GLPK, COIN-OR CLP/CBC, CPLEX, GUROBI, MOSEK, XPRESS, CHOCO, MIPCL, SCIP tosolve linear problems.</p> <p>https://github.com/coin-or/pulp</p>"},{"location":"available_software/detail/PuLP/#available-modules","title":"Available modules","text":"<p>The overview below shows which PuLP installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PuLP, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PuLP/2.8.0-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PuLP/2.8.0-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/PyCairo/","title":"PyCairo","text":"<p>Python bindings for the cairo library</p> <p>https://pycairo.readthedocs.io/</p>"},{"location":"available_software/detail/PyCairo/#available-modules","title":"Available modules","text":"<p>The overview below shows which PyCairo installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PyCairo, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PyCairo/1.25.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PyCairo/1.25.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/PyGObject/","title":"PyGObject","text":"<p>PyGObject is a Python package which provides bindings for GObject basedlibraries such as GTK, GStreamer, WebKitGTK, GLib, GIO and many more.</p> <p>https://pygobject.readthedocs.io/</p>"},{"location":"available_software/detail/PyGObject/#available-modules","title":"Available modules","text":"<p>The overview below shows which PyGObject installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PyGObject, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PyGObject/3.46.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PyGObject/3.46.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/PyOpenGL/","title":"PyOpenGL","text":"<p>PyOpenGL is the most common cross platform Python binding to OpenGL and related APIs.</p> <p>http://pyopengl.sourceforge.net</p>"},{"location":"available_software/detail/PyOpenGL/#available-modules","title":"Available modules","text":"<p>The overview below shows which PyOpenGL installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PyOpenGL, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PyOpenGL/3.1.7-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PyOpenGL/3.1.7-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/PyOpenGL/#pyopengl317-gcccore-1230","title":"PyOpenGL/3.1.7-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>PyOpenGL-3.1.7, PyOpenGL-accelerate-3.1.7</p>"},{"location":"available_software/detail/PyQt-builder/","title":"PyQt-builder","text":"<p>PyQt-builder is the PEP 517 compliant build system for PyQt and projects that   extend PyQt. It extends the SIP build system and uses Qt\u2019s qmake to perform the actual compilation and installation of extension modules.</p> <p>http://www.example.com</p>"},{"location":"available_software/detail/PyQt-builder/#available-modules","title":"Available modules","text":"<p>The overview below shows which PyQt-builder installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PyQt-builder, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PyQt-builder/1.15.4-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PyQt-builder/1.15.4-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/PyQt-builder/#pyqt-builder1154-gcccore-1230","title":"PyQt-builder/1.15.4-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>PyQt-builder-1.15.4</p>"},{"location":"available_software/detail/PyQt5/","title":"PyQt5","text":"<p>PyQt5 is a set of Python bindings for v5 of the Qt application framework from The Qt Company.This bundle includes PyQtWebEngine, a set of Python bindings for The Qt Company\u2019s Qt WebEngine framework.</p> <p>https://www.riverbankcomputing.com/software/pyqt</p>"},{"location":"available_software/detail/PyQt5/#available-modules","title":"Available modules","text":"<p>The overview below shows which PyQt5 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PyQt5, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PyQt5/5.15.10-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PyQt5/5.15.10-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/PyTorch/","title":"PyTorch","text":"<p>Tensors and Dynamic neural networks in Python with strong GPU acceleration.PyTorch is a deep learning framework that puts Python first.</p> <p>https://pytorch.org/</p>"},{"location":"available_software/detail/PyTorch/#available-modules","title":"Available modules","text":"<p>The overview below shows which PyTorch installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PyTorch, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PyTorch/2.1.2-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PyTorch/2.1.2-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/PyYAML/","title":"PyYAML","text":"<p>PyYAML is a YAML parser and emitter for the Python programming language.</p> <p>https://github.com/yaml/pyyaml</p>"},{"location":"available_software/detail/PyYAML/#available-modules","title":"Available modules","text":"<p>The overview below shows which PyYAML installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PyYAML, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PyYAML/6.0.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PyYAML/6.0.1-GCCcore-13.2.0 x x x x x x x x x x x PyYAML/6.0-GCCcore-12.3.0 x x x x x x x x x x x PyYAML/6.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/PyZMQ/","title":"PyZMQ","text":"<p>Python bindings for ZeroMQ</p> <p>https://www.zeromq.org/bindings:python</p>"},{"location":"available_software/detail/PyZMQ/#available-modules","title":"Available modules","text":"<p>The overview below shows which PyZMQ installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using PyZMQ, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load PyZMQ/25.1.1-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 PyZMQ/25.1.1-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Pygments/","title":"Pygments","text":"<p>Generic syntax highlighter suitable for use in code hosting, forums, wikis or other applications that need to prettify source code.</p> <p>https://pygments.org/</p>"},{"location":"available_software/detail/Pygments/#available-modules","title":"Available modules","text":"<p>The overview below shows which Pygments installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Pygments, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Pygments/2.18.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Pygments/2.18.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Pysam/","title":"Pysam","text":"<p>Pysam is a python module for reading and manipulating Samfiles. It's a lightweight wrapper of the samtools C-API. Pysam also includes an interface for tabix.</p> <p>https://github.com/pysam-developers/pysam</p>"},{"location":"available_software/detail/Pysam/#available-modules","title":"Available modules","text":"<p>The overview below shows which Pysam installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Pysam, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Pysam/0.22.0-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Pysam/0.22.0-GCC-12.3.0 x x x x x x x x x x x Pysam/0.21.0-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Python-bundle-PyPI/","title":"Python-bundle-PyPI","text":"<p>Bundle of Python packages from PyPI</p> <p>https://python.org/</p>"},{"location":"available_software/detail/Python-bundle-PyPI/#available-modules","title":"Available modules","text":"<p>The overview below shows which Python-bundle-PyPI installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Python-bundle-PyPI, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Python-bundle-PyPI/2023.10-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Python-bundle-PyPI/2023.10-GCCcore-13.2.0 x x x x x x x x x x x Python-bundle-PyPI/2023.06-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Python-bundle-PyPI/#python-bundle-pypi202310-gcccore-1320","title":"Python-bundle-PyPI/2023.10-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>alabaster-0.7.13, appdirs-1.4.4, asn1crypto-1.5.1, atomicwrites-1.4.1, attrs-23.1.0, Babel-2.13.1, backports.entry-points-selectable-1.2.0, backports.functools_lru_cache-1.6.6, bitarray-2.8.2, bitstring-4.1.2, blist-1.3.6, cachecontrol-0.13.1, cachy-0.3.0, certifi-2023.7.22, cffi-1.16.0, chardet-5.2.0, charset-normalizer-3.3.1, cleo-2.0.1, click-8.1.7, cloudpickle-3.0.0, colorama-0.4.6, commonmark-0.9.1, crashtest-0.4.1, Cython-3.0.4, decorator-5.1.1, distlib-0.3.7, distro-1.8.0, docopt-0.6.2, docutils-0.20.1, doit-0.36.0, dulwich-0.21.6, ecdsa-0.18.0, editables-0.5, exceptiongroup-1.1.3, execnet-2.0.2, filelock-3.13.0, fsspec-2023.10.0, future-0.18.3, glob2-0.7, html5lib-1.1, idna-3.4, imagesize-1.4.1, importlib_metadata-6.8.0, importlib_resources-6.1.0, iniconfig-2.0.0, intervaltree-3.1.0, intreehooks-1.0, ipaddress-1.0.23, jaraco.classes-3.3.0, jeepney-0.8.0, Jinja2-3.1.2, joblib-1.3.2, jsonschema-4.17.3, keyring-24.2.0, keyrings.alt-5.0.0, liac-arff-2.5.0, lockfile-0.12.2, markdown-it-py-3.0.0, MarkupSafe-2.1.3, mdurl-0.1.2, mock-5.1.0, more-itertools-10.1.0, msgpack-1.0.7, netaddr-0.9.0, netifaces-0.11.0, packaging-23.2, pastel-0.2.1, pathlib2-2.3.7.post1, pathspec-0.11.2, pbr-5.11.1, pexpect-4.8.0, pkginfo-1.9.6, platformdirs-3.11.0, pluggy-1.3.0, pooch-1.8.0, psutil-5.9.6, ptyprocess-0.7.0, py-1.11.0, py_expression_eval-0.3.14, pyasn1-0.5.0, pycparser-2.21, pycryptodome-3.19.0, pydevtool-0.3.0, Pygments-2.16.1, Pygments-2.16.1, pylev-1.4.0, PyNaCl-1.5.0, pyparsing-3.1.1, pyrsistent-0.20.0, pytest-7.4.3, pytest-xdist-3.3.1, python-dateutil-2.8.2, pytoml-0.1.21, pytz-2023.3.post1, rapidfuzz-2.15.2, regex-2023.10.3, requests-2.31.0, requests-toolbelt-1.0.0, rich-13.6.0, rich-click-1.7.0, scandir-1.10.0, SecretStorage-3.3.3, semantic_version-2.10.0, shellingham-1.5.4, simplegeneric-0.8.1, simplejson-3.19.2, six-1.16.0, snowballstemmer-2.2.0, sortedcontainers-2.4.0, sphinx-7.2.6, sphinx-bootstrap-theme-0.8.1, sphinxcontrib-jsmath-1.0.1, sphinxcontrib_applehelp-1.0.7, sphinxcontrib_devhelp-1.0.5, sphinxcontrib_htmlhelp-2.0.4, sphinxcontrib_qthelp-1.0.6, sphinxcontrib_serializinghtml-1.1.9, sphinxcontrib_websupport-1.2.6, tabulate-0.9.0, threadpoolctl-3.2.0, toml-0.10.2, tomli-2.0.1, tomli_w-1.0.0, tomlkit-0.12.1, ujson-5.8.0, urllib3-2.0.7, wcwidth-0.2.8, webencodings-0.5.1, xlrd-2.0.1, zipfile36-0.1.3, zipp-3.17.0</p>"},{"location":"available_software/detail/Python-bundle-PyPI/#python-bundle-pypi202306-gcccore-1230","title":"Python-bundle-PyPI/2023.06-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>alabaster-0.7.13, appdirs-1.4.4, asn1crypto-1.5.1, atomicwrites-1.4.1, attrs-23.1.0, Babel-2.12.1, backports.entry-points-selectable-1.2.0, backports.functools_lru_cache-1.6.5, bitstring-4.0.2, blist-1.3.6, CacheControl-0.12.14, cachy-0.3.0, certifi-2023.5.7, cffi-1.15.1, chardet-5.1.0, charset-normalizer-3.1.0, cleo-2.0.1, click-8.1.3, cloudpickle-2.2.1, colorama-0.4.6, commonmark-0.9.1, crashtest-0.4.1, Cython-0.29.35, decorator-5.1.1, distlib-0.3.6, distro-1.8.0, docopt-0.6.2, docutils-0.20.1, doit-0.36.0, dulwich-0.21.5, ecdsa-0.18.0, editables-0.3, exceptiongroup-1.1.1, execnet-1.9.0, filelock-3.12.2, fsspec-2023.6.0, future-0.18.3, glob2-0.7, html5lib-1.1, idna-3.4, imagesize-1.4.1, importlib_metadata-6.7.0, importlib_resources-5.12.0, iniconfig-2.0.0, intervaltree-3.1.0, intreehooks-1.0, ipaddress-1.0.23, jaraco.classes-3.2.3, jeepney-0.8.0, Jinja2-3.1.2, joblib-1.2.0, jsonschema-4.17.3, keyring-23.13.1, keyrings.alt-4.2.0, liac-arff-2.5.0, lockfile-0.12.2, markdown-it-py-3.0.0, MarkupSafe-2.1.3, mdurl-0.1.2, mock-5.0.2, more-itertools-9.1.0, msgpack-1.0.5, netaddr-0.8.0, netifaces-0.11.0, packaging-23.1, pastel-0.2.1, pathlib2-2.3.7.post1, pathspec-0.11.1, pbr-5.11.1, pexpect-4.8.0, pkginfo-1.9.6, platformdirs-3.8.0, pluggy-1.2.0, pooch-1.7.0, psutil-5.9.5, ptyprocess-0.7.0, py-1.11.0, py_expression_eval-0.3.14, pyasn1-0.5.0, pycparser-2.21, pycryptodome-3.18.0, pydevtool-0.3.0, Pygments-2.15.1, Pygments-2.15.1, pylev-1.4.0, PyNaCl-1.5.0, pyparsing-3.1.0, pyrsistent-0.19.3, pytest-7.4.0, pytest-xdist-3.3.1, python-dateutil-2.8.2, pytoml-0.1.21, pytz-2023.3, rapidfuzz-2.15.1, regex-2023.6.3, requests-2.31.0, requests-toolbelt-1.0.0, rich-13.4.2, rich-click-1.6.1, scandir-1.10.0, SecretStorage-3.3.3, semantic_version-2.10.0, shellingham-1.5.0.post1, simplegeneric-0.8.1, simplejson-3.19.1, six-1.16.0, snowballstemmer-2.2.0, sortedcontainers-2.4.0, Sphinx-7.0.1, sphinx-bootstrap-theme-0.8.1, sphinxcontrib-applehelp-1.0.4, sphinxcontrib-devhelp-1.0.2, sphinxcontrib-htmlhelp-2.0.1, sphinxcontrib-jsmath-1.0.1, sphinxcontrib-qthelp-1.0.3, sphinxcontrib-serializinghtml-1.1.5, sphinxcontrib-websupport-1.2.4, tabulate-0.9.0, threadpoolctl-3.1.0, toml-0.10.2, tomli-2.0.1, tomli_w-1.0.0, tomlkit-0.11.8, ujson-5.8.0, urllib3-1.26.16, wcwidth-0.2.6, webencodings-0.5.1, xlrd-2.0.1, zipfile36-0.1.3, zipp-3.15.0</p>"},{"location":"available_software/detail/Python/","title":"Python","text":"<p>Python is a programming language that lets you work more quickly and integrate your systems more effectively.</p> <p>https://python.org/</p>"},{"location":"available_software/detail/Python/#available-modules","title":"Available modules","text":"<p>The overview below shows which Python installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Python, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Python/3.11.5-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Python/3.11.5-GCCcore-13.2.0 x x x x x x x x x x x Python/3.11.3-GCCcore-12.3.0 x x x x x x x x x x x Python/3.10.8-GCCcore-12.2.0-bare x x x x x x x x x x x Python/3.10.8-GCCcore-12.2.0 x x x x x x x x x x x Python/2.7.18-GCCcore-12.2.0-bare x x x x x x x x x x x"},{"location":"available_software/detail/Python/#python3115-gcccore-1320","title":"Python/3.11.5-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>flit_core-3.9.0, packaging-23.2, pip-23.2.1, setuptools-68.2.2, setuptools-scm-8.0.4, tomli-2.0.1, typing_extensions-4.8.0, wheel-0.41.2</p>"},{"location":"available_software/detail/Python/#python3113-gcccore-1230","title":"Python/3.11.3-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>flit_core-3.9.0, packaging-23.1, pip-23.1.2, setuptools-67.7.2, setuptools_scm-7.1.0, tomli-2.0.1, typing_extensions-4.6.3, wheel-0.40.0</p>"},{"location":"available_software/detail/Python/#python3108-gcccore-1220","title":"Python/3.10.8-GCCcore-12.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>alabaster-0.7.12, appdirs-1.4.4, asn1crypto-1.5.1, atomicwrites-1.4.1, attrs-22.1.0, Babel-2.11.0, backports.entry-points-selectable-1.2.0, backports.functools_lru_cache-1.6.4, bcrypt-4.0.1, bitstring-3.1.9, blist-1.3.6, CacheControl-0.12.11, cachy-0.3.0, certifi-2022.9.24, cffi-1.15.1, chardet-5.0.0, charset-normalizer-2.1.1, cleo-1.0.0a5, click-8.1.3, clikit-0.6.2, cloudpickle-2.2.0, colorama-0.4.6, commonmark-0.9.1, crashtest-0.3.1, cryptography-38.0.3, Cython-0.29.32, decorator-5.1.1, distlib-0.3.6, docopt-0.6.2, docutils-0.19, doit-0.36.0, dulwich-0.20.50, ecdsa-0.18.0, editables-0.3, exceptiongroup-1.0.1, execnet-1.9.0, filelock-3.8.0, flit-3.8.0, flit_core-3.8.0, flit_scm-1.7.0, fsspec-2022.11.0, future-0.18.2, glob2-0.7, hatch_fancy_pypi_readme-22.8.0, hatch_vcs-0.2.0, hatchling-1.11.1, html5lib-1.1, idna-3.4, imagesize-1.4.1, importlib_metadata-5.0.0, importlib_resources-5.10.0, iniconfig-1.1.1, intervaltree-3.1.0, intreehooks-1.0, ipaddress-1.0.23, jaraco.classes-3.2.3, jeepney-0.8.0, Jinja2-3.1.2, joblib-1.2.0, jsonschema-4.17.0, keyring-23.11.0, keyrings.alt-4.2.0, liac-arff-2.5.0, lockfile-0.12.2, MarkupSafe-2.1.1, mock-4.0.3, more-itertools-9.0.0, msgpack-1.0.4, netaddr-0.8.0, netifaces-0.11.0, packaging-21.3, paramiko-2.12.0, pastel-0.2.1, pathlib2-2.3.7.post1, pathspec-0.10.1, pbr-5.11.0, pexpect-4.8.0, pip-22.3.1, pkginfo-1.8.3, platformdirs-2.5.3, pluggy-1.0.0, poetry-1.2.2, poetry-core-1.3.2, poetry_plugin_export-1.2.0, pooch-1.6.0, psutil-5.9.4, ptyprocess-0.7.0, py-1.11.0, py_expression_eval-0.3.14, pyasn1-0.4.8, pycparser-2.21, pycryptodome-3.17, pydevtool-0.3.0, Pygments-2.13.0, pylev-1.4.0, PyNaCl-1.5.0, pyparsing-3.0.9, pyrsistent-0.19.2, pytest-7.2.0, pytest-xdist-3.1.0, python-dateutil-2.8.2, pytoml-0.1.21, pytz-2022.6, regex-2022.10.31, requests-2.28.1, requests-toolbelt-0.9.1, rich-13.1.0, rich-click-1.6.0, scandir-1.10.0, SecretStorage-3.3.3, semantic_version-2.10.0, setuptools-63.4.3, setuptools-rust-1.5.2, setuptools_scm-7.0.5, shellingham-1.5.0, simplegeneric-0.8.1, simplejson-3.17.6, six-1.16.0, snowballstemmer-2.2.0, sortedcontainers-2.4.0, Sphinx-5.3.0, sphinx-bootstrap-theme-0.8.1, sphinxcontrib-applehelp-1.0.2, sphinxcontrib-devhelp-1.0.2, sphinxcontrib-htmlhelp-2.0.0, sphinxcontrib-jsmath-1.0.1, sphinxcontrib-qthelp-1.0.3, sphinxcontrib-serializinghtml-1.1.5, sphinxcontrib-websupport-1.2.4, tabulate-0.9.0, threadpoolctl-3.1.0, toml-0.10.2, tomli-2.0.1, tomli_w-1.0.0, tomlkit-0.11.6, typing_extensions-4.4.0, ujson-5.5.0, urllib3-1.26.12, virtualenv-20.16.6, wcwidth-0.2.5, webencodings-0.5.1, wheel-0.38.4, xlrd-2.0.1, zipfile36-0.1.3, zipp-3.10.0</p>"},{"location":"available_software/detail/Qhull/","title":"Qhull","text":"<p>Qhull computes the convex hull, Delaunay triangulation, Voronoi diagram, halfspace intersection about a point, furthest-site Delaunay triangulation, and furthest-site Voronoi diagram. The source code runs in 2-d, 3-d, 4-d, and higher dimensions. Qhull implements the Quickhull algorithm for computing the convex hull.</p> <p>http://www.qhull.org</p>"},{"location":"available_software/detail/Qhull/#available-modules","title":"Available modules","text":"<p>The overview below shows which Qhull installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Qhull, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Qhull/2020.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Qhull/2020.2-GCCcore-13.2.0 x x x x x x x x x x x Qhull/2020.2-GCCcore-12.3.0 x x x x x x x x x x x Qhull/2020.2-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Qt5/","title":"Qt5","text":"<p>Qt is a comprehensive cross-platform C++ application framework.</p> <p>https://qt.io/</p>"},{"location":"available_software/detail/Qt5/#available-modules","title":"Available modules","text":"<p>The overview below shows which Qt5 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Qt5, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Qt5/5.15.13-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Qt5/5.15.13-GCCcore-13.2.0 x x x x x x x x x x x Qt5/5.15.10-GCCcore-12.3.0 x x x x x x x x x x x Qt5/5.15.7-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/QuantumESPRESSO/","title":"QuantumESPRESSO","text":"<p>Quantum ESPRESSO  is an integrated suite of computer codesfor electronic-structure calculations and materials modeling at the nanoscale.It is based on density-functional theory, plane waves, and pseudopotentials(both norm-conserving and ultrasoft).</p> <p>https://www.quantum-espresso.org</p>"},{"location":"available_software/detail/QuantumESPRESSO/#available-modules","title":"Available modules","text":"<p>The overview below shows which QuantumESPRESSO installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using QuantumESPRESSO, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load QuantumESPRESSO/7.3.1-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 QuantumESPRESSO/7.3.1-foss-2023a x x x x x x x x x x x QuantumESPRESSO/7.2-foss-2022b x x x x x x x x x x x"},{"location":"available_software/detail/R-bundle-Bioconductor/","title":"R-bundle-Bioconductor","text":"<p>Bioconductor provides tools for the analysis and coprehension of high-throughput genomic data.</p> <p>https://bioconductor.org</p>"},{"location":"available_software/detail/R-bundle-Bioconductor/#available-modules","title":"Available modules","text":"<p>The overview below shows which R-bundle-Bioconductor installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using R-bundle-Bioconductor, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load R-bundle-Bioconductor/3.18-foss-2023a-R-4.3.2\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 R-bundle-Bioconductor/3.18-foss-2023a-R-4.3.2 x x x x x x x x x x x R-bundle-Bioconductor/3.16-foss-2022b-R-4.2.2 x x x x x x x x x x x"},{"location":"available_software/detail/R-bundle-Bioconductor/#r-bundle-bioconductor318-foss-2023a-r-432","title":"R-bundle-Bioconductor/3.18-foss-2023a-R-4.3.2","text":"<p>This is a list of extensions included in the module:</p> <p>affxparser-1.74.0, affy-1.80.0, affycoretools-1.74.0, affyio-1.72.0, AgiMicroRna-2.52.0, agricolae-1.3-7, ALDEx2-1.34.0, ALL-1.44.0, ANCOMBC-2.4.0, annaffy-1.74.0, annotate-1.80.0, AnnotationDbi-1.64.1, AnnotationFilter-1.26.0, AnnotationForge-1.44.0, AnnotationHub-3.10.0, anytime-0.3.9, aroma.affymetrix-3.2.1, aroma.apd-0.7.0, aroma.core-3.3.0, aroma.light-3.32.0, ash-1.0-15, ATACseqQC-1.26.0, AUCell-1.24.0, aws.s3-0.3.21, aws.signature-0.6.0, babelgene-22.9, ballgown-2.34.0, basilisk-1.14.2, basilisk.utils-1.14.1, batchelor-1.18.1, baySeq-2.36.0, beachmat-2.18.0, BH-1.84.0-0, Biobase-2.62.0, BiocBaseUtils-1.4.0, BiocFileCache-2.10.1, BiocGenerics-0.48.0, BiocIO-1.12.0, BiocManager-1.30.22, BiocNeighbors-1.20.2, BiocParallel-1.36.0, BiocSingular-1.18.0, BiocStyle-2.30.0, BiocVersion-3.18.1, biomaRt-2.58.0, biomformat-1.30.0, Biostrings-2.70.0, biovizBase-1.50.0, blme-1.0-5, bluster-1.12.0, bookdown-0.37, BSgenome-1.70.1, BSgenome.Cfamiliaris.UCSC.canFam3-1.4.0, BSgenome.Hsapiens.UCSC.hg19-1.4.3, BSgenome.Hsapiens.UCSC.hg38-1.4.5, BSgenome.Mmusculus.UCSC.mm10-1.4.3, bsseq-1.38.0, bumphunter-1.44.0, ca-0.71.1, CAGEfightR-1.22.0, CAGEr-2.8.0, CAMERA-1.58.0, Category-2.68.0, ccdata-1.28.0, ccmap-1.28.0, CGHbase-1.62.0, CGHcall-2.64.0, ChIPpeakAnno-3.36.0, ChIPseeker-1.38.0, chromVAR-1.24.0, clusterProfiler-4.10.0, CNEr-1.38.0, coloc-5.2.3, colorRamps-2.3.1, ComplexHeatmap-2.18.0, ConsensusClusterPlus-1.66.0, conumee-1.36.0, crossmeta-1.28.0, cummeRbund-2.44.0, cytolib-2.14.1, CytoML-2.14.0, dada2-1.30.0, ddPCRclust-1.22.0, DECIPHER-2.30.0, DeconRNASeq-1.44.0, decontam-1.22.0, decoupleR-2.8.0, DEGseq-1.56.1, DelayedArray-0.28.0, DelayedMatrixStats-1.24.0, densEstBayes-1.0-2.2, derfinder-1.36.0, derfinderHelper-1.36.0, DESeq2-1.42.0, diffcyt-1.22.0, dir.expiry-1.10.0, directlabels-2024.1.21, DirichletMultinomial-1.44.0, DNABarcodes-1.32.0, DNAcopy-1.76.0, DO.db-2.9, docopt-0.7.1, DOSE-3.28.2, dqrng-0.3.2, DRIMSeq-1.30.0, DropletUtils-1.22.0, DSS-2.50.1, dupRadar-1.32.0, DynDoc-1.80.0, EBImage-4.44.0, edgeR-4.0.12, egg-0.4.5, emmeans-1.10.0, enrichplot-1.22.0, EnsDb.Hsapiens.v75-2.99.0, EnsDb.Hsapiens.v79-2.99.0, EnsDb.Hsapiens.v86-2.99.0, ensembldb-2.26.0, escape-1.12.0, estimability-1.4.1, ExperimentHub-2.10.0, extraDistr-1.10.0, factoextra-1.0.7, fANCOVA-0.6-1, fda-6.1.4, FDb.InfiniumMethylation.hg19-2.2.0, fds-1.8, feature-1.2.15, fgsea-1.28.0, filelock-1.0.3, flowAI-1.32.0, flowClean-1.40.0, flowClust-3.40.0, flowCore-2.14.0, flowDensity-1.36.1, flowFP-1.60.0, flowMerge-2.50.0, flowPeaks-1.48.0, FlowSOM-2.10.0, FlowSorted.Blood.EPIC-2.6.0, FlowSorted.CordBloodCombined.450k-1.18.0, flowStats-4.14.1, flowViz-1.66.0, flowWorkspace-4.14.2, FRASER-1.14.0, fresh-0.2.0, gcrma-2.74.0, gdsfmt-1.38.0, genefilter-1.84.0, geneLenDataBase-1.38.0, geneplotter-1.80.0, GENESIS-2.32.0, GENIE3-1.24.0, genomation-1.34.0, GenomeInfoDb-1.38.5, GenomeInfoDbData-1.2.11, GenomicAlignments-1.38.2, GenomicFeatures-1.54.1, GenomicFiles-1.38.0, GenomicInteractions-1.36.0, GenomicRanges-1.54.1, GenomicScores-2.14.3, GEOmap-2.5-5, GEOquery-2.70.0, ggbio-1.50.0, ggcyto-1.30.0, ggdendro-0.1.23, ggnewscale-0.4.9, ggpointdensity-0.1.0, ggrastr-1.0.2, ggseqlogo-0.1, ggthemes-5.0.0, ggtree-3.10.0, GLAD-2.66.0, Glimma-2.12.0, GlobalAncova-4.20.0, globaltest-5.56.0, GO.db-3.18.0, GOSemSim-2.28.1, goseq-1.54.0, GOstats-2.68.0, graph-1.80.0, graphite-1.48.0, GSEABase-1.64.0, gsmoothr-0.1.7, gson-0.1.0, GSVA-1.50.0, Gviz-1.46.1, GWASExactHW-1.01, GWASTools-1.48.0, HDF5Array-1.30.0, HDO.db-0.99.1, hdrcde-3.4, heatmaply-1.5.0, hgu133plus2.db-3.13.0, HiCBricks-1.20.0, HiCcompare-1.24.0, HMMcopy-1.44.0, Homo.sapiens-1.3.1, IHW-1.30.0, IlluminaHumanMethylation450kanno.ilmn12.hg19-0.6.1, IlluminaHumanMethylation450kmanifest-0.4.0, IlluminaHumanMethylationEPICanno.ilm10b2.hg19-0.6.0, IlluminaHumanMethylationEPICanno.ilm10b4.hg19-0.6.0, IlluminaHumanMethylationEPICmanifest-0.3.0, illuminaio-0.44.0, impute-1.76.0, InteractionSet-1.30.0, interactiveDisplayBase-1.40.0, intervals-0.15.4, IRanges-2.36.0, isva-1.9, JASPAR2020-0.99.10, KEGGgraph-1.62.0, KEGGREST-1.42.0, LEA-3.14.0, limma-3.58.1, log4r-0.4.3, lpsymphony-1.30.0, lsa-0.73.3, lumi-2.54.0, M3Drop-1.28.0, marray-1.80.0, maSigPro-1.74.0, MassSpecWavelet-1.68.0, MatrixGenerics-1.14.0, MBA-0.1-0, MEDIPS-1.54.0, MetaboCoreUtils-1.10.0, metagenomeSeq-1.43.0, metaMA-3.1.3, metap-1.9, metapod-1.10.1, MethylSeekR-1.42.0, methylumi-2.48.0, Mfuzz-2.62.0, mia-1.10.0, minfi-1.48.0, missMethyl-1.36.0, mixOmics-6.26.0, mixsqp-0.3-54, MLInterfaces-1.82.0, MotifDb-1.44.0, motifmatchr-1.24.0, motifStack-1.46.0, MsCoreUtils-1.14.1, MsExperiment-1.4.0, MsFeatures-1.10.0, msigdbr-7.5.1, MSnbase-2.28.1, MSstats-4.10.0, MSstatsConvert-1.12.0, MSstatsLiP-1.8.1, MSstatsPTM-2.4.2, MSstatsTMT-2.10.0, MultiAssayExperiment-1.28.0, MultiDataSet-1.30.0, multtest-2.58.0, muscat-1.16.0, mutoss-0.1-13, mzID-1.40.0, mzR-2.36.0, NADA-1.6-1.1, ncdfFlow-2.48.0, NMF-0.26, NOISeq-2.46.0, numbat-1.3.2-1, oligo-1.66.0, oligoClasses-1.64.0, ontologyIndex-2.11, oompaBase-3.2.9, oompaData-3.1.3, openCyto-2.14.0, org.Hs.eg.db-3.18.0, org.Mm.eg.db-3.18.0, org.Rn.eg.db-3.18.0, OrganismDbi-1.44.0, OUTRIDER-1.20.0, pathview-1.42.0, pcaMethods-1.94.0, perm-1.0-0.4, PFAM.db-3.18.0, phyloseq-1.46.0, plyranges-1.22.0, pmp-1.14.0, polyester-1.38.0, poweRlaw-0.70.6, preprocessCore-1.64.0, pRoloc-1.42.0, pRolocdata-1.40.0, pRolocGUI-2.12.0, ProtGenerics-1.34.0, PRROC-1.3.1, PSCBS-0.66.0, PureCN-2.8.1, qap-0.1-2, QDNAseq-1.38.0, QFeatures-1.12.0, qlcMatrix-0.9.7, qqconf-1.3.2, quantsmooth-1.68.0, qvalue-2.34.0, R.devices-2.17.1, R.filesets-2.15.0, R.huge-0.10.1, rainbow-3.8, randomcoloR-1.1.0.1, rARPACK-0.11-0, RBGL-1.78.0, RcisTarget-1.22.0, RcppAnnoy-0.0.22, RcppHNSW-0.5.0, RcppML-0.3.7, RcppZiggurat-0.1.6, reactome.db-1.86.2, ReactomePA-1.46.0, regioneR-1.34.0, reldist-1.7-2, remaCor-0.0.16, Repitools-1.48.0, ReportingTools-2.42.3, ResidualMatrix-1.12.0, restfulr-0.0.15, Rfast-2.1.0, RFOC-3.4-10, rGADEM-2.50.0, Rgraphviz-2.46.0, rhdf5-2.46.1, rhdf5filters-1.14.1, Rhdf5lib-1.24.1, Rhtslib-2.4.1, Ringo-1.66.0, RNASeqPower-1.42.0, RnBeads-2.20.0, RnBeads.hg19-1.34.0, RnBeads.hg38-1.34.0, RnBeads.mm10-2.10.0, RnBeads.mm9-1.34.0, RnBeads.rn5-1.34.0, ROC-1.78.0, rols-2.30.0, ROntoTools-2.30.0, ropls-1.34.0, RPMG-2.2-7, RProtoBufLib-2.14.0, Rsamtools-2.18.0, RSEIS-4.1-6, Rsubread-2.16.1, rsvd-1.0.5, rtracklayer-1.62.0, Rwave-2.6-5, S4Arrays-1.2.0, S4Vectors-0.40.2, samr-3.0, SamSPECTRAL-1.56.0, SC3-1.30.0, ScaledMatrix-1.10.0, SCANVIS-1.16.0, scater-1.30.1, scattermore-1.2, scDblFinder-1.16.0, scistreer-1.2.0, scran-1.30.2, scrime-1.3.5, scuttle-1.12.0, SeqArray-1.42.0, seqLogo-1.68.0, seqPattern-1.34.0, SeqVarTools-1.40.0, seriation-1.5.4, Seurat-5.0.1, SeuratObject-5.0.1, shinyBS-0.61.1, shinydashboardPlus-2.0.3, shinyFiles-0.9.3, shinyhelper-0.3.2, shinypanel-0.1.5, shinyWidgets-0.8.1, ShortRead-1.60.0, siggenes-1.76.0, Signac-1.12.0, SimBu-1.4.3, simplifyEnrichment-1.12.0, SingleCellExperiment-1.24.0, SingleR-2.4.1, sitmo-2.0.2, slingshot-2.10.0, SMVar-1.3.4, SNPRelate-1.36.0, snpStats-1.52.0, SparseArray-1.2.3, sparseMatrixStats-1.14.0, sparsesvd-0.2-2, SpatialExperiment-1.12.0, Spectra-1.12.0, SPIA-2.54.0, splancs-2.01-44, SPOTlight-1.6.7, stageR-1.24.0, struct-1.14.0, structToolbox-1.14.0, SummarizedExperiment-1.32.0, susieR-0.12.35, sva-3.50.0, TailRank-3.2.2, TFBSTools-1.40.0, TFMPvalue-0.0.9, tkWidgets-1.80.0, TrajectoryUtils-1.10.0, treeio-1.26.0, TreeSummarizedExperiment-2.10.0, TSP-1.2-4, TxDb.Hsapiens.UCSC.hg19.knownGene-3.2.2, TxDb.Mmusculus.UCSC.mm10.knownGene-3.10.0, tximport-1.30.0, UCell-2.6.2, uwot-0.1.16, variancePartition-1.32.2, VariantAnnotation-1.48.1, venn-1.12, vsn-3.70.0, waiter-0.2.5, wateRmelon-2.8.0, WGCNA-1.72-5, widgetTools-1.80.0, Wrench-1.20.0, xcms-4.0.2, XVector-0.42.0, zCompositions-1.5.0-1, zellkonverter-1.12.1, zlibbioc-1.48.0</p>"},{"location":"available_software/detail/R-bundle-Bioconductor/#r-bundle-bioconductor316-foss-2022b-r-422","title":"R-bundle-Bioconductor/3.16-foss-2022b-R-4.2.2","text":"<p>This is a list of extensions included in the module:</p> <p>affxparser-1.70.0, affy-1.76.0, affycoretools-1.70.0, affyio-1.68.0, AgiMicroRna-2.48.0, agricolae-1.3-5, ALDEx2-1.30.0, ALL-1.40.0, ANCOMBC-2.0.2, annaffy-1.70.0, annotate-1.76.0, AnnotationDbi-1.60.2, AnnotationFilter-1.22.0, AnnotationForge-1.40.1, AnnotationHub-3.6.0, anytime-0.3.9, aroma.affymetrix-3.2.1, aroma.apd-0.6.1, aroma.core-3.3.0, aroma.light-3.28.0, ash-1.0-15, ATACseqQC-1.22.0, AUCell-1.20.2, aws.s3-0.3.21, aws.signature-0.6.0, babelgene-22.9, ballgown-2.30.0, basilisk-1.10.2, basilisk.utils-1.10.0, batchelor-1.14.1, baySeq-2.31.0, beachmat-2.14.0, Biobase-2.58.0, BiocBaseUtils-1.0.0, BiocFileCache-2.6.1, BiocGenerics-0.44.0, BiocIO-1.8.0, BiocManager-1.30.20, BiocNeighbors-1.16.0, BiocParallel-1.32.5, BiocSingular-1.14.0, BiocStyle-2.26.0, BiocVersion-3.16.0, biomaRt-2.54.0, biomformat-1.26.0, Biostrings-2.66.0, biovizBase-1.46.0, blme-1.0-5, bluster-1.8.0, bookdown-0.33, BSgenome-1.66.3, BSgenome.Cfamiliaris.UCSC.canFam3-1.4.0, BSgenome.Hsapiens.UCSC.hg19-1.4.3, BSgenome.Hsapiens.UCSC.hg38-1.4.5, BSgenome.Mmusculus.UCSC.mm10-1.4.3, bsseq-1.34.0, bumphunter-1.40.0, ca-0.71.1, CAGEr-2.4.0, CAMERA-1.54.0, Category-2.64.0, ccdata-1.24.0, ccmap-1.24.0, CGHbase-1.58.0, CGHcall-2.60.0, ChIPpeakAnno-3.32.0, chromVAR-1.20.2, clusterProfiler-4.6.2, CNEr-1.34.0, coloc-5.1.0.1, colorRamps-2.3.1, ComplexHeatmap-2.14.0, ConsensusClusterPlus-1.62.0, conumee-1.32.0, crossmeta-1.24.0, cummeRbund-2.40.0, cytolib-2.10.1, CytoML-2.10.0, dada2-1.26.0, ddPCRclust-1.18.0, DECIPHER-2.26.0, DeconRNASeq-1.40.0, decontam-1.18.0, decoupleR-2.4.0, DEGseq-1.52.0, DelayedArray-0.24.0, DelayedMatrixStats-1.20.0, densEstBayes-1.0-2.1, derfinder-1.32.0, derfinderHelper-1.32.0, DESeq2-1.38.3, diffcyt-1.18.0, dir.expiry-1.6.0, DirichletMultinomial-1.40.0, DNABarcodes-1.28.0, DNAcopy-1.72.3, DO.db-2.9, docopt-0.7.1, DOSE-3.24.2, dqrng-0.3.0, DRIMSeq-1.26.0, DropletUtils-1.18.1, DSS-2.46.0, dupRadar-1.28.0, DynDoc-1.76.0, EBImage-4.40.0, edgeR-3.40.2, egg-0.4.5, emmeans-1.8.5, enrichplot-1.18.3, EnsDb.Hsapiens.v75-2.99.0, EnsDb.Hsapiens.v79-2.99.0, EnsDb.Hsapiens.v86-2.99.0, ensembldb-2.22.0, escape-1.8.0, estimability-1.4.1, ExperimentHub-2.6.0, extraDistr-1.9.1, factoextra-1.0.7, fda-6.0.5, FDb.InfiniumMethylation.hg19-2.2.0, fds-1.8, feature-1.2.15, fgsea-1.24.0, filelock-1.0.2, flowAI-1.28.0, flowClean-1.36.0, flowClust-3.36.0, flowCore-2.10.0, flowDensity-1.32.0, flowFP-1.56.3, flowMerge-2.46.0, flowPeaks-1.44.0, FlowSOM-2.6.0, FlowSorted.Blood.EPIC-2.2.0, FlowSorted.CordBloodCombined.450k-1.14.0, flowStats-4.10.0, flowViz-1.62.0, flowWorkspace-4.10.1, FRASER-1.10.2, fresh-0.2.0, gcrma-2.70.0, gdsfmt-1.34.0, genefilter-1.80.3, geneLenDataBase-1.34.0, geneplotter-1.76.0, GENESIS-2.28.0, GENIE3-1.20.0, GenomeInfoDb-1.34.9, GenomeInfoDbData-1.2.9, GenomicAlignments-1.34.1, GenomicFeatures-1.50.4, GenomicFiles-1.34.0, GenomicRanges-1.50.2, GenomicScores-2.10.0, GEOmap-2.5-0, GEOquery-2.66.0, ggbio-1.46.0, ggcyto-1.26.4, ggdendro-0.1.23, ggnewscale-0.4.8, ggpointdensity-0.1.0, ggrastr-1.0.1, ggseqlogo-0.1, ggthemes-4.2.4, ggtree-3.6.2, GLAD-2.62.0, Glimma-2.8.0, GlobalAncova-4.16.0, globaltest-5.52.0, GO.db-3.16.0, GOSemSim-2.24.0, goseq-1.50.0, GOstats-2.64.0, graph-1.76.0, graphite-1.44.0, GSEABase-1.60.0, gsmoothr-0.1.7, gson-0.1.0, GSVA-1.46.0, Gviz-1.42.1, GWASExactHW-1.01, GWASTools-1.44.0, HDF5Array-1.26.0, HDO.db-0.99.1, hdrcde-3.4, heatmaply-1.4.2, hgu133plus2.db-3.13.0, HiCBricks-1.16.0, HiCcompare-1.20.0, HMMcopy-1.40.0, Homo.sapiens-1.3.1, IHW-1.26.0, IlluminaHumanMethylation450kanno.ilmn12.hg19-0.6.1, IlluminaHumanMethylation450kmanifest-0.4.0, IlluminaHumanMethylationEPICanno.ilm10b2.hg19-0.6.0, IlluminaHumanMethylationEPICanno.ilm10b4.hg19-0.6.0, IlluminaHumanMethylationEPICmanifest-0.3.0, illuminaio-0.40.0, impute-1.72.3, InteractionSet-1.26.1, interactiveDisplayBase-1.36.0, intervals-0.15.4, IRanges-2.32.0, isva-1.9, JASPAR2020-0.99.10, KEGGgraph-1.58.3, KEGGREST-1.38.0, LEA-3.10.2, limma-3.54.2, log4r-0.4.3, lpsymphony-1.26.3, lsa-0.73.3, lumi-2.50.0, M3Drop-1.24.0, marray-1.76.0, maSigPro-1.70.0, MassSpecWavelet-1.64.1, MatrixGenerics-1.10.0, MBA-0.1-0, MEDIPS-1.50.0, metagenomeSeq-1.40.0, metaMA-3.1.3, metap-1.8, metapod-1.6.0, MethylSeekR-1.38.0, methylumi-2.44.0, Mfuzz-2.58.0, mia-1.6.0, minfi-1.44.0, missMethyl-1.32.0, mixOmics-6.22.0, mixsqp-0.3-48, MLInterfaces-1.78.0, MotifDb-1.40.0, motifmatchr-1.20.0, motifStack-1.42.0, MsCoreUtils-1.10.0, MsFeatures-1.6.0, msigdbr-7.5.1, MSnbase-2.24.2, MSstats-4.6.5, MSstatsConvert-1.8.3, MSstatsLiP-1.4.1, MSstatsPTM-2.0.3, MSstatsTMT-2.6.1, MultiAssayExperiment-1.24.0, MultiDataSet-1.26.0, multtest-2.54.0, muscat-1.12.1, mutoss-0.1-13, mzID-1.36.0, mzR-2.32.0, NADA-1.6-1.1, ncdfFlow-2.44.0, NMF-0.25, NOISeq-2.42.0, numbat-1.2.2, oligo-1.62.2, oligoClasses-1.60.0, ontologyIndex-2.10, oompaBase-3.2.9, oompaData-3.1.3, openCyto-2.10.1, org.Hs.eg.db-3.16.0, org.Mm.eg.db-3.16.0, org.Rn.eg.db-3.16.0, OrganismDbi-1.40.0, OUTRIDER-1.16.3, pathview-1.38.0, pcaMethods-1.90.0, perm-1.0-0.2, PFAM.db-3.16.0, phyloseq-1.42.0, pmp-1.10.0, polyester-1.34.0, poweRlaw-0.70.6, preprocessCore-1.60.2, pRoloc-1.38.2, pRolocdata-1.36.0, pRolocGUI-2.8.0, ProtGenerics-1.30.0, PRROC-1.3.1, PSCBS-0.66.0, PureCN-2.4.0, qap-0.1-2, QDNAseq-1.34.0, qlcMatrix-0.9.7, qqconf-1.3.1, quantsmooth-1.64.0, qvalue-2.30.0, R.devices-2.17.1, R.filesets-2.15.0, R.huge-0.9.0, rainbow-3.7, randomcoloR-1.1.0.1, rARPACK-0.11-0, RBGL-1.74.0, RcisTarget-1.18.2, RcppAnnoy-0.0.20, RcppHNSW-0.4.1, RcppML-0.3.7, RcppZiggurat-0.1.6, reactome.db-1.82.0, ReactomePA-1.42.0, regioneR-1.30.0, reldist-1.7-2, remaCor-0.0.11, Repitools-1.44.0, ReportingTools-2.38.0, ResidualMatrix-1.8.0, restfulr-0.0.15, Rfast-2.0.7, RFOC-3.4-6, rGADEM-2.46.0, Rgraphviz-2.42.0, rhdf5-2.42.0, rhdf5filters-1.10.0, Rhdf5lib-1.20.0, Rhtslib-2.0.0, Ringo-1.62.0, RNASeqPower-1.38.0, RnBeads-2.16.0, RnBeads.hg19-1.30.0, RnBeads.hg38-1.30.0, RnBeads.mm10-2.6.0, RnBeads.mm9-1.30.0, RnBeads.rn5-1.30.0, ROC-1.74.0, rols-2.26.0, ROntoTools-2.26.0, ropls-1.30.0, RPMG-2.2-3, RProtoBufLib-2.10.0, Rsamtools-2.14.0, RSEIS-4.1-4, Rsubread-2.12.3, rsvd-1.0.5, rtracklayer-1.58.0, Rwave-2.6-5, S4Vectors-0.36.2, samr-3.0, SamSPECTRAL-1.52.0, SC3-1.26.2, ScaledMatrix-1.6.0, SCANVIS-1.12.0, scater-1.26.1, scattermore-0.8, scDblFinder-1.12.0, scistreer-1.1.0, scran-1.26.2, scrime-1.3.5, scuttle-1.8.4, SeqArray-1.38.0, seqLogo-1.64.0, SeqVarTools-1.36.0, seriation-1.4.2, Seurat-4.3.0, SeuratObject-4.1.3, shinyBS-0.61.1, shinydashboardPlus-2.0.3, shinyFiles-0.9.3, shinyhelper-0.3.2, shinypanel-0.1.5, shinyWidgets-0.7.6, ShortRead-1.56.1, siggenes-1.72.0, Signac-1.9.0, simplifyEnrichment-1.8.0, SingleCellExperiment-1.20.0, SingleR-2.0.0, sitmo-2.0.2, slingshot-2.6.0, SMVar-1.3.4, SNPRelate-1.32.2, snpStats-1.48.0, sparseMatrixStats-1.10.0, sparsesvd-0.2-2, SpatialExperiment-1.8.1, SPIA-2.50.0, splancs-2.01-43, SPOTlight-1.2.0, stageR-1.20.0, struct-1.10.0, structToolbox-1.10.1, SummarizedExperiment-1.28.0, susieR-0.12.35, sva-3.46.0, TailRank-3.2.2, TFBSTools-1.36.0, TFMPvalue-0.0.9, tkWidgets-1.76.0, TrajectoryUtils-1.6.0, treeio-1.22.0, TreeSummarizedExperiment-2.6.0, TSP-1.2-3, TxDb.Hsapiens.UCSC.hg19.knownGene-3.2.2, TxDb.Mmusculus.UCSC.mm10.knownGene-3.10.0, tximport-1.26.1, UCell-2.2.0, uwot-0.1.14, variancePartition-1.28.7, VariantAnnotation-1.44.1, venn-1.11, vsn-3.66.0, waiter-0.2.5, wateRmelon-2.4.0, WGCNA-1.72-1, widgetTools-1.76.0, Wrench-1.16.0, xcms-3.20.0, XVector-0.38.0, zCompositions-1.4.0-1, zellkonverter-1.8.0, zlibbioc-1.44.0</p>"},{"location":"available_software/detail/R-bundle-CRAN/","title":"R-bundle-CRAN","text":"<p>Bundle of R packages from CRAN</p> <p>https://www.r-project.org/</p>"},{"location":"available_software/detail/R-bundle-CRAN/#available-modules","title":"Available modules","text":"<p>The overview below shows which R-bundle-CRAN installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using R-bundle-CRAN, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load R-bundle-CRAN/2024.06-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 R-bundle-CRAN/2024.06-foss-2023b x x x x x x x x x x x R-bundle-CRAN/2023.12-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/R-bundle-CRAN/#r-bundle-cran202406-foss-2023b","title":"R-bundle-CRAN/2024.06-foss-2023b","text":"<p>This is a list of extensions included in the module:</p> <p>abc-2.2.1, abc.data-1.1, abe-3.0.1, abind-1.4-5, acepack-1.4.2, adabag-5.0, ade4-1.7-22, ADGofTest-0.3, admisc-0.35, aggregation-1.0.1, AICcmodavg-2.3-3, akima-0.6-3.4, alabama-2023.1.0, AlgDesign-1.2.1, alluvial-0.1-2, AMAPVox-2.2.1, animation-2.7, aod-1.3.3, apcluster-1.4.13, ape-5.8, aplot-0.2.3, argparse-2.2.3, aricode-1.0.3, arm-1.14-4, arrayhelpers-1.1-0, asnipe-1.1.17, assertive-0.3-6, assertive.base-0.0-9, assertive.code-0.0-4, assertive.data-0.0-3, assertive.data.uk-0.0-2, assertive.data.us-0.0-2, assertive.datetimes-0.0-3, assertive.files-0.0-2, assertive.matrices-0.0-2, assertive.models-0.0-2, assertive.numbers-0.0-2, assertive.properties-0.0-5, assertive.reflection-0.0-5, assertive.sets-0.0-3, assertive.strings-0.0-3, assertive.types-0.0-3, assertthat-0.2.1, AUC-0.3.2, audio-0.1-11, aws-2.5-5, awsMethods-1.1-1, backports-1.5.0, bacr-1.0.1, bartMachine-1.3.4.1, bartMachineJARs-1.2.1, base64-2.0.1, BatchJobs-1.9, batchmeans-1.0-4, BayesianTools-0.1.8, BayesLogit-2.1, bayesm-3.1-6, BayesPen-1.0, bayesplot-1.11.1, bayestestR-0.14.0, BB-2019.10-1, BBmisc-1.13, bbmle-1.0.25.1, BCEE-1.3.2, BDgraph-2.72, bdsmatrix-1.3-7, beanplot-1.3.1, beeswarm-0.4.0, berryFunctions-1.22.5, betareg-3.1-4, BH-1.84.0-0, BiasedUrn-2.0.12, bibtex-0.5.1, BIEN-1.2.6, bigD-0.2.0, BIGL-1.9.1, bigmemory-4.6.4, bigmemory.sri-0.1.8, bindr-0.1.1, bindrcpp-0.2.3, bio3d-2.4-4, biom-0.3.12, biomod2-4.2-5-2, bit-4.0.5, bit64-4.0.5, bitops-1.0-7, blavaan-0.5-5, blob-1.2.4, BMA-3.18.17, bmp-0.3, bnlearn-4.9.4, bold-1.3.0, boot-1.3-30, bootstrap-2019.6, Boruta-8.0.0, brglm-0.7.2, bridgedist-0.1.2, bridgesampling-1.1-2, brms-2.21.0, Brobdingnag-1.2-9, broom-1.0.6, broom.helpers-1.15.0, broom.mixed-0.2.9.5, bst-0.3-24, Cairo-1.6-2, calibrate-1.7.7, car-3.1-2, carData-3.0-5, caret-6.0-94, catlearn-1.0, caTools-1.18.2, CBPS-0.23, celestial-1.4.6, cellranger-1.1.0, cgdsr-1.3.0, cghFLasso-0.2-1, changepoint-2.2.4, checkmate-2.3.1, chemometrics-1.4.4, chk-0.9.1, chkptstanr-0.1.1, chron-2.3-61, circlize-0.4.16, circular-0.5-0, class-7.3-22, classInt-0.4-10, cld2-1.2.4, clisymbols-1.2.0, clock-0.7.0, clue-0.3-65, cluster-2.1.6, clusterGeneration-1.3.8, clusterRepro-0.9, clustree-0.5.1, clValid-0.7, cmna-1.0.5, cmprsk-2.2-12, cNORM-3.0.4, cobalt-4.5.5, cobs-1.3-8, coda-0.19-4.1, codetools-0.2-20, coin-1.4-3, collapse-2.0.14, colorspace-2.1-0, colourpicker-1.3.0, combinat-0.0-8, ComICS-1.0.4, ComplexUpset-1.3.3, compositions-2.0-8, CompQuadForm-1.4.3, conditionz-0.1.0, conflicted-1.2.0, conquer-1.3.3, ConsRank-2.1.4, contfrac-1.1-12, copCAR-2.0-4, copula-1.1-3, corpcor-1.6.10, corrplot-0.92, covr-3.6.4, CovSel-1.2.1, covsim-1.1.0, cowplot-1.1.3, coxed-0.3.3, coxme-2.2-20, crfsuite-0.4.2, crosstalk-1.2.1, crul-1.4.2, cSEM-0.5.0, csSAM-1.2.4, ctmle-0.1.2, cubature-2.1.0, cubelyr-1.0.2, cvAUC-1.1.4, CVST-0.2-3, CVXR-1.0-13, d3Network-0.5.2.1, dagitty-0.3-4, data.table-1.15.4, data.tree-1.1.0, DataCombine-0.2.21, datawizard-0.12.2, date-1.2-42, dbarts-0.9-28, DBI-1.2.3, dbplyr-2.5.0, dbscan-1.1-12, dcurver-0.9.2, ddalpha-1.3.15, deal-1.2-42, debugme-1.2.0, deldir-2.0-4, dendextend-1.17.1, DEoptim-2.2-8, DEoptimR-1.1-3, DepthProc-2.1.5, Deriv-4.1.3, DescTools-0.99.54, deSolve-1.40, dfidx-0.0-5, DHARMa-0.4.6, dHSIC-2.1, diagram-1.6.5, DiagrammeR-1.0.11, DiceKriging-1.6.0, dichromat-2.0-0.1, dimRed-0.2.6, diptest-0.77-1, DiscriMiner-0.1-29, dismo-1.3-14, distillery-1.2-1, distr-2.9.3, distrEx-2.9.2, distributional-0.4.0, DistributionUtils-0.6-1, diveRsity-1.9.90, dlm-1.1-6, DMCfun-3.5.4, doc2vec-0.2.0, docstring-1.0.0, doMC-1.3.8, doParallel-1.0.17, doRNG-1.8.6, doSNOW-1.0.20, dotCall64-1.1-1, downloader-0.4, dplyr-1.1.4, dr-3.0.10, dreamerr-1.4.0, drgee-1.1.10, DRR-0.0.4, drugCombo-1.2.1, DT-0.33, dtangle-2.0.9, dtplyr-1.3.1, DTRreg-2.2, dtw-1.23-1, dummies-1.5.6, dygraphs-1.1.1.6, dynamicTreeCut-1.63-1, e1071-1.7-14, earth-5.3.3, EasyABC-1.5.2, ECOSolveR-0.5.5, ellipse-0.5.0, elliptic-1.4-0, emdbook-1.3.13, emmeans-1.10.2, emoa-0.5-2, emulator-1.2-24, energy-1.7-11, ENMeval-2.0.4, entropy-1.3.1, EnvStats-2.8.1, epitools-0.5-10.1, ergm-4.6.0, ergm.count-4.1.2, ergm.multi-0.2.1, estimability-1.5.1, EValue-4.1.3, evd-2.3-7, Exact-3.2, expm-0.999-9, ExPosition-2.8.23, expsmooth-2.3, extrafont-0.19, extrafontdb-1.0, extRemes-2.1-4, FactoMineR-2.11, FactorCopula-0.9.3, fail-1.3, farver-2.1.2, fastcluster-1.2.6, fastDummies-1.7.3, fasterize-1.0.5, fastICA-1.2-4, fastmatch-1.1-4, fdrtool-1.2.17, feather-0.3.5, ff-4.0.12, fftw-1.0-8, fftwtools-0.9-11, fields-15.2, filehash-2.4-5, finalfit-1.0.7, findpython-1.0.8, fishMod-0.29, fitdistrplus-1.1-11, fixest-0.12.1, FKSUM-1.0.1, flashClust-1.01-2, flexclust-1.4-2, flexmix-2.3-19, flextable-0.9.6, fma-2.5, FME-1.3.6.3, fmri-1.9.12, FNN-1.1.4, fontBitstreamVera-0.1.1, fontLiberation-0.1.0, fontquiver-0.2.1, forcats-1.0.0, foreach-1.5.2, forecast-8.23.0, foreign-0.8-86, formatR-1.14, Formula-1.2-5, formula.tools-1.7.1, fossil-0.4.0, fpc-2.2-12, fpp-0.5, fracdiff-1.5-3, furrr-0.3.1, futile.logger-1.4.3, futile.options-1.0.1, future-1.33.2, future.apply-1.11.2, gam-1.22-3, gamlss-5.4-22, gamlss.data-6.0-6, gamlss.dist-6.1-1, gamlss.tr-5.1-9, gamm4-0.2-6, gap-1.5-3, gap.datasets-0.0.6, gapfill-0.9.6-1, gargle-1.5.2, gaussquad-1.0-3, gbm-2.1.9, gbRd-0.4.12, gclus-1.3.2, gdalUtils-2.0.3.2, gdata-3.0.0, gdistance-1.6.4, gdtools-0.3.7, gee-4.13-27, geeM-0.10.1, geepack-1.3.11, geex-1.1.1, geiger-2.0.11, GeneNet-1.2.16, generics-0.1.3, genoPlotR-0.8.11, GenSA-1.1.14, geojsonsf-2.0.3, geometries-0.2.4, geometry-0.4.7, getopt-1.20.4, GetoptLong-1.0.5, gfonts-0.2.0, GGally-2.2.1, ggbeeswarm-0.7.2, ggdag-0.2.12, ggdist-3.3.2, ggExtra-0.10.1, ggfan-0.1.3, ggforce-0.4.2, ggformula-0.12.0, ggfun-0.1.5, ggh4x-0.2.8, ggnetwork-0.5.13, ggplot2-3.5.1, ggplotify-0.1.2, ggpubr-0.6.0, ggraph-2.2.1, ggrepel-0.9.5, ggridges-0.5.6, ggsci-3.2.0, ggsignif-0.6.4, ggstance-0.3.7, ggstats-0.6.0, ggvenn-0.1.10, ggvis-0.4.9, GillespieSSA-0.6.2, git2r-0.33.0, GJRM-0.2-6.5, glasso-1.11, gld-2.6.6, gllvm-1.4.3, glmmML-1.1.6, glmmTMB-1.1.9, glmnet-4.1-8, GlobalOptions-0.1.2, globals-0.16.3, gmm-1.8, gmodels-2.19.1, gmp-0.7-4, gnumeric-0.7-10, goftest-1.2-3, gomms-1.0, googledrive-2.1.1, googlesheets4-1.1.1, gower-1.0.1, GPArotation-2024.3-1, gplots-3.1.3.1, graphlayouts-1.1.1, grf-2.3.2, gridBase-0.4-7, gridExtra-2.3, gridGraphics-0.5-1, grImport2-0.3-1, grpreg-3.4.0, GSA-1.03.3, gsalib-2.2.1, gsl-2.1-8, gsw-1.1-1, gt-0.10.1, gtable-0.3.5, gtools-3.9.5, gtsummary-1.7.2, GUTS-1.2.5, gWidgets2-1.0-9, gWidgets2tcltk-1.0-8, GxEScanR-2.0.2, h2o-3.44.0.3, hal9001-0.4.6, haldensify-0.2.3, hardhat-1.4.0, harmony-1.2.0, hash-2.2.6.3, haven-2.5.4, hdf5r-1.3.10, hdm-0.3.2, heatmap3-1.1.9, here-1.0.1, hexbin-1.28.3, HGNChelper-0.8.14, HiddenMarkov-1.8-13, Hmisc-5.1-3, hms-1.1.3, Hmsc-3.0-13, htmlTable-2.4.2, httpcode-0.3.0, huge-1.3.5, hunspell-3.0.3, hwriter-1.3.2.1, HWxtest-1.1.9, hypergeo-1.2-13, ica-1.0-3, IDPmisc-1.1.21, idr-1.3, ids-1.0.1, ie2misc-0.9.1, igraph-2.0.3, image.binarization-0.1.3, imager-1.0.2, imagerExtra-1.3.2, ineq-0.2-13, influenceR-0.1.5, infotheo-1.2.0.1, inline-0.3.19, insight-0.20.3, intergraph-2.0-4, interp-1.1-6, interpretR-0.2.5, intrinsicDimension-1.2.0, inum-1.0-5, ipred-0.9-14, irace-3.5, irlba-2.3.5.1, ismev-1.42, Iso-0.0-21, isoband-0.2.7, ISOcodes-2024.02.12, ISOweek-0.6-2, iterators-1.0.14, itertools-0.1-3, JADE-2.0-4, janeaustenr-1.0.0, JBTools-0.7.2.9, jiebaR-0.11, jiebaRD-0.1, jomo-2.7-6, jpeg-0.1-10, jsonify-1.2.2, jstable-1.2.6, juicyjuice-0.1.0, kde1d-1.0.7, kedd-1.0.4, kernlab-0.9-32, KernSmooth-2.23-24, kinship2-1.9.6.1, klaR-1.7-3, KODAMA-2.4, kohonen-3.0.12, ks-1.14.2, labdsv-2.1-0, labeling-0.4.3, labelled-2.13.0, laeken-0.5.3, lambda.r-1.2.4, LaplacesDemon-16.1.6, lars-1.3, lassosum-0.4.5, lattice-0.22-6, latticeExtra-0.6-30, lava-1.8.0, lavaan-0.6-18, lazy-1.2-18, lazyeval-0.2.2, LCFdata-2.0, lda-1.5.2, ldbounds-2.0.2, leafem-0.2.3, leaflet-2.2.2, leaflet.providers-2.0.0, leafsync-0.1.0, leaps-3.2, LearnBayes-2.15.1, leiden-0.4.3.1, lhs-1.1.6, libcoin-1.0-10, limSolve-1.5.7.1, linkcomm-1.0-14, linprog-0.9-4, liquidSVM-1.2.4, listenv-0.9.1, lme4-1.1-35.4, LMERConvenienceFunctions-3.0, lmerTest-3.1-3, lmom-3.0, Lmoments-1.3-1, lmtest-0.9-40, lobstr-1.1.2, locfdr-1.1-8, locfit-1.5-9.10, logcondens-2.1.8, logger-0.3.0, logistf-1.26.0, logspline-2.1.22, longitudinal-1.1.13, longmemo-1.1-2, loo-2.7.0, lpSolve-5.6.20, lpSolveAPI-5.5.2.0-17.11, lqa-1.0-3, lsei-1.3-0, lslx-0.6.11, lubridate-1.9.3, lwgeom-0.2-14, magic-1.6-1, magick-2.8.3, MALDIquant-1.22.2, manipulateWidget-0.11.1, mapproj-1.2.11, maps-3.4.2, maptools-1.1-8, markdown-1.13, MASS-7.3-61, Matching-4.10-14, MatchIt-4.5.5, mathjaxr-1.6-0, matlab-1.0.4, Matrix-1.7-0, matrixcalc-1.0-6, MatrixModels-0.5-3, matrixStats-1.3.0, maxLik-1.5-2.1, maxlike-0.1-11, maxnet-0.1.4, mboost-2.9-10, mclogit-0.9.6, mclust-6.1.1, mcmc-0.9-8, MCMCpack-1.7-0, mcmcse-1.5-0, mda-0.5-4, medflex-0.6-10, mediation-4.5.0, memisc-0.99.31.7, memuse-4.2-3, MESS-0.5.12, metadat-1.2-0, metafor-4.6-0, MetaUtility-2.1.2, mets-1.3.4, mgcv-1.9-1, mgsub-1.7.3, mhsmm-0.4.21, mi-1.1, mice-3.16.0, miceadds-3.17-44, microbenchmark-1.4.10, MIIVsem-0.5.8, minerva-1.5.10, minpack.lm-1.2-4, minqa-1.2.7, minty-0.0.1, mirt-1.41, misc3d-0.9-1, miscTools-0.6-28, missForest-1.5, missMDA-1.19, mitml-0.4-5, mitools-2.4, mixtools-2.0.0, mlbench-2.1-5, mlegp-3.1.9, MLmetrics-1.1.3, mlogit-1.1-1, mlr-2.19.2, mlrMBO-1.1.5.1, mltools-0.3.5, mnormt-2.1.1, ModelMetrics-1.2.2.2, modelr-0.1.11, modeltools-0.2-23, momentfit-0.5, moments-0.14.1, MonteCarlo-1.0.6, mosaicCore-0.9.4.0, mpath-0.4-2.25, mRMRe-2.1.2.1, msm-1.7.1, mstate-0.3.2, multcomp-1.4-25, multcompView-0.1-10, multicool-1.0.1, multipol-1.0-9, multitaper-1.0-17, munsell-0.5.1, mvabund-4.2.1, mvnfast-0.2.8, mvtnorm-1.2-5, nabor-0.5.0, naniar-1.1.0, natserv-1.0.0, naturalsort-0.1.3, ncbit-2013.03.29.1, ncdf4-1.22, NCmisc-1.2.0, network-1.18.2, networkDynamic-0.11.4, networkLite-1.0.5, neuralnet-1.44.2, neuRosim-0.2-14, ngspatial-1.2-2, NISTunits-1.0.1, nleqslv-3.3.5, nlme-3.1-165, nloptr-2.1.0, NLP-0.2-1, nlsem-0.8-1, nnet-7.3-19, nnls-1.5, nonnest2-0.5-7, nor1mix-1.3-3, norm-1.0-11.1, nortest-1.0-4, np-0.60-17, npsurv-0.5-0, numDeriv-2016.8-1.1, oai-0.4.0, oce-1.8-2, OceanView-1.0.7, oddsratio-2.0.1, officer-0.6.6, openair-2.18-2, OpenMx-2.21.11, openxlsx-4.2.5.2, operator.tools-1.6.3, optextras-2019-12.4, optimParallel-1.0-2, optimr-2019-12.16, optimx-2023-10.21, optmatch-0.10.7, optparse-1.7.5, ordinal-2023.12-4, origami-1.0.7, oro.nifti-0.11.4, orthopolynom-1.0-6.1, osqp-0.6.3.3, outliers-0.15, packrat-0.9.2, pacman-0.5.1, pammtools-0.5.93, pamr-1.56.2, pan-1.9, parallelDist-0.2.6, parallelly-1.37.1, parallelMap-1.5.1, ParamHelpers-1.14.1, parsedate-1.3.1, party-1.3-15, partykit-1.2-20, pastecs-1.4.2, patchwork-1.2.0, pbapply-1.7-2, pbivnorm-0.6.0, pbkrtest-0.5.2, PCAmatchR-0.3.3, pcaPP-2.0-4, pdp-0.8.1, PearsonDS-1.3.1, pec-2023.04.12, penalized-0.9-52, penfa-0.1.1, peperr-1.5, performance-0.12.2, PermAlgo-1.2, permute-0.9-7, phangorn-2.11.1, pheatmap-1.0.12, phylobase-0.8.12, phytools-2.3-0, pim-2.0.2, pinfsc50-1.3.0, pixmap-0.4-13, pkgmaker-0.32.10, PKI-0.1-14, plogr-0.2.0, plot3D-1.4.1, plot3Drgl-1.0.4, plotly-4.10.4, plotmo-3.6.3, plotrix-3.8-4, pls-2.8-3, plyr-1.8.9, PMA-1.2-3, png-0.1-8, PoissonSeq-1.1.2, poLCA-1.6.0.1, polspline-1.1.25, Polychrome-1.5.1, polyclip-1.10-6, polycor-0.8-1, polynom-1.4-1, posterior-1.5.0, ppcor-1.1, prabclus-2.3-3, pracma-2.4.4, PresenceAbsence-1.1.11, preseqR-4.0.0, prettyGraphs-2.1.6, princurve-2.1.6, pROC-1.18.5, prodlim-2023.08.28, profileModel-0.6.1, proftools-0.99-3, progress-1.2.3, progressr-0.14.0, projpred-2.8.0, proto-1.0.0, proxy-0.4-27, proxyC-0.4.1, pryr-0.1.6, pscl-1.5.9, pspline-1.0-20, psych-2.4.3, Publish-2023.01.17, pulsar-0.3.11, pvclust-2.2-0, qgam-1.3.4, qgraph-1.9.8, qqman-0.1.9, qrnn-2.1.1, quadprog-1.5-8, quanteda-4.0.2, quantmod-0.4.26, quantreg-5.98, questionr-0.7.8, QuickJSR-1.2.2, R.cache-0.16.0, R.matlab-3.7.0, R.methodsS3-1.8.2, R.oo-1.26.0, R.rsp-0.46.0, R.utils-2.12.3, R2WinBUGS-2.1-22.1, random-0.2.6, randomForest-4.7-1.1, randomForestSRC-3.2.3, randtoolbox-2.0.4, rangeModelMetadata-0.1.5, ranger-0.16.0, RANN-2.6.1, rapidjsonr-1.2.0, rARPACK-0.11-0, raster-3.6-26, rasterVis-0.51.6, ratelimitr-0.4.1, RBesT-1.7-3, rbibutils-2.2.16, rbison-1.0.0, Rborist-0.3-7, RCAL-2.0, Rcgmin-2022-4.30, RCircos-1.2.2, RColorBrewer-1.1-3, RcppArmadillo-0.12.8.4.0, RcppEigen-0.3.4.0.0, RcppGSL-0.3.13, RcppParallel-5.1.7, RcppProgress-0.4.2, RcppRoll-0.3.0, RcppThread-2.1.7, RcppTOML-0.2.2, RCurl-1.98-1.14, rda-1.2-1, Rdpack-2.6, rdrop2-0.8.2.1, reactable-0.4.4, reactR-0.5.0, readbitmap-0.1.5, reader-1.0.6, readODS-2.3.0, readr-2.1.5, readxl-1.4.3, rebird-1.3.0, recipes-1.0.10, RefFreeEWAS-2.2, registry-0.5-1, regsem-1.9.5, relsurv-2.2-9, rematch-2.0.0, rentrez-1.2.3, renv-1.0.7, reprex-2.1.0, resample-0.6, reshape-0.8.9, reshape2-1.4.4, reticulate-1.38.0, rex-1.2.1, rgbif-3.8.0, RGCCA-3.0.3, rgdal-1.6-7, rgeos-0.6-4, rgexf-0.16.2, rgl-1.3.1, Rglpk-0.6-5.1, rhandsontable-0.3.8, RhpcBLASctl-0.23-42, ridge-3.3, ridigbio-0.3.8, RInside-0.2.18, rio-1.1.1, riskRegression-2023.12.21, ritis-1.0.0, RItools-0.3-4, rJava-1.0-11, rjson-0.2.21, RJSONIO-1.3-1.9, rle-0.9.2, rlecuyer-0.3-8, rlemon-0.2.1, rlist-0.4.6.2, rmeta-3.0, Rmpfr-0.9-5, rms-6.8-1, RMTstat-0.3.1, rncl-0.8.7, rnetcarto-0.2.6, RNeXML-2.4.11, rngtools-1.5.2, rngWELL-0.10-9, RNifti-1.7.0, robustbase-0.99-2, ROCR-1.0-11, ROI-1.0-1, ROI.plugin.glpk-1.0-0, Rook-1.2, rootSolve-1.8.2.4, roptim-0.1.6, rotl-3.1.0, rpact-4.0.0, rpart-4.1.23, rpf-1.0.14, RPMM-1.25, RPostgreSQL-0.7-6, rrcov-1.7-5, rredlist-0.7.1, rsample-1.2.1, rsconnect-1.3.1, Rserve-1.8-13, RSNNS-0.4-17, Rsolnp-1.16, RSpectra-0.16-1, RSQLite-2.3.7, Rssa-1.0.5, rstan-2.32.6, rstantools-2.4.0, rstatix-0.7.2, rtdists-0.11-5, Rtsne-0.17, Rttf2pt1-1.3.12, RUnit-0.4.33, ruv-0.9.7.1, rvertnet-0.8.4, rvest-1.0.4, rvinecopulib-0.6.3.1.1, Rvmmin-2018-4.17.1, RWeka-0.4-46, RWekajars-3.9.3-2, s2-1.1.6, sampling-2.10, sandwich-3.1-0, SBdecomp-1.2, scales-1.3.0, scam-1.2-17, scatterpie-0.2.3, scatterplot3d-0.3-44, scs-3.2.4, sctransform-0.4.1, SDMTools-1.1-221.2, seewave-2.2.3, segmented-2.1-0, selectr-0.4-2, sem-3.1-15, semPLS-1.0-10, semTools-0.5-6, sendmailR-1.4-0, sensemakr-0.1.4, sentometrics-1.0.0, seqinr-4.2-36, servr-0.30, setRNG-2024.2-1, sf-1.0-16, sfheaders-0.4.4, sfsmisc-1.1-18, shadowtext-0.1.3, shape-1.4.6.1, shapefiles-0.7.2, shinycssloaders-1.0.0, shinydashboard-0.7.2, shinyjs-2.1.0, shinystan-2.6.0, shinythemes-1.2.0, signal-1.8-0, SignifReg-4.3, simex-1.8, SimSeq-1.4.0, SKAT-2.2.5, slam-0.1-50, slider-0.3.1, sm-2.2-6.0, smoof-1.6.0.3, smoother-1.3, sn-2.1.1, sna-2.7-2, SNFtool-2.3.1, snow-0.4-4, SnowballC-0.7.1, snowfall-1.84-6.3, SOAR-0.99-11, solrium-1.2.0, som-0.3-5.1, soundecology-1.3.3, sp-2.1-4, spaa-0.2.2, spam-2.10-0, spaMM-4.5.0, SparseM-1.83, SPAtest-3.1.2, spatial-7.3-17, spatstat-3.0-8, spatstat.core-2.4-4, spatstat.data-3.1-2, spatstat.explore-3.2-7, spatstat.geom-3.2-9, spatstat.linnet-3.1-5, spatstat.model-3.2-11, spatstat.random-3.2-3, spatstat.sparse-3.1-0, spatstat.utils-3.0-5, spData-2.3.1, spdep-1.3-5, splitstackshape-1.4.8, spls-2.2-3, spocc-1.2.3, spThin-0.2.0, SQUAREM-2021.1, stabledist-0.7-1, stabs-0.6-4, StanHeaders-2.32.9, stargazer-5.2.3, stars-0.6-5, startupmsg-0.9.6.1, StatMatch-1.4.2, statmod-1.5.0, statnet-2019.6, statnet.common-4.9.0, stdReg-3.4.1, stopwords-2.3, stringdist-0.9.12, stringmagic-1.1.2, strucchange-1.5-3, styler-1.10.3, subplex-1.8, SuperLearner-2.0-29, SuppDists-1.1-9.7, survey-4.4-2, survival-3.7-0, survivalROC-1.0.3.1, svd-0.5.5, svglite-2.1.3, svUnit-1.0.6, swagger-5.17.14, symmoments-1.2.1, tableone-0.13.2, tabletools-0.1.0, tau-0.0-25, taxize-0.9.100, tcltk2-1.2-11, tclust-2.0-4, TeachingDemos-2.13, tensor-1.5, tensorA-0.36.2.1, tergm-4.2.0, terra-1.7-78, testit-0.13, textcat-1.0-8, textplot-0.2.2, TFisher-0.2.0, TH.data-1.1-2, threejs-0.3.3, tictoc-1.2.1, tidybayes-3.0.6, tidygraph-1.3.1, tidyr-1.3.1, tidyselect-1.2.1, tidytext-0.4.2, tidytree-0.4.6, tidyverse-2.0.0, tiff-0.1-12, timechange-0.3.0, timeDate-4032.109, timereg-2.0.5, tkrplot-0.0-27, tm-0.7-13, tmap-3.3-4, tmaptools-3.1-1, TMB-1.9.12, tmle-2.0.1.1, tmvnsim-1.0-2, tmvtnorm-1.6, tokenizers-0.3.0, topicmodels-0.2-16, TraMineR-2.2-10, tree-1.0-43, triebeard-0.4.1, trimcluster-0.1-5, tripack-1.3-9.1, TruncatedNormal-2.2.2, truncnorm-1.0-9, trust-0.1-8, tseries-0.10-56, tseriesChaos-0.1-13.1, tsna-0.3.5, tsne-0.1-3.1, TTR-0.24.4, tuneR-1.4.7, twang-2.6, tweedie-2.3.5, tweenr-2.0.3, tzdb-0.4.0, ucminf-1.2.1, udpipe-0.8.11, umap-0.2.10.0, unbalanced-2.0, unikn-1.0.0, uniqueAtomMat-0.1-3-2, units-0.8-5, unmarked-1.4.1, UpSetR-1.4.0, urca-1.3-4, urltools-1.7.3, uroot-2.1-3, uuid-1.2-0, V8-4.4.2, varhandle-2.0.6, vcd-1.4-12, vcfR-1.15.0, vegan-2.6-6.1, VennDiagram-1.7.3, VGAM-1.1-11, VIM-6.2.2, VineCopula-2.5.0, vioplot-0.4.0, vipor-0.4.7, viridis-0.6.5, viridisLite-0.4.2, visdat-0.6.0, visNetwork-2.1.2, vroom-1.6.5, VSURF-1.2.0, warp-0.2.1, waveslim-1.8.5, wdm-0.2.4, webshot-0.5.5, webutils-1.2.0, weights-1.0.4, WeightSVM-1.7-13, wellknown-0.7.4, widgetframe-0.3.1, WikidataQueryServiceR-1.0.0, WikidataR-2.3.3, WikipediR-1.7.1, wikitaxa-0.4.0, wk-0.9.1, word2vec-0.4.0, wordcloud-2.6, worrms-0.4.3, writexl-1.5.0, WriteXLS-6.6.0, XBRL-0.99.19.1, xgboost-1.7.7.1, xlsx-0.6.5, xlsxjars-0.6.1, XML-3.99-0.16.1, xts-0.14.0, yaImpute-1.0-34, yulab.utils-0.1.4, zeallot-0.1.0, zoo-1.8-12</p>"},{"location":"available_software/detail/R-bundle-CRAN/#r-bundle-cran202312-foss-2023a","title":"R-bundle-CRAN/2023.12-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>abc-2.2.1, abc.data-1.0, abe-3.0.1, abind-1.4-5, acepack-1.4.2, adabag-5.0, ade4-1.7-22, ADGofTest-0.3, admisc-0.34, aggregation-1.0.1, AICcmodavg-2.3-3, akima-0.6-3.4, alabama-2023.1.0, AlgDesign-1.2.1, alluvial-0.1-2, AMAPVox-1.0.1, animation-2.7, aod-1.3.2, apcluster-1.4.11, ape-5.7-1, aplot-0.2.2, argparse-2.2.2, aricode-1.0.3, arm-1.13-1, arrayhelpers-1.1-0, asnipe-1.1.17, assertive-0.3-6, assertive.base-0.0-9, assertive.code-0.0-4, assertive.data-0.0-3, assertive.data.uk-0.0-2, assertive.data.us-0.0-2, assertive.datetimes-0.0-3, assertive.files-0.0-2, assertive.matrices-0.0-2, assertive.models-0.0-2, assertive.numbers-0.0-2, assertive.properties-0.0-5, assertive.reflection-0.0-5, assertive.sets-0.0-3, assertive.strings-0.0-3, assertive.types-0.0-3, assertthat-0.2.1, AUC-0.3.2, audio-0.1-11, aws-2.5-3, awsMethods-1.1-1, backports-1.4.1, bacr-1.0.1, bartMachine-1.3.4.1, bartMachineJARs-1.2.1, base64-2.0.1, BatchJobs-1.9, batchmeans-1.0-4, BayesianTools-0.1.8, BayesLogit-2.1, bayesm-3.1-6, BayesPen-1.0, bayesplot-1.10.0, BB-2019.10-1, BBmisc-1.13, bbmle-1.0.25.1, BCEE-1.3.2, BDgraph-2.72, bdsmatrix-1.3-6, beanplot-1.3.1, beeswarm-0.4.0, berryFunctions-1.22.0, betareg-3.1-4, BH-1.81.0-1, BiasedUrn-2.0.11, bibtex-0.5.1, BIEN-1.2.6, bigD-0.2.0, BIGL-1.8.0, bigmemory-4.6.1, bigmemory.sri-0.1.6, bindr-0.1.1, bindrcpp-0.2.2, bio3d-2.4-4, biom-0.3.12, biomod2-4.2-4, bit-4.0.5, bit64-4.0.5, bitops-1.0-7, blavaan-0.5-2, blob-1.2.4, BMA-3.18.17, bmp-0.3, bnlearn-4.9.1, bold-1.3.0, boot-1.3-28.1, bootstrap-2019.6, Boruta-8.0.0, brglm-0.7.2, bridgedist-0.1.2, bridgesampling-1.1-2, brms-2.20.4, Brobdingnag-1.2-9, broom-1.0.5, broom.helpers-1.14.0, broom.mixed-0.2.9.4, bst-0.3-24, Cairo-1.6-2, calibrate-1.7.7, car-3.1-2, carData-3.0-5, caret-6.0-94, catlearn-1.0, caTools-1.18.2, CBPS-0.23, celestial-1.4.6, cellranger-1.1.0, cgdsr-1.3.0, cghFLasso-0.2-1, changepoint-2.2.4, checkmate-2.3.1, chemometrics-1.4.4, chk-0.9.1, chkptstanr-0.1.1, chron-2.3-61, circlize-0.4.15, circular-0.5-0, class-7.3-22, classInt-0.4-10, cld2-1.2.4, clisymbols-1.2.0, clock-0.7.0, clue-0.3-65, cluster-2.1.6, clusterGeneration-1.3.8, clusterRepro-0.9, clustree-0.5.1, clValid-0.7, cmna-1.0.5, cmprsk-2.2-11, cNORM-3.0.4, cobalt-4.5.2, cobs-1.3-5, coda-0.19-4, codetools-0.2-19, coin-1.4-3, collapse-2.0.7, colorspace-2.1-0, colourpicker-1.3.0, combinat-0.0-8, ComICS-1.0.4, ComplexUpset-1.3.3, compositions-2.0-6, CompQuadForm-1.4.3, conditionz-0.1.0, conflicted-1.2.0, conquer-1.3.3, ConsRank-2.1.3, contfrac-1.1-12, copCAR-2.0-4, copula-1.1-3, corpcor-1.6.10, corrplot-0.92, covr-3.6.4, CovSel-1.2.1, covsim-1.0.0, cowplot-1.1.1, coxed-0.3.3, coxme-2.2-18.1, crfsuite-0.4.2, crosstalk-1.2.1, crul-1.4.0, cSEM-0.5.0, csSAM-1.2.4, ctmle-0.1.2, cubature-2.1.0, cubelyr-1.0.2, cvAUC-1.1.4, CVST-0.2-3, CVXR-1.0-11, d3Network-0.5.2.1, dagitty-0.3-4, data.table-1.14.10, data.tree-1.1.0, DataCombine-0.2.21, date-1.2-42, dbarts-0.9-25, DBI-1.1.3, dbplyr-2.4.0, dbscan-1.1-12, dcurver-0.9.2, ddalpha-1.3.13, deal-1.2-42, debugme-1.1.0, deldir-2.0-2, dendextend-1.17.1, DEoptim-2.2-8, DEoptimR-1.1-3, DepthProc-2.1.5, Deriv-4.1.3, DescTools-0.99.52, deSolve-1.40, dfidx-0.0-5, DHARMa-0.4.6, dHSIC-2.1, diagram-1.6.5, DiagrammeR-1.0.10, DiceKriging-1.6.0, dichromat-2.0-0.1, dimRed-0.2.6, diptest-0.77-0, DiscriMiner-0.1-29, dismo-1.3-14, distillery-1.2-1, distr-2.9.2, distrEx-2.9.0, distributional-0.3.2, DistributionUtils-0.6-1, diveRsity-1.9.90, dlm-1.1-6, DMCfun-2.0.2, doc2vec-0.2.0, docstring-1.0.0, doMC-1.3.8, doParallel-1.0.17, doRNG-1.8.6, doSNOW-1.0.20, dotCall64-1.1-1, downloader-0.4, dplyr-1.1.4, dr-3.0.10, dreamerr-1.4.0, drgee-1.1.10, DRR-0.0.4, drugCombo-1.2.1, DT-0.31, dtangle-2.0.9, dtplyr-1.3.1, DTRreg-2.0, dtw-1.23-1, dummies-1.5.6, dygraphs-1.1.1.6, dynamicTreeCut-1.63-1, e1071-1.7-14, earth-5.3.2, EasyABC-1.5.2, ECOSolveR-0.5.5, ellipse-0.5.0, elliptic-1.4-0, emdbook-1.3.13, emmeans-1.8.9, emoa-0.5-0.2, emulator-1.2-21, energy-1.7-11, ENMeval-2.0.4, entropy-1.3.1, EnvStats-2.8.1, epitools-0.5-10.1, ergm-4.5.0, ergm.count-4.1.1, ergm.multi-0.2.0, estimability-1.4.1, EValue-4.1.3, evd-2.3-6.1, Exact-3.2, expm-0.999-8, ExPosition-2.8.23, expsmooth-2.3, extrafont-0.19, extrafontdb-1.0, extRemes-2.1-3, FactoMineR-2.9, FactorCopula-0.9.3, fail-1.3, farver-2.1.1, fastcluster-1.2.3, fastDummies-1.7.3, fasterize-1.0.5, fastICA-1.2-4, fastmatch-1.1-4, fdrtool-1.2.17, feather-0.3.5, ff-4.0.9, fftw-1.0-7, fftwtools-0.9-11, fields-15.2, filehash-2.4-5, finalfit-1.0.7, findpython-1.0.8, fishMod-0.29, fitdistrplus-1.1-11, fixest-0.11.2, FKSUM-1.0.1, flashClust-1.01-2, flexclust-1.4-1, flexmix-2.3-19, flextable-0.9.4, fma-2.5, FME-1.3.6.3, fmri-1.9.12, FNN-1.1.3.2, fontBitstreamVera-0.1.1, fontLiberation-0.1.0, fontquiver-0.2.1, forcats-1.0.0, foreach-1.5.2, forecast-8.21.1, foreign-0.8-86, formatR-1.14, Formula-1.2-5, formula.tools-1.7.1, fossil-0.4.0, fpc-2.2-10, fpp-0.5, fracdiff-1.5-2, furrr-0.3.1, futile.logger-1.4.3, futile.options-1.0.1, future-1.33.0, future.apply-1.11.0, gam-1.22-3, gamlss-5.4-20, gamlss.data-6.0-2, gamlss.dist-6.1-1, gamlss.tr-5.1-7, gamm4-0.2-6, gap-1.5-3, gap.datasets-0.0.6, gapfill-0.9.6-1, gargle-1.5.2, gaussquad-1.0-3, gbm-2.1.8.1, gbRd-0.4-11, gclus-1.3.2, gdalUtils-2.0.3.2, gdata-3.0.0, gdistance-1.6.4, gdtools-0.3.5, gee-4.13-26, geeM-0.10.1, geepack-1.3.9, geex-1.1.1, geiger-2.0.11, GeneNet-1.2.16, generics-0.1.3, genoPlotR-0.8.11, GenSA-1.1.10.1, geojsonsf-2.0.3, geometries-0.2.3, geometry-0.4.7, getopt-1.20.4, GetoptLong-1.0.5, gfonts-0.2.0, GGally-2.2.0, ggbeeswarm-0.7.2, ggdag-0.2.10, ggdist-3.3.1, ggExtra-0.10.1, ggfan-0.1.3, ggforce-0.4.1, ggformula-0.12.0, ggfun-0.1.3, ggh4x-0.2.6, ggnetwork-0.5.12, ggplot2-3.4.4, ggplotify-0.1.2, ggpubr-0.6.0, ggraph-2.1.0, ggrepel-0.9.4, ggridges-0.5.4, ggsci-3.0.0, ggsignif-0.6.4, ggstance-0.3.6, ggstats-0.5.1, ggvenn-0.1.10, ggvis-0.4.8, GillespieSSA-0.6.2, git2r-0.33.0, GJRM-0.2-6.4, glasso-1.11, gld-2.6.6, gllvm-1.4.3, glmmML-1.1.6, glmmTMB-1.1.8, glmnet-4.1-8, GlobalOptions-0.1.2, globals-0.16.2, gmm-1.8, gmodels-2.18.1.1, gmp-0.7-3, gnumeric-0.7-10, goftest-1.2-3, gomms-1.0, googledrive-2.1.1, googlesheets4-1.1.1, gower-1.0.1, GPArotation-2023.11-1, gplots-3.1.3, graphlayouts-1.0.2, grf-2.3.1, gridBase-0.4-7, gridExtra-2.3, gridGraphics-0.5-1, grImport2-0.3-1, grpreg-3.4.0, GSA-1.03.2, gsalib-2.2.1, gsl-2.1-8, gsw-1.1-1, gt-0.10.0, gtable-0.3.4, gtools-3.9.5, gtsummary-1.7.2, GUTS-1.2.5, gWidgets2-1.0-9, gWidgets2tcltk-1.0-8, GxEScanR-2.0.2, h2o-3.42.0.2, hal9001-0.4.6, haldensify-0.2.3, hardhat-1.3.0, harmony-1.2.0, hash-2.2.6.3, haven-2.5.4, hdf5r-1.3.8, hdm-0.3.1, heatmap3-1.1.9, here-1.0.1, hexbin-1.28.3, HGNChelper-0.8.1, HiddenMarkov-1.8-13, Hmisc-5.1-1, hms-1.1.3, Hmsc-3.0-13, htmlTable-2.4.2, httpcode-0.3.0, huge-1.3.5, hunspell-3.0.3, hwriter-1.3.2.1, HWxtest-1.1.9, hypergeo-1.2-13, ica-1.0-3, IDPmisc-1.1.20, idr-1.3, ids-1.0.1, ie2misc-0.9.1, igraph-1.5.1, image.binarization-0.1.3, imager-0.45.2, imagerExtra-1.3.2, ineq-0.2-13, influenceR-0.1.5, infotheo-1.2.0.1, inline-0.3.19, intergraph-2.0-3, interp-1.1-5, interpretR-0.2.5, intrinsicDimension-1.2.0, inum-1.0-5, ipred-0.9-14, irace-3.5, irlba-2.3.5.1, ismev-1.42, Iso-0.0-21, isoband-0.2.7, ISOcodes-2023.12.07, ISOweek-0.6-2, iterators-1.0.14, itertools-0.1-3, JADE-2.0-4, janeaustenr-1.0.0, JBTools-0.7.2.9, jiebaR-0.11, jiebaRD-0.1, jomo-2.7-6, jpeg-0.1-10, jsonify-1.2.2, jstable-1.1.3, juicyjuice-0.1.0, kde1d-1.0.5, kedd-1.0.3, kernlab-0.9-32, KernSmooth-2.23-22, kinship2-1.9.6, klaR-1.7-2, KODAMA-2.4, kohonen-3.0.12, ks-1.14.1, labdsv-2.1-0, labeling-0.4.3, labelled-2.12.0, laeken-0.5.2, lambda.r-1.2.4, LaplacesDemon-16.1.6, lars-1.3, lassosum-0.4.5, lattice-0.22-5, latticeExtra-0.6-30, lava-1.7.3, lavaan-0.6-16, lazy-1.2-18, lazyeval-0.2.2, LCFdata-2.0, lda-1.4.2, ldbounds-2.0.2, leafem-0.2.3, leaflet-2.2.1, leaflet.providers-2.0.0, leafsync-0.1.0, leaps-3.1, LearnBayes-2.15.1, leiden-0.4.3.1, lhs-1.1.6, libcoin-1.0-10, limSolve-1.5.7, linkcomm-1.0-14, linprog-0.9-4, liquidSVM-1.2.4, listenv-0.9.0, lme4-1.1-35.1, LMERConvenienceFunctions-3.0, lmerTest-3.1-3, lmom-3.0, Lmoments-1.3-1, lmtest-0.9-40, lobstr-1.1.2, locfdr-1.1-8, locfit-1.5-9.8, logcondens-2.1.8, logger-0.2.2, logistf-1.26.0, logspline-2.1.21, longitudinal-1.1.13, longmemo-1.1-2, loo-2.6.0, lpSolve-5.6.19, lpSolveAPI-5.5.2.0-17.11, lqa-1.0-3, lsei-1.3-0, lslx-0.6.11, lubridate-1.9.3, lwgeom-0.2-13, magic-1.6-1, magick-2.8.1, MALDIquant-1.22.1, manipulateWidget-0.11.1, mapproj-1.2.11, maps-3.4.1.1, maptools-1.1-8, markdown-1.12, MASS-7.3-60, Matching-4.10-14, MatchIt-4.5.5, mathjaxr-1.6-0, matlab-1.0.4, Matrix-1.6-4, matrixcalc-1.0-6, MatrixModels-0.5-3, matrixStats-1.1.0, maxLik-1.5-2, maxlike-0.1-10, maxnet-0.1.4, mboost-2.9-9, mclogit-0.9.6, mclust-6.0.1, mcmc-0.9-8, MCMCpack-1.6-3, mcmcse-1.5-0, mda-0.5-4, medflex-0.6-10, mediation-4.5.0, memisc-0.99.31.6, memuse-4.2-3, MESS-0.5.12, metadat-1.2-0, metafor-4.4-0, MetaUtility-2.1.2, mets-1.3.3, mgcv-1.9-0, mgsub-1.7.3, mhsmm-0.4.21, mi-1.1, mice-3.16.0, miceadds-3.16-18, microbenchmark-1.4.10, MIIVsem-0.5.8, minerva-1.5.10, minpack.lm-1.2-4, minqa-1.2.6, mirt-1.41, misc3d-0.9-1, miscTools-0.6-28, missForest-1.5, missMDA-1.19, mitml-0.4-5, mitools-2.4, mixtools-2.0.0, mlbench-2.1-3.1, mlegp-3.1.9, MLmetrics-1.1.1, mlogit-1.1-1, mlr-2.19.1, mlrMBO-1.1.5.1, mltools-0.3.5, mnormt-2.1.1, ModelMetrics-1.2.2.2, modelr-0.1.11, modeltools-0.2-23, momentfit-0.5, moments-0.14.1, MonteCarlo-1.0.6, mosaicCore-0.9.4.0, mpath-0.4-2.23, mRMRe-2.1.2.1, msm-1.7.1, mstate-0.3.2, multcomp-1.4-25, multcompView-0.1-9, multicool-1.0.0, multipol-1.0-9, munsell-0.5.0, mvabund-4.2.1, mvnfast-0.2.8, mvtnorm-1.2-4, nabor-0.5.0, naniar-1.0.0, natserv-1.0.0, naturalsort-0.1.3, ncbit-2013.03.29.1, ncdf4-1.22, NCmisc-1.2.0, network-1.18.2, networkDynamic-0.11.3, networkLite-1.0.5, neuralnet-1.44.2, neuRosim-0.2-14, ngspatial-1.2-2, NISTunits-1.0.1, nleqslv-3.3.5, nlme-3.1-164, nloptr-2.0.3, NLP-0.2-1, nlsem-0.8-1, nnet-7.3-19, nnls-1.5, nonnest2-0.5-6, nor1mix-1.3-2, norm-1.0-11.1, nortest-1.0-4, np-0.60-17, npsurv-0.5-0, numDeriv-2016.8-1.1, oai-0.4.0, oce-1.8-2, OceanView-1.0.6, oddsratio-2.0.1, officer-0.6.3, openair-2.18-0, OpenMx-2.21.11, openxlsx-4.2.5.2, operator.tools-1.6.3, optextras-2019-12.4, optimParallel-1.0-2, optimr-2019-12.16, optimx-2023-10.21, optmatch-0.10.7, optparse-1.7.3, ordinal-2023.12-4, origami-1.0.7, oro.nifti-0.11.4, orthopolynom-1.0-6.1, osqp-0.6.3.2, outliers-0.15, packrat-0.9.2, pacman-0.5.1, pammtools-0.5.92, pamr-1.56.1, pan-1.9, parallelDist-0.2.6, parallelly-1.36.0, parallelMap-1.5.1, ParamHelpers-1.14.1, parsedate-1.3.1, party-1.3-14, partykit-1.2-20, pastecs-1.3.21, patchwork-1.1.3, pbapply-1.7-2, pbivnorm-0.6.0, pbkrtest-0.5.2, PCAmatchR-0.3.3, pcaPP-2.0-4, pdp-0.8.1, PearsonDS-1.3.0, pec-2023.04.12, penalized-0.9-52, penfa-0.1.1, peperr-1.5, PermAlgo-1.2, permute-0.9-7, phangorn-2.11.1, pheatmap-1.0.12, phylobase-0.8.10, phytools-2.0-3, pim-2.0.2, pinfsc50-1.3.0, pixmap-0.4-12, pkgmaker-0.32.10, plogr-0.2.0, plot3D-1.4, plot3Drgl-1.0.4, plotly-4.10.3, plotmo-3.6.2, plotrix-3.8-4, pls-2.8-3, plyr-1.8.9, PMA-1.2-2, png-0.1-8, PoissonSeq-1.1.2, poLCA-1.6.0.1, polspline-1.1.24, Polychrome-1.5.1, polyclip-1.10-6, polycor-0.8-1, polynom-1.4-1, posterior-1.5.0, ppcor-1.1, prabclus-2.3-3, pracma-2.4.4, PresenceAbsence-1.1.11, preseqR-4.0.0, prettyGraphs-2.1.6, princurve-2.1.6, pROC-1.18.5, prodlim-2023.08.28, profileModel-0.6.1, proftools-0.99-3, progress-1.2.3, progressr-0.14.0, projpred-2.7.0, proto-1.0.0, proxy-0.4-27, proxyC-0.3.4, pryr-0.1.6, pscl-1.5.5.1, pspline-1.0-19, psych-2.3.9, Publish-2023.01.17, pulsar-0.3.11, pvclust-2.2-0, qgam-1.3.4, qgraph-1.9.8, qqman-0.1.9, qrnn-2.1, quadprog-1.5-8, quanteda-3.3.1, quantmod-0.4.25, quantreg-5.97, questionr-0.7.8, QuickJSR-1.0.8, R.cache-0.16.0, R.matlab-3.7.0, R.methodsS3-1.8.2, R.oo-1.25.0, R.rsp-0.45.0, R.utils-2.12.3, R2WinBUGS-2.1-21, random-0.2.6, randomForest-4.7-1.1, randomForestSRC-3.2.3, randtoolbox-2.0.4, rangeModelMetadata-0.1.5, ranger-0.16.0, RANN-2.6.1, rapidjsonr-1.2.0, rARPACK-0.11-0, raster-3.6-26, rasterVis-0.51.6, ratelimitr-0.4.1, RBesT-1.7-2, rbibutils-2.2.16, rbison-1.0.0, Rborist-0.3-5, RCAL-2.0, Rcgmin-2022-4.30, RCircos-1.2.2, RColorBrewer-1.1-3, RcppArmadillo-0.12.6.6.1, RcppEigen-0.3.3.9.4, RcppGSL-0.3.13, RcppParallel-5.1.7, RcppProgress-0.4.2, RcppRoll-0.3.0, RcppThread-2.1.6, RcppTOML-0.2.2, RCurl-1.98-1.13, rda-1.2-1, Rdpack-2.6, rdrop2-0.8.2.1, reactable-0.4.4, reactR-0.5.0, readbitmap-0.1.5, reader-1.0.6, readODS-2.1.0, readr-2.1.4, readxl-1.4.3, rebird-1.3.0, recipes-1.0.8, RefFreeEWAS-2.2, registry-0.5-1, regsem-1.9.5, relsurv-2.2-9, rematch-2.0.0, rentrez-1.2.3, renv-1.0.3, reprex-2.0.2, resample-0.6, reshape-0.8.9, reshape2-1.4.4, reticulate-1.34.0, rex-1.2.1, rgbif-3.7.8, RGCCA-3.0.2, rgdal-1.6-7, rgeos-0.6-4, rgexf-0.16.2, rgl-1.2.8, Rglpk-0.6-5, rhandsontable-0.3.8, RhpcBLASctl-0.23-42, ridge-3.3, ridigbio-0.3.7, RInside-0.2.18, rio-1.0.1, riskRegression-2023.09.08, ritis-1.0.0, RItools-0.3-3, rJava-1.0-10, rjson-0.2.21, RJSONIO-1.3-1.9, rle-0.9.2, rlecuyer-0.3-8, rlemon-0.2.1, rlist-0.4.6.2, rmeta-3.0, Rmpfr-0.9-4, rms-6.7-1, RMTstat-0.3.1, rncl-0.8.7, rnetcarto-0.2.6, RNeXML-2.4.11, rngtools-1.5.2, rngWELL-0.10-9, RNifti-1.5.1, robustbase-0.99-1, ROCR-1.0-11, ROI-1.0-1, ROI.plugin.glpk-1.0-0, Rook-1.2, rootSolve-1.8.2.4, roptim-0.1.6, rotl-3.1.0, rpact-3.4.0, rpart-4.1.23, rpf-1.0.14, RPMM-1.25, RPostgreSQL-0.7-5, rrcov-1.7-4, rredlist-0.7.1, rsample-1.2.0, rsconnect-1.1.1, Rserve-1.8-13, RSNNS-0.4-17, Rsolnp-1.16, RSpectra-0.16-1, RSQLite-2.3.4, Rssa-1.0.5, rstan-2.32.3, rstantools-2.3.1.1, rstatix-0.7.2, rtdists-0.11-5, Rtsne-0.17, Rttf2pt1-1.3.12, RUnit-0.4.32, ruv-0.9.7.1, rvertnet-0.8.2, rvest-1.0.3, rvinecopulib-0.6.3.1.1, Rvmmin-2018-4.17.1, RWeka-0.4-46, RWekajars-3.9.3-2, s2-1.1.4, sampling-2.10, sandwich-3.0-2, SBdecomp-1.2, scales-1.3.0, scam-1.2-14, scatterpie-0.2.1, scatterplot3d-0.3-44, scs-3.2.4, sctransform-0.4.1, SDMTools-1.1-221.2, seewave-2.2.3, segmented-2.0-0, selectr-0.4-2, sem-3.1-15, semPLS-1.0-10, semTools-0.5-6, sendmailR-1.4-0, sensemakr-0.1.4, sentometrics-1.0.0, seqinr-4.2-36, servr-0.27, setRNG-2022.4-1, sf-1.0-14, sfheaders-0.4.3, sfsmisc-1.1-16, shadowtext-0.1.2, shape-1.4.6, shapefiles-0.7.2, shinycssloaders-1.0.0, shinydashboard-0.7.2, shinyjs-2.1.0, shinystan-2.6.0, shinythemes-1.2.0, signal-1.8-0, SignifReg-4.3, simex-1.8, SimSeq-1.4.0, SKAT-2.2.5, slam-0.1-50, slider-0.3.1, sm-2.2-5.7.1, smoof-1.6.0.3, smoother-1.1, sn-2.1.1, sna-2.7-2, SNFtool-2.3.1, snow-0.4-4, SnowballC-0.7.1, snowfall-1.84-6.3, SOAR-0.99-11, solrium-1.2.0, som-0.3-5.1, soundecology-1.3.3, sp-2.1-2, spaa-0.2.2, spam-2.10-0, spaMM-4.4.0, SparseM-1.81, SPAtest-3.1.2, spatial-7.3-17, spatstat-3.0-7, spatstat.core-2.4-4, spatstat.data-3.0-3, spatstat.explore-3.2-5, spatstat.geom-3.2-7, spatstat.linnet-3.1-3, spatstat.model-3.2-8, spatstat.random-3.2-2, spatstat.sparse-3.0-3, spatstat.utils-3.0-4, spData-2.3.0, spdep-1.3-1, splitstackshape-1.4.8, spls-2.2-3, spocc-1.2.2, spThin-0.2.0, SQUAREM-2021.1, stabledist-0.7-1, stabs-0.6-4, StanHeaders-2.26.28, stargazer-5.2.3, stars-0.6-4, startupmsg-0.9.6, StatMatch-1.4.1, statmod-1.5.0, statnet-2019.6, statnet.common-4.9.0, stdReg-3.4.1, stopwords-2.3, stringdist-0.9.12, stringmagic-1.0.0, strucchange-1.5-3, styler-1.10.2, subplex-1.8, SuperLearner-2.0-28.1, SuppDists-1.1-9.7, survey-4.2-1, survival-3.5-7, survivalROC-1.0.3.1, svd-0.5.5, svglite-2.1.3, svUnit-1.0.6, swagger-3.33.1, symmoments-1.2.1, tableone-0.13.2, tabletools-0.1.0, tau-0.0-25, taxize-0.9.100, tcltk2-1.2-11, tclust-1.5-5, TeachingDemos-2.12, tensor-1.5, tensorA-0.36.2, tergm-4.2.0, terra-1.7-55, testit-0.13, textcat-1.0-8, textplot-0.2.2, TFisher-0.2.0, TH.data-1.1-2, threejs-0.3.3, tictoc-1.2, tidybayes-3.0.6, tidygraph-1.2.3, tidyr-1.3.0, tidyselect-1.2.0, tidytext-0.4.1, tidytree-0.4.5, tidyverse-2.0.0, tiff-0.1-12, timechange-0.2.0, timeDate-4022.108, timereg-2.0.5, tkrplot-0.0-27, tm-0.7-11, tmap-3.3-4, tmaptools-3.1-1, TMB-1.9.9, tmle-2.0.0, tmvnsim-1.0-2, tmvtnorm-1.6, tokenizers-0.3.0, topicmodels-0.2-15, TraMineR-2.2-8, tree-1.0-43, triebeard-0.4.1, trimcluster-0.1-5, tripack-1.3-9.1, TruncatedNormal-2.2.2, truncnorm-1.0-9, trust-0.1-8, tseries-0.10-55, tseriesChaos-0.1-13.1, tsna-0.3.5, tsne-0.1-3.1, TTR-0.24.4, tuneR-1.4.6, twang-2.6, tweedie-2.3.5, tweenr-2.0.2, tzdb-0.4.0, ucminf-1.2.0, udpipe-0.8.11, umap-0.2.10.0, unbalanced-2.0, unikn-0.9.0, uniqueAtomMat-0.1-3-2, units-0.8-5, unmarked-1.3.2, UpSetR-1.4.0, urca-1.3-3, urltools-1.7.3, uroot-2.1-2, uuid-1.1-1, V8-4.4.1, varhandle-2.0.6, vcd-1.4-11, vcfR-1.15.0, vegan-2.6-4, VennDiagram-1.7.3, VGAM-1.1-9, VIM-6.2.2, VineCopula-2.5.0, vioplot-0.4.0, vipor-0.4.5, viridis-0.6.4, viridisLite-0.4.2, visdat-0.6.0, visNetwork-2.1.2, vroom-1.6.5, VSURF-1.2.0, warp-0.2.1, waveslim-1.8.4, wdm-0.2.4, webshot-0.5.5, webutils-1.2.0, weights-1.0.4, WeightSVM-1.7-13, wellknown-0.7.4, widgetframe-0.3.1, WikidataQueryServiceR-1.0.0, WikidataR-2.3.3, WikipediR-1.5.0, wikitaxa-0.4.0, wk-0.9.1, word2vec-0.4.0, wordcloud-2.6, worrms-0.4.3, writexl-1.4.2, WriteXLS-6.4.0, XBRL-0.99.19.1, xgboost-1.7.6.1, xlsx-0.6.5, xlsxjars-0.6.1, XML-3.99-0.16, xts-0.13.1, yaImpute-1.0-33, yulab.utils-0.1.0, zeallot-0.1.0, zoo-1.8-12</p>"},{"location":"available_software/detail/R/","title":"R","text":"<p>R is a free software environment for statistical computing and graphics.</p> <p>https://www.r-project.org/</p>"},{"location":"available_software/detail/R/#available-modules","title":"Available modules","text":"<p>The overview below shows which R installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using R, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load R/4.4.1-gfbf-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 R/4.4.1-gfbf-2023b x x x x x x x x x x x R/4.3.2-gfbf-2023a x x x x x x x x x x x R/4.2.2-foss-2022b x x x x x x x x x x x"},{"location":"available_software/detail/R/#r441-gfbf-2023b","title":"R/4.4.1-gfbf-2023b","text":"<p>This is a list of extensions included in the module:</p> <p>askpass-1.2.0, base, base64enc-0.1-3, brew-1.0-10, brio-1.1.5, bslib-0.7.0, cachem-1.1.0, callr-3.7.6, cli-3.6.3, clipr-0.8.0, commonmark-1.9.1, compiler, cpp11-0.4.7, crayon-1.5.3, credentials-2.0.1, curl-5.2.1, datasets, desc-1.4.3, devtools-2.4.5, diffobj-0.3.5, digest-0.6.36, downlit-0.4.4, ellipsis-0.3.2, evaluate-0.24.0, fansi-1.0.6, fastmap-1.2.0, fontawesome-0.5.2, fs-1.6.4, gert-2.0.1, gh-1.4.1, gitcreds-0.1.2, glue-1.7.0, graphics, grDevices, grid, highr-0.11, htmltools-0.5.8.1, htmlwidgets-1.6.4, httpuv-1.6.15, httr-1.4.7, httr2-1.0.1, ini-0.3.1, jquerylib-0.1.4, jsonlite-1.8.8, knitr-1.47, later-1.3.2, lifecycle-1.0.4, magrittr-2.0.3, memoise-2.0.1, methods, mime-0.12, miniUI-0.1.1.1, openssl-2.2.0, parallel, pillar-1.9.0, pkgbuild-1.4.4, pkgconfig-2.0.3, pkgdown-2.0.9, pkgload-1.3.4, praise-1.0.0, prettyunits-1.2.0, processx-3.8.4, profvis-0.3.8, promises-1.3.0, ps-1.7.6, purrr-1.0.2, R6-2.5.1, ragg-1.3.2, rappdirs-0.3.3, rcmdcheck-1.4.0, Rcpp-1.0.12, rematch2-2.1.2, remotes-2.5.0, rlang-1.1.4, rmarkdown-2.27, roxygen2-7.3.1, rprojroot-2.0.4, rstudioapi-0.16.0, rversions-2.1.2, sass-0.4.9, sessioninfo-1.2.2, shiny-1.8.1.1, sourcetools-0.1.7-1, splines, stats, stats4, stringi-1.8.4, stringr-1.5.1, sys-3.4.2, systemfonts-1.1.0, tcltk, testthat-3.2.1.1, textshaping-0.4.0, tibble-3.2.1, tinytex-0.51, tools, urlchecker-1.0.1, usethis-2.2.3, utf8-1.2.4, utils, vctrs-0.6.5, waldo-0.5.2, whisker-0.4.1, withr-3.0.0, xfun-0.45, xml2-1.3.6, xopen-1.0.1, xtable-1.8-4, yaml-2.3.8, zip-2.3.1</p>"},{"location":"available_software/detail/R/#r432-gfbf-2023a","title":"R/4.3.2-gfbf-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>askpass-1.2.0, base, base64enc-0.1-3, brew-1.0-8, brio-1.1.3, bslib-0.5.1, cachem-1.0.8, callr-3.7.3, cli-3.6.1, clipr-0.8.0, commonmark-1.9.0, compiler, cpp11-0.4.6, crayon-1.5.2, credentials-2.0.1, curl-5.1.0, datasets, desc-1.4.2, devtools-2.4.5, diffobj-0.3.5, digest-0.6.33, downlit-0.4.3, ellipsis-0.3.2, evaluate-0.23, fansi-1.0.5, fastmap-1.1.1, fontawesome-0.5.2, fs-1.6.3, gert-2.0.0, gh-1.4.0, gitcreds-0.1.2, glue-1.6.2, graphics, grDevices, grid, highr-0.10, htmltools-0.5.7, htmlwidgets-1.6.2, httpuv-1.6.12, httr-1.4.7, httr2-0.2.3, ini-0.3.1, jquerylib-0.1.4, jsonlite-1.8.7, knitr-1.45, later-1.3.1, lifecycle-1.0.3, magrittr-2.0.3, memoise-2.0.1, methods, mime-0.12, miniUI-0.1.1.1, openssl-2.1.1, parallel, pillar-1.9.0, pkgbuild-1.4.2, pkgconfig-2.0.3, pkgdown-2.0.7, pkgload-1.3.3, praise-1.0.0, prettyunits-1.2.0, processx-3.8.2, profvis-0.3.8, promises-1.2.1, ps-1.7.5, purrr-1.0.2, R6-2.5.1, ragg-1.2.6, rappdirs-0.3.3, rcmdcheck-1.4.0, Rcpp-1.0.11, rematch2-2.1.2, remotes-2.4.2.1, rlang-1.1.2, rmarkdown-2.25, roxygen2-7.2.3, rprojroot-2.0.4, rstudioapi-0.15.0, rversions-2.1.2, sass-0.4.7, sessioninfo-1.2.2, shiny-1.7.5.1, sourcetools-0.1.7-1, splines, stats, stats4, stringi-1.7.12, stringr-1.5.0, sys-3.4.2, systemfonts-1.0.5, tcltk, testthat-3.2.0, textshaping-0.3.7, tibble-3.2.1, tinytex-0.48, tools, urlchecker-1.0.1, usethis-2.2.2, utf8-1.2.4, utils, vctrs-0.6.4, waldo-0.5.2, whisker-0.4.1, withr-2.5.2, xfun-0.41, xml2-1.3.5, xopen-1.0.0, xtable-1.8-4, yaml-2.3.7, zip-2.3.0</p>"},{"location":"available_software/detail/R/#r422-foss-2022b","title":"R/4.2.2-foss-2022b","text":"<p>This is a list of extensions included in the module:</p> <p>abc-2.2.1, abc.data-1.0, abe-3.0.1, abind-1.4-5, acepack-1.4.1, adabag-4.2, ade4-1.7-22, ADGofTest-0.3, admisc-0.31, aggregation-1.0.1, AICcmodavg-2.3-1, akima-0.6-3.4, alabama-2022.4-1, AlgDesign-1.2.1, alluvial-0.1-2, AMAPVox-1.0.0, animation-2.7, aod-1.3.2, apcluster-1.4.10, ape-5.7-1, aplot-0.1.10, argparse-2.2.2, aricode-1.0.2, arm-1.13-1, askpass-1.1, asnipe-1.1.16, assertive-0.3-6, assertive.base-0.0-9, assertive.code-0.0-3, assertive.data-0.0-3, assertive.data.uk-0.0-2, assertive.data.us-0.0-2, assertive.datetimes-0.0-3, assertive.files-0.0-2, assertive.matrices-0.0-2, assertive.models-0.0-2, assertive.numbers-0.0-2, assertive.properties-0.0-5, assertive.reflection-0.0-5, assertive.sets-0.0-3, assertive.strings-0.0-3, assertive.types-0.0-3, assertthat-0.2.1, AUC-0.3.2, audio-0.1-10, aws-2.5-1, awsMethods-1.1-1, backports-1.4.1, bacr-1.0.1, bartMachine-1.3.3.1, bartMachineJARs-1.2.1, base, base64-2.0.1, base64enc-0.1-3, BatchJobs-1.9, batchmeans-1.0-4, BayesianTools-0.1.8, BayesLogit-2.1, bayesm-3.1-5, BayesPen-1.0, bayesplot-1.10.0, BB-2019.10-1, BBmisc-1.13, bbmle-1.0.25, BCEE-1.3.1, BDgraph-2.72, bdsmatrix-1.3-6, beanplot-1.3.1, beeswarm-0.4.0, berryFunctions-1.22.0, betareg-3.1-4, BH-1.81.0-1, BiasedUrn-2.0.9, bibtex-0.5.1, bigD-0.2.0, BIGL-1.7.0, bigmemory-4.6.1, bigmemory.sri-0.1.6, bindr-0.1.1, bindrcpp-0.2.2, bio3d-2.4-4, biom-0.3.12, biomod2-4.2-2, bit-4.0.5, bit64-4.0.5, bitops-1.0-7, blavaan-0.4-7, blob-1.2.4, BMA-3.18.17, bmp-0.3, bnlearn-4.8.1, bold-1.2.0, boot-1.3-28.1, bootstrap-2019.6, Boruta-8.0.0, brew-1.0-8, brglm-0.7.2, bridgedist-0.1.2, bridgesampling-1.1-2, brio-1.1.3, brms-2.19.0, Brobdingnag-1.2-9, broom-1.0.4, broom.helpers-1.12.0, broom.mixed-0.2.9.4, bslib-0.4.2, bst-0.3-24, cachem-1.0.7, Cairo-1.6-0, calibrate-1.7.7, callr-3.7.3, car-3.1-1, carData-3.0-5, caret-6.0-93, catlearn-0.9.1, caTools-1.18.2, CBPS-0.23, celestial-1.4.6, cellranger-1.1.0, cgdsr-1.2.10, cghFLasso-0.2-1, changepoint-2.2.4, checkmate-2.1.0, chemometrics-1.4.2, chkptstanr-0.1.1, chron-2.3-60, circlize-0.4.15, circular-0.4-95, class-7.3-21, classInt-0.4-9, cld2-1.2.4, cli-3.6.0, clipr-0.8.0, clisymbols-1.2.0, clock-0.6.1, clue-0.3-64, cluster-2.1.4, clusterGeneration-1.3.7, clusterRepro-0.9, clustree-0.5.0, clValid-0.7, cmprsk-2.2-11, cNORM-3.0.2, cobalt-4.4.1, cobs-1.3-5, coda-0.19-4, codetools-0.2-19, coin-1.4-2, collapse-1.9.3, colorspace-2.1-0, colourpicker-1.2.0, combinat-0.0-8, ComICS-1.0.4, commonmark-1.8.1, compiler, ComplexUpset-1.3.3, compositions-2.0-5, CompQuadForm-1.4.3, conditionz-0.1.0, conflicted-1.2.0, conquer-1.3.3, contfrac-1.1-12, copCAR-2.0-4, copula-1.1-2, corpcor-1.6.10, corrplot-0.92, covr-3.6.1, CovSel-1.2.1, covsim-1.0.0, cowplot-1.1.1, coxed-0.3.3, coxme-2.2-18.1, cpp11-0.4.3, crayon-1.5.2, credentials-1.3.2, crfsuite-0.4.1, crosstalk-1.2.0, crul-1.3, cSEM-0.5.0, csSAM-1.2.4, ctmle-0.1.2, cubature-2.0.4.6, cubelyr-1.0.2, curl-5.0.0, cvAUC-1.1.4, CVST-0.2-3, CVXR-1.0-11, d3Network-0.5.2.1, dagitty-0.3-1, data.table-1.14.8, data.tree-1.0.0, DataCombine-0.2.21, datasets, date-1.2-42, dbarts-0.9-23, DBI-1.1.3, dbplyr-2.3.1, dbscan-1.1-11, dcurver-0.9.2, ddalpha-1.3.13, deal-1.2-42, debugme-1.1.0, deldir-1.0-6, dendextend-1.16.0, DEoptim-2.2-8, DEoptimR-1.0-11, DepthProc-2.1.5, Deriv-4.1.3, desc-1.4.2, DescTools-0.99.48, deSolve-1.35, devtools-2.4.5, dfidx-0.0-5, DHARMa-0.4.6, dHSIC-2.1, diagram-1.6.5, DiagrammeR-1.0.9, DiceKriging-1.6.0, dichromat-2.0-0.1, diffobj-0.3.5, digest-0.6.31, dimRed-0.2.6, diptest-0.76-0, DiscriMiner-0.1-29, dismo-1.3-9, distillery-1.2-1, distr-2.9.1, distrEx-2.9.0, distributional-0.3.1, DistributionUtils-0.6-0, diveRsity-1.9.90, dlm-1.1-6, DMCfun-2.0.2, doc2vec-0.2.0, docstring-1.0.0, doMC-1.3.8, doParallel-1.0.17, doRNG-1.8.6, doSNOW-1.0.20, dotCall64-1.0-2, downlit-0.4.2, downloader-0.4, dplyr-1.1.0, dr-3.0.10, drgee-1.1.10, DRR-0.0.4, drugCombo-1.2.1, DT-0.27, dtangle-2.0.9, dtplyr-1.3.0, DTRreg-1.7, dtw-1.23-1, dummies-1.5.6, dygraphs-1.1.1.6, dynamicTreeCut-1.63-1, e1071-1.7-13, earth-5.3.2, EasyABC-1.5.2, ECOSolveR-0.5.5, elementR-1.3.7, ellipse-0.4.3, ellipsis-0.3.2, elliptic-1.4-0, emdbook-1.3.12, emmeans-1.8.5, emoa-0.5-0.1, emulator-1.2-21, energy-1.7-11, ENMeval-2.0.4, entropy-1.3.1, EnvStats-2.7.0, epitools-0.5-10.1, ergm-4.4.0, ergm.count-4.1.1, estimability-1.4.1, evaluate-0.20, EValue-4.1.3, evd-2.3-6.1, Exact-3.2, expm-0.999-7, ExPosition-2.8.23, expsmooth-2.3, extrafont-0.19, extrafontdb-1.0, extRemes-2.1-3, FactoMineR-2.7, FactorCopula-0.9.3, fail-1.3, fansi-1.0.4, farver-2.1.1, fastcluster-1.2.3, fastDummies-1.6.3, fasterize-1.0.4, fastICA-1.2-3, fastmap-1.1.1, fastmatch-1.1-3, fdrtool-1.2.17, feather-0.3.5, ff-4.0.9, fftw-1.0-7, fftwtools-0.9-11, fields-14.1, filehash-2.4-5, finalfit-1.0.6, findpython-1.0.8, fishMod-0.29, fitdistrplus-1.1-8, FKSUM-1.0.1, flashClust-1.01-2, flexclust-1.4-1, flexmix-2.3-19, flextable-0.9.2, fma-2.5, FME-1.3.6.2, fmri-1.9.11, FNN-1.1.3.1, fontawesome-0.5.0, fontBitstreamVera-0.1.1, fontLiberation-0.1.0, fontquiver-0.2.1, forcats-1.0.0, foreach-1.5.2, forecast-8.21, foreign-0.8-84, formatR-1.14, Formula-1.2-5, formula.tools-1.7.1, fossil-0.4.0, fpc-2.2-10, fpp-0.5, fracdiff-1.5-2, fs-1.6.1, furrr-0.3.1, futile.logger-1.4.3, futile.options-1.0.1, future-1.32.0, future.apply-1.10.0, gam-1.22-1, gamlss-5.4-12, gamlss.data-6.0-2, gamlss.dist-6.0-5, gamlss.tr-5.1-7, gamm4-0.2-6, gap-1.5-1, gap.datasets-0.0.5, gapfill-0.9.6-1, gargle-1.3.0, gaussquad-1.0-3, gbm-2.1.8.1, gbRd-0.4-11, gclus-1.3.2, gdalUtilities-1.2.5, gdalUtils-2.0.3.2, gdata-2.18.0.1, gdistance-1.6, gdtools-0.3.3, gee-4.13-25, geeM-0.10.1, geepack-1.3.9, geex-1.1.1, geiger-2.0.10, GeneNet-1.2.16, generics-0.1.3, genoPlotR-0.8.11, GenSA-1.1.8, geojson-0.3.5, geojsonio-0.11.3, geojsonsf-2.0.3, geometries-0.2.2, geometry-0.4.7, gert-1.9.2, getopt-1.20.3, GetoptLong-1.0.5, gfonts-0.2.0, GGally-2.1.2, ggbeeswarm-0.7.1, ggdag-0.2.7, ggExtra-0.10.0, ggfan-0.1.3, ggforce-0.4.1, ggformula-0.10.2, ggfun-0.0.9, ggh4x-0.2.3, ggnetwork-0.5.12, ggplot2-3.4.1, ggplotify-0.1.0, ggpubr-0.6.0, ggraph-2.1.0, ggrepel-0.9.3, ggridges-0.5.4, ggsci-3.0.0, ggsignif-0.6.4, ggstance-0.3.6, ggvenn-0.1.9, ggvis-0.4.8, gh-1.4.0, GillespieSSA-0.6.2, git2r-0.31.0, gitcreds-0.1.2, GJRM-0.2-6.1, glasso-1.11, gld-2.6.6, gllvm-1.4.1, glmmML-1.1.4, glmmTMB-1.1.5, glmnet-4.1-6, GlobalOptions-0.1.2, globals-0.16.2, glue-1.6.2, gmm-1.7, gmodels-2.18.1.1, gmp-0.7-1, gnumeric-0.7-8, goftest-1.2-3, gomms-1.0, googledrive-2.0.0, googlesheets4-1.0.1, gower-1.0.1, GPArotation-2022.10-2, gplots-3.1.3, graphics, graphlayouts-0.8.4, grDevices, grf-2.2.1, grid, gridBase-0.4-7, gridExtra-2.3, gridGraphics-0.5-1, grImport2-0.2-0, grpreg-3.4.0, GSA-1.03.2, gsalib-2.2.1, gsl-2.1-8, gsw-1.1-1, gt-0.8.0, gtable-0.3.1, gtools-3.9.4, gtsummary-1.7.0, GUTS-1.2.3, gWidgets2-1.0-9, gWidgets2tcltk-1.0-8, GxEScanR-2.0.2, h2o-3.40.0.1, hal9001-0.4.3, haldensify-0.2.3, hardhat-1.2.0, harmony-0.1.1, hash-2.2.6.2, haven-2.5.2, hdf5r-1.3.8, hdm-0.3.1, heatmap3-1.1.9, here-1.0.1, hexbin-1.28.2, HGNChelper-0.8.1, HiddenMarkov-1.8-13, highr-0.10, Hmisc-5.0-1, hms-1.1.2, Hmsc-3.0-13, htmlTable-2.4.1, htmltools-0.5.4, htmlwidgets-1.6.1, httpcode-0.3.0, httpuv-1.6.9, httr-1.4.5, httr2-0.2.2, huge-1.3.5, hunspell-3.0.2, hwriter-1.3.2.1, HWxtest-1.1.9, hypergeo-1.2-13, ica-1.0-3, IDPmisc-1.1.20, idr-1.3, ids-1.0.1, ie2misc-0.9.0, igraph-1.4.1, image.binarization-0.1.3, imager-0.42.18, imagerExtra-1.3.2, ineq-0.2-13, influenceR-0.1.0.1, infotheo-1.2.0.1, ini-0.3.1, inline-0.3.19, intergraph-2.0-2, interp-1.1-3, interpretR-0.2.4, intrinsicDimension-1.2.0, inum-1.0-5, ipred-0.9-14, irace-3.5, irlba-2.3.5.1, ismev-1.42, Iso-0.0-18.1, isoband-0.2.7, ISOcodes-2022.09.29, ISOweek-0.6-2, iterators-1.0.14, itertools-0.1-3, JADE-2.0-3, janeaustenr-1.0.0, JBTools-0.7.2.9, jiebaR-0.11, jiebaRD-0.1, jomo-2.7-4, jpeg-0.1-10, jqr-1.3.1, jquerylib-0.1.4, jsonify-1.2.2, jsonlite-1.8.4, jstable-1.0.7, juicyjuice-0.1.0, kde1d-1.0.5, kedd-1.0.3, kernlab-0.9-32, KernSmooth-2.23-20, kinship2-1.9.6, klaR-1.7-1, knitr-1.42, KODAMA-2.4, kohonen-3.0.11, ks-1.14.0, labdsv-2.0-1, labeling-0.4.2, labelled-2.10.0, laeken-0.5.2, lambda.r-1.2.4, LaplacesDemon-16.1.6, lars-1.3, lassosum-0.4.5, later-1.3.0, lattice-0.20-45, latticeExtra-0.6-30, lava-1.7.2.1, lavaan-0.6-15, lazy-1.2-18, lazyeval-0.2.2, LCFdata-2.0, lda-1.4.2, ldbounds-2.0.0, leafem-0.2.0, leaflet-2.1.2, leaflet.providers-1.9.0, leafsync-0.1.0, leaps-3.1, LearnBayes-2.15.1, leiden-0.4.3, lhs-1.1.6, libcoin-1.0-9, lifecycle-1.0.3, limSolve-1.5.6, linkcomm-1.0-14, linprog-0.9-4, liquidSVM-1.2.4, listenv-0.9.0, lme4-1.1-32, LMERConvenienceFunctions-3.0, lmerTest-3.1-3, lmom-2.9, Lmoments-1.3-1, lmtest-0.9-40, lobstr-1.1.2, locfdr-1.1-8, locfit-1.5-9.7, logcondens-2.1.7, logger-0.2.2, logistf-1.24.1, logspline-2.1.19, longitudinal-1.1.13, longmemo-1.1-2, loo-2.5.1, lpSolve-5.6.18, lpSolveAPI-5.5.2.0-17.9, lqa-1.0-3, lsei-1.3-0, lslx-0.6.11, lubridate-1.9.2, lwgeom-0.2-11, magic-1.6-1, magick-2.7.4, magrittr-2.0.3, MALDIquant-1.22, manipulateWidget-0.11.1, mapproj-1.2.11, maps-3.4.1, maptools-1.1-6, markdown-1.5, MASS-7.3-58.3, Matching-4.10-8, MatchIt-4.5.1, mathjaxr-1.6-0, matlab-1.0.4, Matrix-1.5-3, matrixcalc-1.0-6, MatrixModels-0.5-1, matrixStats-0.63.0, maxLik-1.5-2, maxlike-0.1-9, maxnet-0.1.4, mboost-2.9-7, mclogit-0.9.6, mclust-6.0.0, mcmc-0.9-7, MCMCpack-1.6-3, mcmcse-1.5-0, mda-0.5-3, medflex-0.6-7, mediation-4.5.0, memisc-0.99.31.6, memoise-2.0.1, memuse-4.2-3, MESS-0.5.9, metadat-1.2-0, metafor-3.8-1, MetaUtility-2.1.2, methods, mets-1.3.2, mgcv-1.8-42, mgsub-1.7.3, mhsmm-0.4.16, mi-1.1, mice-3.15.0, miceadds-3.16-18, microbenchmark-1.4.9, MIIVsem-0.5.8, mime-0.12, minerva-1.5.10, miniUI-0.1.1.1, minpack.lm-1.2-3, minqa-1.2.5, mirt-1.38.1, misc3d-0.9-1, miscTools-0.6-26, missForest-1.5, mitml-0.4-5, mitools-2.4, mixtools-2.0.0, mlbench-2.1-3, mlegp-3.1.9, MLmetrics-1.1.1, mlogit-1.1-1, mlr-2.19.1, mlrMBO-1.1.5.1, mltools-0.3.5, mnormt-2.1.1, ModelMetrics-1.2.2.2, modelr-0.1.10, modeltools-0.2-23, MODIStsp-2.1.0, momentfit-0.3, moments-0.14.1, MonteCarlo-1.0.6, mosaicCore-0.9.2.1, mpath-0.4-2.23, mRMRe-2.1.2, msm-1.7, mstate-0.3.2, multcomp-1.4-23, multcompView-0.1-8, multicool-0.1-12, multipol-1.0-7, munsell-0.5.0, mvabund-4.2.1, mvnfast-0.2.8, mvtnorm-1.1-3, nabor-0.5.0, naniar-1.0.0, natserv-1.0.0, naturalsort-0.1.3, ncbit-2013.03.29.1, ncdf4-1.21, NCmisc-1.2.0, network-1.18.1, networkDynamic-0.11.3, networkLite-1.0.5, neuralnet-1.44.2, neuRosim-0.2-13, ngspatial-1.2-2, NISTunits-1.0.1, nleqslv-3.3.4, nlme-3.1-162, nloptr-2.0.3, NLP-0.2-1, nlsem-0.8, nnet-7.3-18, nnls-1.4, nonnest2-0.5-5, nor1mix-1.3-0, norm-1.0-10.0, nortest-1.0-4, np-0.60-17, npsurv-0.5-0, numDeriv-2016.8-1.1, oai-0.4.0, oce-1.7-10, OceanView-1.0.6, oddsratio-2.0.1, officer-0.6.2, openair-2.16-0, OpenMx-2.21.1, openssl-2.0.6, openxlsx-4.2.5.2, operator.tools-1.6.3, optextras-2019-12.4, optimParallel-1.0-2, optimr-2019-12.16, optimx-2022-4.30, optmatch-0.10.6, optparse-1.7.3, ordinal-2022.11-16, origami-1.0.7, oro.nifti-0.11.4, orthopolynom-1.0-6.1, osqp-0.6.0.8, outliers-0.15, packrat-0.9.1, pacman-0.5.1, pammtools-0.5.8, pamr-1.56.1, pan-1.6, parallel, parallelDist-0.2.6, parallelly-1.34.0, parallelMap-1.5.1, ParamHelpers-1.14.1, parsedate-1.3.1, party-1.3-13, partykit-1.2-18, pastecs-1.3.21, patchwork-1.1.2, pbapply-1.7-0, pbivnorm-0.6.0, pbkrtest-0.5.2, PCAmatchR-0.3.3, pcaPP-2.0-3, pdp-0.8.1, PearsonDS-1.2.3, pec-2022.05.04, penalized-0.9-52, penfa-0.1.1, peperr-1.4, PermAlgo-1.2, permute-0.9-7, phangorn-2.11.1, pheatmap-1.0.12, phylobase-0.8.10, phytools-1.5-1, pillar-1.8.1, pim-2.0.2, pinfsc50-1.2.0, pixmap-0.4-12, pkgbuild-1.4.0, pkgconfig-2.0.3, pkgdown-2.0.7, pkgload-1.3.2, pkgmaker-0.32.8, plogr-0.2.0, plot3D-1.4, plot3Drgl-1.0.4, plotly-4.10.1, plotmo-3.6.2, plotrix-3.8-2, pls-2.8-1, plyr-1.8.8, PMA-1.2.1, png-0.1-8, PoissonSeq-1.1.2, poLCA-1.6.0.1, polspline-1.1.22, Polychrome-1.5.1, polyclip-1.10-4, polycor-0.8-1, polynom-1.4-1, posterior-1.4.1, ppcor-1.1, prabclus-2.3-2, pracma-2.4.2, praise-1.0.0, PresenceAbsence-1.1.11, preseqR-4.0.0, prettyGraphs-2.1.6, prettyunits-1.1.1, princurve-2.1.6, pROC-1.18.0, processx-3.8.0, prodlim-2019.11.13, profileModel-0.6.1, proftools-0.99-3, profvis-0.3.7, progress-1.2.2, progressr-0.13.0, projpred-2.4.0, promises-1.2.0.1, proto-1.0.0, protolite-2.3.0, proxy-0.4-27, proxyC-0.3.3, pryr-0.1.6, ps-1.7.2, pscl-1.5.5, pspline-1.0-19, psych-2.2.9, Publish-2023.01.17, pulsar-0.3.10, purrr-1.0.1, pvclust-2.2-0, qgam-1.3.4, qgraph-1.9.3, qqman-0.1.8, qrnn-2.0.5, quadprog-1.5-8, quanteda-3.3.0, quantmod-0.4.20, quantreg-5.94, questionr-0.7.8, R.cache-0.16.0, R.matlab-3.7.0, R.methodsS3-1.8.2, R.oo-1.25.0, R.rsp-0.45.0, R.utils-2.12.2, R2WinBUGS-2.1-21, R6-2.5.1, ragg-1.2.5, random-0.2.6, randomForest-4.7-1.1, randomForestSRC-3.2.1, randtoolbox-2.0.4, rangeModelMetadata-0.1.4, ranger-0.14.1, RANN-2.6.1, rapidjsonr-1.2.0, rappdirs-0.3.3, rARPACK-0.11-0, raster-3.6-20, rasterVis-0.51.5, ratelimitr-0.4.1, RBesT-1.6-6, rbibutils-2.2.13, rbison-1.0.0, Rborist-0.3-2, RCAL-2.0, Rcgmin-2022-4.30, RCircos-1.2.2, rcmdcheck-1.4.0, RColorBrewer-1.1-3, Rcpp-1.0.10, RcppArmadillo-0.12.0.1.0, RcppEigen-0.3.3.9.3, RcppGSL-0.3.13, RcppParallel-5.1.7, RcppProgress-0.4.2, RcppRoll-0.3.0, RcppThread-2.1.3, RcppTOML-0.2.2, RCurl-1.98-1.10, rda-1.2-1, Rdpack-2.4, rdrop2-0.8.2.1, readbitmap-0.1.5, reader-1.0.6, readODS-1.8.0, readr-2.1.4, readxl-1.4.2, rebird-1.3.0, recipes-1.0.5, RefFreeEWAS-2.2, registry-0.5-1, regsem-1.9.3, relsurv-2.2-9, rematch-1.0.1, rematch2-2.1.2, remotes-2.4.2, rentrez-1.2.3, renv-0.17.1, reprex-2.0.2, resample-0.6, reshape-0.8.9, reshape2-1.4.4, reticulate-1.28, rex-1.2.1, rgbif-3.7.5, RGCCA-2.1.2, rgdal-1.6-5, rgeos-0.6-2, rgexf-0.16.2, rgl-1.0.1, Rglpk-0.6-4, RhpcBLASctl-0.23-42, ridge-3.3, ridigbio-0.3.6, RInside-0.2.18, rio-0.5.29, riskRegression-2022.11.28, ritis-1.0.0, RItools-0.3-3, rJava-1.0-6, rjson-0.2.21, RJSONIO-1.3-1.8, rlang-1.1.0, rle-0.9.2, rlecuyer-0.3-5, rlemon-0.2.1, rlist-0.4.6.2, rmarkdown-2.20, rmeta-3.0, Rmpfr-0.9-1, rms-6.5-0, RMTstat-0.3.1, rncl-0.8.7, rnetcarto-0.2.6, RNeXML-2.4.11, rngtools-1.5.2, rngWELL-0.10-9, RNifti-1.4.5, robustbase-0.95-0, ROCR-1.0-11, ROI-1.0-0, ROI.plugin.glpk-1.0-0, Rook-1.2, rootSolve-1.8.2.3, roptim-0.1.6, rotl-3.0.14, roxygen2-7.2.3, rpact-3.3.4, rpart-4.1.19, rpf-1.0.11, RPMM-1.25, rprojroot-2.0.3, rrcov-1.7-2, rredlist-0.7.1, rsample-1.1.1, rsconnect-0.8.29, Rserve-1.8-11, RSNNS-0.4-15, Rsolnp-1.16, RSpectra-0.16-1, RSQLite-2.3.0, Rssa-1.0.5, rstan-2.21.8, rstantools-2.3.0, rstatix-0.7.2, rstudioapi-0.14, rtdists-0.11-5, Rtsne-0.16, Rttf2pt1-1.3.12, RUnit-0.4.32, ruv-0.9.7.1, rversions-2.1.2, rvertnet-0.8.2, rvest-1.0.3, rvinecopulib-0.6.3.1.1, Rvmmin-2018-4.17.1, RWeka-0.4-46, RWekajars-3.9.3-2, s2-1.1.2, sampling-2.9, sandwich-3.0-2, sass-0.4.5, SBdecomp-1.2, scales-1.2.1, scam-1.2-13, scatterpie-0.1.8, scatterplot3d-0.3-43, scs-3.2.4, sctransform-0.3.5, SDMTools-1.1-221.2, seewave-2.2.0, segmented-1.6-2, selectr-0.4-2, sem-3.1-15, semPLS-1.0-10, semTools-0.5-6, sendmailR-1.4-0, sensemakr-0.1.4, sentometrics-1.0.0, seqinr-4.2-23, servr-0.25, sessioninfo-1.2.2, setRNG-2022.4-1, sf-1.0-11, sfheaders-0.4.2, sfsmisc-1.1-14, shadowtext-0.1.2, shape-1.4.6, shapefiles-0.7.2, shiny-1.7.4, shinycssloaders-1.0.0, shinydashboard-0.7.2, shinyjs-2.1.0, shinystan-2.6.0, shinythemes-1.2.0, signal-0.7-7, SignifReg-4.3, simex-1.8, SimSeq-1.4.0, SKAT-2.2.5, slam-0.1-50, slider-0.3.0, sm-2.2-5.7.1, smoof-1.6.0.3, smoother-1.1, sn-2.1.0, sna-2.7-1, SNFtool-2.3.1, snow-0.4-4, SnowballC-0.7.0, snowfall-1.84-6.2, SOAR-0.99-11, solrium-1.2.0, som-0.3-5.1, soundecology-1.3.3, sourcetools-0.1.7-1, sp-1.6-0, spaa-0.2.2, spam-2.9-1, spaMM-4.2.1, SparseM-1.81, SPAtest-3.1.2, spatial-7.3-16, spatstat-3.0-3, spatstat.core-2.4-4, spatstat.data-3.0-1, spatstat.explore-3.1-0, spatstat.geom-3.1-0, spatstat.linnet-3.0-6, spatstat.model-3.2-1, spatstat.random-3.1-4, spatstat.sparse-3.0-1, spatstat.utils-3.0-2, spData-2.2.2, splines, splitstackshape-1.4.8, spls-2.2-3, spocc-1.2.1, spThin-0.2.0, SQUAREM-2021.1, stabledist-0.7-1, stabs-0.6-4, StanHeaders-2.21.0-7, stargazer-5.2.3, stars-0.6-0, startupmsg-0.9.6, StatMatch-1.4.1, statmod-1.5.0, statnet-2019.6, statnet.common-4.8.0, stats, stats4, stdReg-3.4.1, stopwords-2.3, stringdist-0.9.10, stringi-1.7.12, stringr-1.5.0, strucchange-1.5-3, styler-1.9.1, subplex-1.8, SuperLearner-2.0-28, SuppDists-1.1-9.7, survey-4.1-1, survival-3.5-5, survivalROC-1.0.3.1, svd-0.5.3, svglite-2.1.1, swagger-3.33.1, symmoments-1.2.1, sys-3.4.1, systemfonts-1.0.4, tableone-0.13.2, tabletools-0.1.0, tau-0.0-24, taxize-0.9.100, tcltk, tcltk2-1.2-11, tclust-1.5-2, TeachingDemos-2.12, tensor-1.5, tensorA-0.36.2, tergm-4.1.1, terra-1.7-18, testit-0.13, testthat-3.1.7, textcat-1.0-8, textplot-0.2.2, textshaping-0.3.6, TFisher-0.2.0, TH.data-1.1-1, threejs-0.3.3, tibble-3.2.0, tictoc-1.1, tidygraph-1.2.3, tidyr-1.3.0, tidyselect-1.2.0, tidytext-0.4.1, tidytree-0.4.2, tidyverse-2.0.0, tiff-0.1-11, timechange-0.2.0, timeDate-4022.108, timereg-2.0.5, tinytex-0.44, tkrplot-0.0-27, tm-0.7-11, tmap-3.3-3, tmaptools-3.1-1, TMB-1.9.2, tmle-1.5.0.2, tmvnsim-1.0-2, tmvtnorm-1.5, tokenizers-0.3.0, tools, topicmodels-0.2-13, TraMineR-2.2-6, tree-1.0-43, triebeard-0.4.1, trimcluster-0.1-5, tripack-1.3-9.1, TruncatedNormal-2.2.2, truncnorm-1.0-8, trust-0.1-8, tseries-0.10-53, tseriesChaos-0.1-13.1, tsna-0.3.5, tsne-0.1-3.1, TTR-0.24.3, tuneR-1.4.3, twang-2.5, tweedie-2.3.5, tweenr-2.0.2, tzdb-0.3.0, ucminf-1.1-4.1, udpipe-0.8.11, umap-0.2.10.0, unbalanced-2.0, unikn-0.8.0, uniqueAtomMat-0.1-3-2, units-0.8-1, unmarked-1.2.5, UpSetR-1.4.0, urca-1.3-3, urlchecker-1.0.1, urltools-1.7.3, uroot-2.1-2, usethis-2.1.6, utf8-1.2.3, utils, uuid-1.1-0, V8-4.2.2, varhandle-2.0.5, vcd-1.4-11, vcfR-1.14.0, vctrs-0.6.0, vegan-2.6-4, VennDiagram-1.7.3, VGAM-1.1-8, VIM-6.2.2, VineCopula-2.4.5, vioplot-0.4.0, vipor-0.4.5, viridis-0.6.2, viridisLite-0.4.1, visdat-0.6.0, visNetwork-2.1.2, vroom-1.6.1, VSURF-1.2.0, waldo-0.4.0, warp-0.2.0, waveslim-1.8.4, wdm-0.2.3, webshot-0.5.4, webutils-1.1, weights-1.0.4, WeightSVM-1.7-11, wellknown-0.7.4, whisker-0.4.1, widgetframe-0.3.1, WikidataQueryServiceR-1.0.0, WikidataR-2.3.3, WikipediR-1.5.0, wikitaxa-0.4.0, withr-2.5.0, wk-0.7.1, word2vec-0.3.4, wordcloud-2.6, worrms-0.4.2, WriteXLS-6.4.0, xfun-0.37, xgboost-1.7.3.1, xlsx-0.6.5, xlsxjars-0.6.1, XML-3.99-0.13, xml2-1.3.3, xopen-1.0.0, xtable-1.8-4, xts-0.13.0, yaImpute-1.0-33, yaml-2.3.7, yulab.utils-0.0.6, zeallot-0.1.0, zip-2.2.2, zoo-1.8-11</p>"},{"location":"available_software/detail/RAxML/","title":"RAxML","text":"<p>RAxML search algorithm for maximum likelihood based inference of phylogenetic trees.</p> <p>https://github.com/stamatak/standard-RAxML</p>"},{"location":"available_software/detail/RAxML/#available-modules","title":"Available modules","text":"<p>The overview below shows which RAxML installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using RAxML, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load RAxML/8.2.13-gompi-2023a-standard\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 RAxML/8.2.13-gompi-2023a-standard x x x x - - - - - - - RAxML/8.2.13-gompi-2023a-avx2 - - - - x x x x x x x"},{"location":"available_software/detail/RE2/","title":"RE2","text":"<p>RE2 is a fast, safe, thread-friendly alternative to backtracking regularexpression engines like those used in PCRE, Perl, and Python. It is a C++library.</p> <p>https://github.com/google/re2</p>"},{"location":"available_software/detail/RE2/#available-modules","title":"Available modules","text":"<p>The overview below shows which RE2 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using RE2, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load RE2/2024-03-01-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 RE2/2024-03-01-GCCcore-13.2.0 x x x x x x x x x x x RE2/2023-08-01-GCCcore-12.3.0 x x x x x x x x x x x RE2/2023-03-01-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/ROOT/","title":"ROOT","text":"<p>The ROOT system provides a set of OO frameworks with all the functionality    needed to handle and analyze large amounts of data in a very efficient way.</p> <p>https://root.cern.ch</p>"},{"location":"available_software/detail/ROOT/#available-modules","title":"Available modules","text":"<p>The overview below shows which ROOT installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ROOT, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ROOT/6.30.06-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ROOT/6.30.06-foss-2023a x x x x x x x x x x x ROOT/6.26.10-foss-2022b x x x x x x x x x x x"},{"location":"available_software/detail/RapidJSON/","title":"RapidJSON","text":"<p>A fast JSON parser/generator for C++ with both SAX/DOM style API</p> <p>https://rapidjson.org</p>"},{"location":"available_software/detail/RapidJSON/#available-modules","title":"Available modules","text":"<p>The overview below shows which RapidJSON installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using RapidJSON, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load RapidJSON/1.1.0-GCCcore-12.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 RapidJSON/1.1.0-GCCcore-12.2.0 x x x x x x x x x x x RapidJSON/1.1.0-20240409-GCCcore-13.2.0 x x x x x x x x x x x RapidJSON/1.1.0-20230928-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Raptor/","title":"Raptor","text":"<p>Set of parsers and serializers that generate Resource Description Framework(RDF) triples by parsing syntaxes or serialize the triples into a syntax.</p> <p>https://librdf.org/raptor/</p>"},{"location":"available_software/detail/Raptor/#available-modules","title":"Available modules","text":"<p>The overview below shows which Raptor installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Raptor, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Raptor/2.0.16-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Raptor/2.0.16-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Rasqal/","title":"Rasqal","text":"<p>A library handling RDF query syntaxes, construction and execution</p> <p>hhttps://librdf.org/rasqal</p>"},{"location":"available_software/detail/Rasqal/#available-modules","title":"Available modules","text":"<p>The overview below shows which Rasqal installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Rasqal, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Rasqal/0.9.33-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Rasqal/0.9.33-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/ReFrame/","title":"ReFrame","text":"<p>ReFrame is a framework for writing regression tests for HPC systems.</p> <p>https://github.com/reframe-hpc/reframe</p>"},{"location":"available_software/detail/ReFrame/#available-modules","title":"Available modules","text":"<p>The overview below shows which ReFrame installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ReFrame, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ReFrame/4.6.2\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ReFrame/4.6.2 x x x x x x x x x x x ReFrame/4.3.3 x x x x x x x x x x x"},{"location":"available_software/detail/ReFrame/#reframe462","title":"ReFrame/4.6.2","text":"<p>This is a list of extensions included in the module:</p> <p>pip-24.0, reframe-4.6.2, setuptools-68.0.0, wheel-0.42.0</p>"},{"location":"available_software/detail/ReFrame/#reframe433","title":"ReFrame/4.3.3","text":"<p>This is a list of extensions included in the module:</p> <p>pip-21.3.1, reframe-4.3.3, wheel-0.37.1</p>"},{"location":"available_software/detail/Redland/","title":"Redland","text":"<p>Redland is a set of free software C libraries that provide support for the Resource Description Framework (RDF).</p> <p>https://librdf.org/raptor</p>"},{"location":"available_software/detail/Redland/#available-modules","title":"Available modules","text":"<p>The overview below shows which Redland installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Redland, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Redland/1.0.17-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Redland/1.0.17-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Rivet/","title":"Rivet","text":"<p>Rivet toolkit (Robust Independent Validation of Experiment and Theory)To use your own analysis you must append the path to <code>RIVET_ANALYSIS_PATH</code>.</p> <p>https://gitlab.com/hepcedar/rivet</p>"},{"location":"available_software/detail/Rivet/#available-modules","title":"Available modules","text":"<p>The overview below shows which Rivet installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Rivet, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Rivet/3.1.9-gompi-2023a-HepMC3-3.2.6\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Rivet/3.1.9-gompi-2023a-HepMC3-3.2.6 x x x x x x x x x x x"},{"location":"available_software/detail/Ruby/","title":"Ruby","text":"<p>Ruby is a dynamic, open source programming language with a focus on simplicity and productivity. It has an elegant syntax that is natural to read and easy to write.</p> <p>https://www.ruby-lang.org</p>"},{"location":"available_software/detail/Ruby/#available-modules","title":"Available modules","text":"<p>The overview below shows which Ruby installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Ruby, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Ruby/3.3.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Ruby/3.3.0-GCCcore-12.3.0 x x x x x x x x x x x Ruby/3.2.2-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Ruby/#ruby322-gcccore-1220","title":"Ruby/3.2.2-GCCcore-12.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>activesupport-5.2.8.1, addressable-2.8.4, arr-pm-0.0.12, backports-3.24.1, bundler-2.4.14, cabin-0.9.0, childprocess-4.1.0, clamp-1.3.2, concurrent-ruby-1.2.2, connection_pool-2.4.1, diff-lcs-1.5.0, ethon-0.16.0, faraday-1.2.0, faraday-net_http-3.0.2, faraday_middleware-1.2.0, ffi-1.15.5, gh-0.18.0, highline-2.1.0, i18n-1.14.1, json-2.6.3, launchy-2.5.2, minitest-5.18.0, multi_json-1.15.0, multipart-post-2.3.0, mustermann-3.0.0, net-http-persistent-2.9.4, net-http-pipeline-1.0.1, public_suffix-5.0.1, pusher-client-0.6.2, rack-2.2.4, rack-protection-3.0.6, rack-test-2.1.0, rspec-3.12.0, rspec-core-3.12.2, rspec-expectations-3.12.3, rspec-mocks-3.12.5, rspec-support-3.12.0, ruby2_keywords-0.0.5, sinatra-3.0.6, thread_safe-0.3.6, tilt-2.2.0, typhoeus-1.4.0, tzinfo-1.1.0, websocket-1.2.9, zeitwerk-2.6.8</p>"},{"location":"available_software/detail/Rust/","title":"Rust","text":"<p>Rust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.</p> <p>https://www.rust-lang.org</p>"},{"location":"available_software/detail/Rust/#available-modules","title":"Available modules","text":"<p>The overview below shows which Rust installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Rust, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Rust/1.76.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Rust/1.76.0-GCCcore-13.2.0 x x x x x x x x x x x Rust/1.75.0-GCCcore-12.3.0 x x x x x x x x x x x Rust/1.73.0-GCCcore-13.2.0 x x x x x x x x x x x Rust/1.70.0-GCCcore-12.3.0 x x x x x x x x x x x Rust/1.65.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/SAMtools/","title":"SAMtools","text":"<p>SAM Tools provide various utilities for manipulating alignments in the SAM format,  including sorting, merging, indexing and generating alignments in a per-position format.</p> <p>https://www.htslib.org/</p>"},{"location":"available_software/detail/SAMtools/#available-modules","title":"Available modules","text":"<p>The overview below shows which SAMtools installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using SAMtools, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load SAMtools/1.18-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 SAMtools/1.18-GCC-12.3.0 x x x x x x x x x x x SAMtools/1.17-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/SCOTCH/","title":"SCOTCH","text":"<p>Software package and libraries for sequential and parallel graph partitioning,static mapping, and sparse matrix block ordering, and sequential mesh and hypergraph partitioning.</p> <p>https://www.labri.fr/perso/pelegrin/scotch/</p>"},{"location":"available_software/detail/SCOTCH/#available-modules","title":"Available modules","text":"<p>The overview below shows which SCOTCH installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using SCOTCH, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load SCOTCH/7.0.3-gompi-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 SCOTCH/7.0.3-gompi-2023a x x x x x x x x x x x SCOTCH/7.0.3-gompi-2022b x x x x x x x x x x x"},{"location":"available_software/detail/SDL2/","title":"SDL2","text":"<p>SDL: Simple DirectMedia Layer, a cross-platform multimedia library</p> <p>https://www.libsdl.org/</p>"},{"location":"available_software/detail/SDL2/#available-modules","title":"Available modules","text":"<p>The overview below shows which SDL2 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using SDL2, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load SDL2/2.28.5-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 SDL2/2.28.5-GCCcore-13.2.0 x x x x x x x x x x x SDL2/2.28.2-GCCcore-12.3.0 x x x x x x x x x x x SDL2/2.26.3-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/SEPP/","title":"SEPP","text":"<p>SATe-enabled Phylogenetic Placement - addresses the problem of phylogeneticplacement of short reads into reference alignments and trees.</p> <p>https://github.com/smirarab/sepp</p>"},{"location":"available_software/detail/SEPP/#available-modules","title":"Available modules","text":"<p>The overview below shows which SEPP installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using SEPP, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load SEPP/4.5.1-foss-2022b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 SEPP/4.5.1-foss-2022b x x x x x x x x x x x"},{"location":"available_software/detail/SIONlib/","title":"SIONlib","text":"<p>SIONlib is a scalable I/O library for parallel access to task-local files. The library not only supports writing and reading binary data to or from several thousands of processors into a single or a small number of physical files, but also provides global open and close functions to access SIONlib files in parallel. This package provides a stripped-down installation of SIONlib for use with performance tools (e.g., Score-P), with renamed symbols to avoid conflicts when an application using SIONlib itself is linked against a tool requiring a different SIONlib version.</p> <p>https://www.fz-juelich.de/ias/jsc/EN/Expertise/Support/Software/SIONlib/_node.html</p>"},{"location":"available_software/detail/SIONlib/#available-modules","title":"Available modules","text":"<p>The overview below shows which SIONlib installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using SIONlib, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load SIONlib/1.7.7-GCCcore-13.2.0-tools\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 SIONlib/1.7.7-GCCcore-13.2.0-tools x x x x x x x x x x x"},{"location":"available_software/detail/SIP/","title":"SIP","text":"<p>SIP is a tool that makes it very easy to create Python bindings for C and C++ libraries.</p> <p>http://www.riverbankcomputing.com/software/sip/</p>"},{"location":"available_software/detail/SIP/#available-modules","title":"Available modules","text":"<p>The overview below shows which SIP installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using SIP, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load SIP/6.8.1-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 SIP/6.8.1-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/SLEPc/","title":"SLEPc","text":"<p>SLEPc (Scalable Library for Eigenvalue Problem Computations) is a software library for the solution of large scale sparse eigenvalue problems on parallel computers. It is an extension of PETSc and can be used for either standard or generalized eigenproblems, with real or complex arithmetic. It can also be used for computing a partial SVD of a large, sparse, rectangular matrix, and to solve quadratic eigenvalue problems.</p> <p>https://slepc.upv.es</p>"},{"location":"available_software/detail/SLEPc/#available-modules","title":"Available modules","text":"<p>The overview below shows which SLEPc installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using SLEPc, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load SLEPc/3.20.1-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 SLEPc/3.20.1-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/SQLAlchemy/","title":"SQLAlchemy","text":"<p>SQLAlchemy is the Python SQL toolkit and Object Relational Mapper that givesapplication developers the full power and flexibility of SQL. SQLAlchemyprovides a full suite of well known enterprise-level persistence patterns,designed for efficient and high-performing database access, adapted into asimple and Pythonic domain language.</p> <p>https://www.sqlalchemy.org/</p>"},{"location":"available_software/detail/SQLAlchemy/#available-modules","title":"Available modules","text":"<p>The overview below shows which SQLAlchemy installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using SQLAlchemy, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load SQLAlchemy/2.0.25-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 SQLAlchemy/2.0.25-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/SQLAlchemy/#sqlalchemy2025-gcccore-1230","title":"SQLAlchemy/2.0.25-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>alembic-1.13.1, async-timeout-4.0.3, asyncpg-0.29.0, greenlet-3.0.3, SQLAlchemy-2.0.25</p>"},{"location":"available_software/detail/SQLite/","title":"SQLite","text":"<p>SQLite: SQL Database Engine in a C Library</p> <p>https://www.sqlite.org/</p>"},{"location":"available_software/detail/SQLite/#available-modules","title":"Available modules","text":"<p>The overview below shows which SQLite installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using SQLite, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load SQLite/3.43.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 SQLite/3.43.1-GCCcore-13.2.0 x x x x x x x x x x x SQLite/3.42.0-GCCcore-12.3.0 x x x x x x x x x x x SQLite/3.39.4-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/STAR/","title":"STAR","text":"<p>STAR aligns RNA-seq reads to a reference genome using uncompressed suffix arrays.</p> <p>https://github.com/alexdobin/STAR</p>"},{"location":"available_software/detail/STAR/#available-modules","title":"Available modules","text":"<p>The overview below shows which STAR installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using STAR, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load STAR/2.7.11b-GCC-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 STAR/2.7.11b-GCC-13.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/SWIG/","title":"SWIG","text":"<p>SWIG is a software development tool that connects programs written in C and C++ with a variety of high-level programming languages.</p> <p>http://www.swig.org/</p>"},{"location":"available_software/detail/SWIG/#available-modules","title":"Available modules","text":"<p>The overview below shows which SWIG installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using SWIG, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load SWIG/4.1.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 SWIG/4.1.1-GCCcore-13.2.0 x x x x x x x x x x x SWIG/4.1.1-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/ScaFaCoS/","title":"ScaFaCoS","text":"<p>ScaFaCoS is a library of scalable fast coulomb solvers.</p> <p>http://www.scafacos.de/</p>"},{"location":"available_software/detail/ScaFaCoS/#available-modules","title":"Available modules","text":"<p>The overview below shows which ScaFaCoS installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ScaFaCoS, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ScaFaCoS/1.0.4-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ScaFaCoS/1.0.4-foss-2023b - - - - x x x x x x x ScaFaCoS/1.0.4-foss-2023a - - - - x x x x x x x"},{"location":"available_software/detail/ScaLAPACK/","title":"ScaLAPACK","text":"<p>The ScaLAPACK (or Scalable LAPACK) library includes a subset of LAPACK routines redesigned for distributed memory MIMD parallel computers.</p> <p>https://www.netlib.org/scalapack/</p>"},{"location":"available_software/detail/ScaLAPACK/#available-modules","title":"Available modules","text":"<p>The overview below shows which ScaLAPACK installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ScaLAPACK, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ScaLAPACK/2.2.0-gompi-2023b-fb\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ScaLAPACK/2.2.0-gompi-2023b-fb x x x x x x x x x x x ScaLAPACK/2.2.0-gompi-2023a-fb x x x x x x x x x x x ScaLAPACK/2.2.0-gompi-2022b-fb x x x x x x x x x x x"},{"location":"available_software/detail/SciPy-bundle/","title":"SciPy-bundle","text":"<p>Bundle of Python packages for scientific software</p> <p>https://python.org/</p>"},{"location":"available_software/detail/SciPy-bundle/#available-modules","title":"Available modules","text":"<p>The overview below shows which SciPy-bundle installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using SciPy-bundle, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load SciPy-bundle/2023.11-gfbf-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 SciPy-bundle/2023.11-gfbf-2023b x x x x x x x x x x x SciPy-bundle/2023.07-gfbf-2023a x x x x x x x x x x x SciPy-bundle/2023.02-gfbf-2022b x x x x x x x x x x x"},{"location":"available_software/detail/SciPy-bundle/#scipy-bundle202311-gfbf-2023b","title":"SciPy-bundle/2023.11-gfbf-2023b","text":"<p>This is a list of extensions included in the module:</p> <p>beniget-0.4.1, Bottleneck-1.3.7, deap-1.4.1, gast-0.5.4, mpmath-1.3.0, numexpr-2.8.7, numpy-1.26.2, pandas-2.1.3, ply-3.11, pythran-0.14.0, scipy-1.11.4, tzdata-2023.3, versioneer-0.29</p>"},{"location":"available_software/detail/SciPy-bundle/#scipy-bundle202307-gfbf-2023a","title":"SciPy-bundle/2023.07-gfbf-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>beniget-0.4.1, Bottleneck-1.3.7, deap-1.4.0, gast-0.5.4, mpmath-1.3.0, numexpr-2.8.4, numpy-1.25.1, pandas-2.0.3, ply-3.11, pythran-0.13.1, scipy-1.11.1, tzdata-2023.3, versioneer-0.29</p>"},{"location":"available_software/detail/SciPy-bundle/#scipy-bundle202302-gfbf-2022b","title":"SciPy-bundle/2023.02-gfbf-2022b","text":"<p>This is a list of extensions included in the module:</p> <p>beniget-0.4.1, Bottleneck-1.3.5, deap-1.3.3, gast-0.5.3, mpmath-1.2.1, numexpr-2.8.4, numpy-1.24.2, pandas-1.5.3, ply-3.11, pythran-0.12.1, scipy-1.10.1</p>"},{"location":"available_software/detail/SciTools-Iris/","title":"SciTools-Iris","text":"<p>A powerful, format-agnostic, community-driven Python package for analysing andvisualising Earth science data.</p> <p>https://scitools-iris.readthedocs.io</p>"},{"location":"available_software/detail/SciTools-Iris/#available-modules","title":"Available modules","text":"<p>The overview below shows which SciTools-Iris installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using SciTools-Iris, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load SciTools-Iris/3.9.0-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 SciTools-Iris/3.9.0-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/SciTools-Iris/#scitools-iris390-foss-2023a","title":"SciTools-Iris/3.9.0-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>antlr4-python3-runtime-4.7.2, cf-units-3.2.0, scitools_iris-3.9.0</p>"},{"location":"available_software/detail/Score-P/","title":"Score-P","text":"<p>The Score-P measurement infrastructure is a highly scalable and easy-to-use tool suite for profiling, event tracing, and online analysis of HPC applications.</p> <p>https://www.score-p.org</p>"},{"location":"available_software/detail/Score-P/#available-modules","title":"Available modules","text":"<p>The overview below shows which Score-P installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Score-P, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Score-P/8.4-gompi-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Score-P/8.4-gompi-2023b x x x x x x x x x x x"},{"location":"available_software/detail/Seaborn/","title":"Seaborn","text":"<p>Seaborn is a Python visualization library based on matplotlib. It provides a high-level interface for drawing attractive statistical graphics.</p> <p>https://seaborn.pydata.org/</p>"},{"location":"available_software/detail/Seaborn/#available-modules","title":"Available modules","text":"<p>The overview below shows which Seaborn installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Seaborn, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Seaborn/0.13.2-gfbf-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Seaborn/0.13.2-gfbf-2023a x x x x x x x x x x x"},{"location":"available_software/detail/Shapely/","title":"Shapely","text":"<p>Shapely is a BSD-licensed Python package for manipulation and analysis of planar geometric objects.It is based on the widely deployed GEOS (the engine of PostGIS) and JTS (from which GEOS is ported) libraries.</p> <p>https://github.com/Toblerity/Shapely</p>"},{"location":"available_software/detail/Shapely/#available-modules","title":"Available modules","text":"<p>The overview below shows which Shapely installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Shapely, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Shapely/2.0.1-gfbf-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Shapely/2.0.1-gfbf-2023a x x x x x x x x x x x"},{"location":"available_software/detail/Siesta/","title":"Siesta","text":"<p>SIESTA is both a method and its computer program implementation, to perform efficient electronicstructure calculations and ab initio molecular dynamics simulations of molecules and solids.</p> <p>https://siesta-project.org/siesta/About/overview.html</p>"},{"location":"available_software/detail/Siesta/#available-modules","title":"Available modules","text":"<p>The overview below shows which Siesta installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Siesta, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Siesta/5.2.2-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Siesta/5.2.2-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/Simple-DFTD3/","title":"Simple-DFTD3","text":"<p>Reimplementation of the D3 dispersion correction. The s-dftd3 project aims toprovide a user-friendly and uniform interface to the D3 dispersion model andfor the calculation of DFT-D3 dispersion corrections.</p> <p>https://dftd3.readthedocs.io</p>"},{"location":"available_software/detail/Simple-DFTD3/#available-modules","title":"Available modules","text":"<p>The overview below shows which Simple-DFTD3 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Simple-DFTD3, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Simple-DFTD3/1.2.1-gfbf-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Simple-DFTD3/1.2.1-gfbf-2023a x x x x x x x x x x x"},{"location":"available_software/detail/SlurmViewer/","title":"SlurmViewer","text":"<p>View the status of a Slurm cluster, including nodes and queue.</p> <p>https://gitlab.com/lkeb/slurm_viewer</p>"},{"location":"available_software/detail/SlurmViewer/#available-modules","title":"Available modules","text":"<p>The overview below shows which SlurmViewer installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using SlurmViewer, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load SlurmViewer/1.0.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 SlurmViewer/1.0.1-GCCcore-13.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/SlurmViewer/#slurmviewer101-gcccore-1320","title":"SlurmViewer/1.0.1-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>asyncssh-2.18.0, plotext-5.2.8, slurm-viewer-1.0.1, textual-0.85.2, textual-plotext-0.2.1</p>"},{"location":"available_software/detail/Solids4foam/","title":"Solids4foam","text":"<p>A toolbox for performing solid mechanics and fluid-solid interactions in OpenFOAM.</p> <p>https://www.solids4foam.com/</p>"},{"location":"available_software/detail/Solids4foam/#available-modules","title":"Available modules","text":"<p>The overview below shows which Solids4foam installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Solids4foam, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Solids4foam/2.1-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Solids4foam/2.1-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/SuiteSparse/","title":"SuiteSparse","text":"<p>SuiteSparse is a collection of libraries to manipulate sparse matrices.</p> <p>https://faculty.cse.tamu.edu/davis/suitesparse.html</p>"},{"location":"available_software/detail/SuiteSparse/#available-modules","title":"Available modules","text":"<p>The overview below shows which SuiteSparse installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using SuiteSparse, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load SuiteSparse/7.1.0-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 SuiteSparse/7.1.0-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/SuperLU_DIST/","title":"SuperLU_DIST","text":"<p>SuperLU is a general purpose library for the direct solution of large, sparse, nonsymmetric systems of linear equations on high performance machines.</p> <p>https://crd-legacy.lbl.gov/~xiaoye/SuperLU/</p>"},{"location":"available_software/detail/SuperLU_DIST/#available-modules","title":"Available modules","text":"<p>The overview below shows which SuperLU_DIST installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using SuperLU_DIST, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load SuperLU_DIST/8.1.2-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 SuperLU_DIST/8.1.2-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/Szip/","title":"Szip","text":"<p>Szip compression software, providing lossless compression of scientific data</p> <p>https://www.hdfgroup.org/doc_resource/SZIP/</p>"},{"location":"available_software/detail/Szip/#available-modules","title":"Available modules","text":"<p>The overview below shows which Szip installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Szip, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Szip/2.1.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Szip/2.1.1-GCCcore-13.2.0 x x x x x x x x x x x Szip/2.1.1-GCCcore-12.3.0 x x x x x x x x x x x Szip/2.1.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/TOML-Fortran/","title":"TOML-Fortran","text":"<p>TOML parser for Fortran projects</p> <p>https://github.com/toml-f/toml-f</p>"},{"location":"available_software/detail/TOML-Fortran/#available-modules","title":"Available modules","text":"<p>The overview below shows which TOML-Fortran installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using TOML-Fortran, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load TOML-Fortran/0.4.2-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 TOML-Fortran/0.4.2-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Tcl/","title":"Tcl","text":"<p>Tcl (Tool Command Language) is a very powerful but easy to learn dynamic programming language, suitable for a very wide range of uses, including web and desktop applications, networking, administration, testing and many more.</p> <p>https://www.tcl.tk/</p>"},{"location":"available_software/detail/Tcl/#available-modules","title":"Available modules","text":"<p>The overview below shows which Tcl installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Tcl, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Tcl/8.6.13-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Tcl/8.6.13-GCCcore-13.2.0 x x x x x x x x x x x Tcl/8.6.13-GCCcore-12.3.0 x x x x x x x x x x x Tcl/8.6.12-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/TensorFlow/","title":"TensorFlow","text":"<p>An open-source software library for Machine Intelligence</p> <p>https://www.tensorflow.org/</p>"},{"location":"available_software/detail/TensorFlow/#available-modules","title":"Available modules","text":"<p>The overview below shows which TensorFlow installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using TensorFlow, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load TensorFlow/2.13.0-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 TensorFlow/2.13.0-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/TensorFlow/#tensorflow2130-foss-2023a","title":"TensorFlow/2.13.0-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>absl-py-1.4.0, astor-0.8.1, astunparse-1.6.3, cachetools-5.3.1, google-auth-2.22.0, google-auth-oauthlib-1.0.0, google-pasta-0.2.0, grpcio-1.57.0, gviz-api-1.10.0, keras-2.13.1, Markdown-3.4.4, oauthlib-3.2.2, opt-einsum-3.3.0, portpicker-1.5.2, pyasn1-modules-0.3.0, requests-oauthlib-1.3.1, rsa-4.9, tblib-2.0.0, tensorboard-2.13.0, tensorboard-data-server-0.7.1, tensorboard-plugin-profile-2.13.1, tensorboard-plugin-wit-1.8.1, TensorFlow-2.13.0, tensorflow-estimator-2.13.0, termcolor-2.3.0, Werkzeug-2.3.7, wrapt-1.15.0</p>"},{"location":"available_software/detail/Tk/","title":"Tk","text":"<p>Tk is an open source, cross-platform widget toolchain that provides a library of basic elements for building a graphical user interface (GUI) in many different programming languages.</p> <p>https://www.tcl.tk/</p>"},{"location":"available_software/detail/Tk/#available-modules","title":"Available modules","text":"<p>The overview below shows which Tk installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Tk, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Tk/8.6.13-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Tk/8.6.13-GCCcore-13.2.0 x x x x x x x x x x x Tk/8.6.13-GCCcore-12.3.0 x x x x x x x x x x x Tk/8.6.12-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Tkinter/","title":"Tkinter","text":"<p>Tkinter module, built with the Python buildsystem</p> <p>https://python.org/</p>"},{"location":"available_software/detail/Tkinter/#available-modules","title":"Available modules","text":"<p>The overview below shows which Tkinter installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Tkinter, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Tkinter/3.11.5-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Tkinter/3.11.5-GCCcore-13.2.0 x x x x x x x x x x x Tkinter/3.11.3-GCCcore-12.3.0 x x x x x x x x x x x Tkinter/3.10.8-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Tombo/","title":"Tombo","text":"<p>Tombo is a suite of tools primarily for the identification of modified nucleotides from raw nanopore sequencing data.</p> <p>https://github.com/nanoporetech/tombo</p>"},{"location":"available_software/detail/Tombo/#available-modules","title":"Available modules","text":"<p>The overview below shows which Tombo installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Tombo, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Tombo/1.5.1-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Tombo/1.5.1-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/Tombo/#tombo151-foss-2023a","title":"Tombo/1.5.1-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>mappy-2.28, ont-tombo-1.5.1, pyfaidx-0.5.8</p>"},{"location":"available_software/detail/Transrate/","title":"Transrate","text":"<p>Transrate is software for de-novo transcriptome assembly quality analysis. It examines your assembly in detail and compares it to experimental evidence such as the sequencing reads, reporting quality scores for contigs and assemblies. This allows you to choose between assemblers and parameters, filter out the bad contigs from an assembly, and help decide when to stop trying to improve the assembly.</p> <p>https://hibberdlab.com/transrate</p>"},{"location":"available_software/detail/Transrate/#available-modules","title":"Available modules","text":"<p>The overview below shows which Transrate installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Transrate, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Transrate/1.0.3-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Transrate/1.0.3-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/UCC/","title":"UCC","text":"<p>UCC (Unified Collective Communication) is a collectivecommunication operations API and library that is flexible, complete, and feature-rich for current and emerging programming models and runtimes.</p> <p>https://www.openucx.org/</p>"},{"location":"available_software/detail/UCC/#available-modules","title":"Available modules","text":"<p>The overview below shows which UCC installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using UCC, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load UCC/1.2.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 UCC/1.2.0-GCCcore-13.2.0 x x x x x x x x x x x UCC/1.2.0-GCCcore-12.3.0 x x x x x x x x x x x UCC/1.1.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/UCX/","title":"UCX","text":"<p>Unified Communication XAn open-source production grade communication framework for data centricand high-performance applications</p> <p>https://www.openucx.org/</p>"},{"location":"available_software/detail/UCX/#available-modules","title":"Available modules","text":"<p>The overview below shows which UCX installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using UCX, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load UCX/1.15.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 UCX/1.15.0-GCCcore-13.2.0 x x x x x x x x x x x UCX/1.14.1-GCCcore-12.3.0 x x x x x x x x x x x UCX/1.13.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/UDUNITS/","title":"UDUNITS","text":"<p>UDUNITS supports conversion of unit specifications between formatted and binary forms, arithmetic manipulation of units, and conversion of values between compatible scales of measurement.</p> <p>https://www.unidata.ucar.edu/software/udunits/</p>"},{"location":"available_software/detail/UDUNITS/#available-modules","title":"Available modules","text":"<p>The overview below shows which UDUNITS installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using UDUNITS, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load UDUNITS/2.2.28-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 UDUNITS/2.2.28-GCCcore-13.2.0 x x x x x x x x x x x UDUNITS/2.2.28-GCCcore-12.3.0 x x x x x x x x x x x UDUNITS/2.2.28-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/UnZip/","title":"UnZip","text":"<p>UnZip is an extraction utility for archives compressedin .zip format (also called \"zipfiles\"). Although highly compatible bothwith PKWARE's PKZIP and PKUNZIP utilities for MS-DOS and with Info-ZIP'sown Zip program, our primary objectives have been portability andnon-MSDOS functionality.</p> <p>http://www.info-zip.org/UnZip.html</p>"},{"location":"available_software/detail/UnZip/#available-modules","title":"Available modules","text":"<p>The overview below shows which UnZip installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using UnZip, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load UnZip/6.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 UnZip/6.0-GCCcore-13.2.0 x x x x x x x x x x x UnZip/6.0-GCCcore-12.3.0 x x x x x x x x x x x UnZip/6.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/VCFtools/","title":"VCFtools","text":"<p>The aim of VCFtools is to provide  easily accessible methods for working with complex  genetic variation data in the form of VCF files.</p> <p>https://vcftools.github.io</p>"},{"location":"available_software/detail/VCFtools/#available-modules","title":"Available modules","text":"<p>The overview below shows which VCFtools installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using VCFtools, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load VCFtools/0.1.16-GCC-12.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 VCFtools/0.1.16-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/VTK/","title":"VTK","text":"<p>The Visualization Toolkit (VTK) is an open-source, freely available software system for 3D computer graphics, image processing and visualization. VTK consists of a C++ class library and several interpreted interface layers including Tcl/Tk, Java, and Python. VTK supports a wide variety of visualization algorithms including: scalar, vector, tensor, texture, and volumetric methods; and advanced modeling techniques such as: implicit modeling, polygon reduction, mesh smoothing, cutting, contouring, and Delaunay triangulation.</p> <p>https://www.vtk.org</p>"},{"location":"available_software/detail/VTK/#available-modules","title":"Available modules","text":"<p>The overview below shows which VTK installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using VTK, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load VTK/9.3.0-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 VTK/9.3.0-foss-2023b x x x x x x x x x x x VTK/9.3.0-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/Valgrind/","title":"Valgrind","text":"<p>Valgrind: Debugging and profiling tools</p> <p>https://valgrind.org</p>"},{"location":"available_software/detail/Valgrind/#available-modules","title":"Available modules","text":"<p>The overview below shows which Valgrind installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Valgrind, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Valgrind/3.23.0-gompi-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Valgrind/3.23.0-gompi-2023b x x x x x x x x x x x Valgrind/3.21.0-gompi-2023a x x x x x x x x x x x Valgrind/3.21.0-gompi-2022b x x x x x x x x x x x"},{"location":"available_software/detail/Vim/","title":"Vim","text":"<p>Vim is an advanced text editor that seeks to provide the power  of the de-facto Unix editor 'Vi', with a more complete feature set.</p> <p>http://www.vim.org</p>"},{"location":"available_software/detail/Vim/#available-modules","title":"Available modules","text":"<p>The overview below shows which Vim installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Vim, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Vim/9.1.0004-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Vim/9.1.0004-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Voro%2B%2B/","title":"Voro++","text":"<p>Voro++ is a software library for carrying out three-dimensional computations of the Voronoitessellation. A distinguishing feature of the Voro++ library is that it carries out cell-based calculations,computing the Voronoi cell for each particle individually. It is particularly well-suited for applications thatrely on cell-based statistics, where features of Voronoi cells (eg. volume, centroid, number of faces) can be usedto analyze a system of particles.</p> <p>http://math.lbl.gov/voro++/</p>"},{"location":"available_software/detail/Voro%2B%2B/#available-modules","title":"Available modules","text":"<p>The overview below shows which Voro++ installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Voro++, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Voro++/0.4.6-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Voro++/0.4.6-GCCcore-13.2.0 x x x x x x x x x x x Voro++/0.4.6-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/WCSLIB/","title":"WCSLIB","text":"<p>The FITS \"World Coordinate System\" (WCS) standard defines keywordsand usage that provide for the description of astronomical coordinate systems in aFITS image header.</p> <p>https://www.atnf.csiro.au/people/mcalabre/WCS/</p>"},{"location":"available_software/detail/WCSLIB/#available-modules","title":"Available modules","text":"<p>The overview below shows which WCSLIB installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using WCSLIB, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load WCSLIB/7.11-GCC-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 WCSLIB/7.11-GCC-13.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/WRF/","title":"WRF","text":"<p>The Weather Research and Forecasting (WRF) Model is a next-generation mesoscale numerical weather prediction system designed to serve both operational forecasting and atmospheric research needs.</p> <p>https://www.wrf-model.org</p>"},{"location":"available_software/detail/WRF/#available-modules","title":"Available modules","text":"<p>The overview below shows which WRF installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using WRF, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load WRF/4.4.1-foss-2022b-dmpar\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 WRF/4.4.1-foss-2022b-dmpar x x x x x x x x x x x"},{"location":"available_software/detail/WSClean/","title":"WSClean","text":"<p>WSClean (w-stacking clean) is a fast generic widefield imager.It implements several gridding algorithms and offers fully-automated multi-scalemulti-frequency deconvolution.</p> <p>https://wsclean.readthedocs.io/</p>"},{"location":"available_software/detail/WSClean/#available-modules","title":"Available modules","text":"<p>The overview below shows which WSClean installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using WSClean, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load WSClean/3.5-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 WSClean/3.5-foss-2023b x x x x x x x x x x x WSClean/3.4-foss-2023b x x x x x x x x x x x"},{"location":"available_software/detail/Wayland/","title":"Wayland","text":"<p>Wayland is a project to define a protocol for a compositor to talk to its clients as well as a library implementation of the protocol.  The compositor can be a standalone display server running on Linux kernel modesetting and evdev input devices, an X application, or a wayland client itself.  The clients can be traditional applications, X servers (rootless or fullscreen) or other display servers.</p> <p>https://wayland.freedesktop.org/</p>"},{"location":"available_software/detail/Wayland/#available-modules","title":"Available modules","text":"<p>The overview below shows which Wayland installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Wayland, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Wayland/1.22.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Wayland/1.22.0-GCCcore-13.2.0 x x x x x x x x x x x Wayland/1.22.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/WhatsHap/","title":"WhatsHap","text":"<p>WhatsHap is a software for phasing genomic variants using DNAsequencing reads, also called read-based phasing or haplotype assembly. It isespecially suitable for long reads, but works also well with short reads.</p> <p>https://whatshap.readthedocs.io</p>"},{"location":"available_software/detail/WhatsHap/#available-modules","title":"Available modules","text":"<p>The overview below shows which WhatsHap installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using WhatsHap, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load WhatsHap/2.2-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 WhatsHap/2.2-foss-2023a x x x x x x x x x x x WhatsHap/2.1-foss-2022b x x x x x x x x x x x"},{"location":"available_software/detail/WhatsHap/#whatshap22-foss-2023a","title":"WhatsHap/2.2-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>PuLP-2.8.0, whatshap-2.2, xopen-1.7.0</p>"},{"location":"available_software/detail/WhatsHap/#whatshap21-foss-2022b","title":"WhatsHap/2.1-foss-2022b","text":"<p>This is a list of extensions included in the module:</p> <p>pulp-2.8.0, WhatsHap-2.1, xopen-1.7.0</p>"},{"location":"available_software/detail/X11/","title":"X11","text":"<p>The X Window System (X11) is a windowing system for bitmap displays</p> <p>https://www.x.org</p>"},{"location":"available_software/detail/X11/#available-modules","title":"Available modules","text":"<p>The overview below shows which X11 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using X11, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load X11/20231019-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 X11/20231019-GCCcore-13.2.0 x x x x x x x x x x x X11/20230603-GCCcore-12.3.0 x x x x x x x x x x x X11/20221110-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/XML-LibXML/","title":"XML-LibXML","text":"<p>Perl binding for libxml2</p> <p>https://metacpan.org/pod/distribution/XML-LibXML/LibXML.pod</p>"},{"location":"available_software/detail/XML-LibXML/#available-modules","title":"Available modules","text":"<p>The overview below shows which XML-LibXML installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using XML-LibXML, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load XML-LibXML/2.0209-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 XML-LibXML/2.0209-GCCcore-12.3.0 x x x x x x x x x x x XML-LibXML/2.0208-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/XML-LibXML/#xml-libxml20209-gcccore-1230","title":"XML-LibXML/2.0209-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>Alien::Base-2.80, Alien::Build::Plugin::Download::GitLab-0.01, Alien::Libxml2-0.19, File::chdir-0.1011, XML::LibXML-2.0209</p>"},{"location":"available_software/detail/XML-LibXML/#xml-libxml20208-gcccore-1220","title":"XML-LibXML/2.0208-GCCcore-12.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>Alien::Base-2.80, Alien::Build::Plugin::Download::GitLab-0.01, Alien::Libxml2-0.19, File::chdir-0.1011, XML::LibXML-2.0208</p>"},{"location":"available_software/detail/Xerces-C%2B%2B/","title":"Xerces-C++","text":"<p>Xerces-C++ is a validating XML parser written in a portablesubset of C++. Xerces-C++ makes it easy to give your application the ability toread and write XML data. A shared library is provided for parsing, generating,manipulating, and validating XML documents using the DOM, SAX, and SAX2APIs.</p> <p>https://xerces.apache.org/xerces-c/</p>"},{"location":"available_software/detail/Xerces-C%2B%2B/#available-modules","title":"Available modules","text":"<p>The overview below shows which Xerces-C++ installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Xerces-C++, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Xerces-C++/3.2.5-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Xerces-C++/3.2.5-GCCcore-13.2.0 x x x x x x x x x x x Xerces-C++/3.2.4-GCCcore-12.3.0 x x x x x x x x x x x Xerces-C++/3.2.4-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Xvfb/","title":"Xvfb","text":"<p>Xvfb is an X server that can run on machines with no display hardware and no physical input devices. It emulates a dumb framebuffer using virtual memory.</p> <p>https://www.x.org/releases/X11R7.6/doc/man/man1/Xvfb.1.xhtml</p>"},{"location":"available_software/detail/Xvfb/#available-modules","title":"Available modules","text":"<p>The overview below shows which Xvfb installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Xvfb, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Xvfb/21.1.9-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Xvfb/21.1.9-GCCcore-13.2.0 x x x x x x x x x x x Xvfb/21.1.8-GCCcore-12.3.0 x x x x x x x x x x x Xvfb/21.1.6-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/YODA/","title":"YODA","text":"<p>Yet more Objects for (High Energy Physics) Data Analysis</p> <p>https://yoda.hepforge.org/</p>"},{"location":"available_software/detail/YODA/#available-modules","title":"Available modules","text":"<p>The overview below shows which YODA installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using YODA, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load YODA/1.9.9-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 YODA/1.9.9-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Yasm/","title":"Yasm","text":"<p>Yasm: Complete rewrite of the NASM assembler with BSD license</p> <p>https://www.tortall.net/projects/yasm/</p>"},{"location":"available_software/detail/Yasm/#available-modules","title":"Available modules","text":"<p>The overview below shows which Yasm installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Yasm, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Yasm/1.3.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Yasm/1.3.0-GCCcore-13.2.0 - - - - x x x x x x x Yasm/1.3.0-GCCcore-12.3.0 - - - - x x x x x x x Yasm/1.3.0-GCCcore-12.2.0 - - - - x x x x x x x"},{"location":"available_software/detail/Z3/","title":"Z3","text":"<p>Z3 is a theorem prover from Microsoft Research with support for bitvectors,booleans, arrays, floating point numbers, strings, and other data types. Thismodule includes z3-solver, the Python interface of Z3.</p> <p>https://github.com/Z3Prover/z3</p>"},{"location":"available_software/detail/Z3/#available-modules","title":"Available modules","text":"<p>The overview below shows which Z3 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Z3, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Z3/4.12.2-GCCcore-12.3.0-Python-3.11.3\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Z3/4.12.2-GCCcore-12.3.0-Python-3.11.3 x x x x x x x x x x x Z3/4.12.2-GCCcore-12.3.0 x x x x x x x x x x x Z3/4.12.2-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/Z3/#z34122-gcccore-1230-python-3113","title":"Z3/4.12.2-GCCcore-12.3.0-Python-3.11.3","text":"<p>This is a list of extensions included in the module:</p> <p>z3-solver-4.12.2.0</p>"},{"location":"available_software/detail/Z3/#z34122-gcccore-1230","title":"Z3/4.12.2-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>z3-solver-4.12.2.0</p>"},{"location":"available_software/detail/ZeroMQ/","title":"ZeroMQ","text":"<p>ZeroMQ looks like an embeddable networking library but acts like a concurrency framework. It gives you sockets that carry atomic messages across various transports like in-process, inter-process, TCP, and multicast. You can connect sockets N-to-N with patterns like fanout, pub-sub, task distribution, and request-reply. It's fast enough to be the fabric for clustered products. Its asynchronous I/O model gives you scalable multicore applications, built as asynchronous message-processing tasks. It has a score of language APIs and runs on most operating systems.</p> <p>https://www.zeromq.org/</p>"},{"location":"available_software/detail/ZeroMQ/#available-modules","title":"Available modules","text":"<p>The overview below shows which ZeroMQ installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ZeroMQ, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ZeroMQ/4.3.5-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ZeroMQ/4.3.5-GCCcore-13.2.0 x x x x x x x x x x x ZeroMQ/4.3.4-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/Zip/","title":"Zip","text":"<p>Zip is a compression and file packaging/archive utility.Although highly compatible both with PKWARE's PKZIP and PKUNZIPutilities for MS-DOS and with Info-ZIP's own UnZip, our primary objectiveshave been portability and other-than-MSDOS functionality</p> <p>http://www.info-zip.org/Zip.html</p>"},{"location":"available_software/detail/Zip/#available-modules","title":"Available modules","text":"<p>The overview below shows which Zip installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using Zip, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load Zip/3.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 Zip/3.0-GCCcore-12.3.0 x x x x x x x x x x x Zip/3.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/amdahl/","title":"amdahl","text":"<p>This Python module contains a pseudo-application that can be used as a blackbox to reproduce Amdahl's Law. It does not do real calculations, nor any realcommunication, so can easily be overloaded.</p> <p>https://github.com/hpc-carpentry/amdahl</p>"},{"location":"available_software/detail/amdahl/#available-modules","title":"Available modules","text":"<p>The overview below shows which amdahl installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using amdahl, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load amdahl/0.3.1-gompi-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 amdahl/0.3.1-gompi-2023a x x x x x x x x x x x"},{"location":"available_software/detail/ant/","title":"ant","text":"<p>Apache Ant is a Java library and command-line tool whose mission is to drive processes described in build files as targets and extension points dependent upon each other. The main known usage of Ant is the build of Java applications.</p> <p>https://ant.apache.org/</p>"},{"location":"available_software/detail/ant/#available-modules","title":"Available modules","text":"<p>The overview below shows which ant installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ant, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ant/1.10.14-Java-11\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ant/1.10.14-Java-11 x x x x x x x x x x x"},{"location":"available_software/detail/archspec/","title":"archspec","text":"<p>A library for detecting, labeling, and reasoning about microarchitectures</p> <p>https://github.com/archspec/archspec</p>"},{"location":"available_software/detail/archspec/#available-modules","title":"Available modules","text":"<p>The overview below shows which archspec installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using archspec, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load archspec/0.2.5-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 archspec/0.2.5-GCCcore-12.3.0 x x x x x x x x x x x archspec/0.2.2-GCCcore-13.2.0 x x x x x x x x x x x archspec/0.2.1-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/arpack-ng/","title":"arpack-ng","text":"<p>ARPACK is a collection of Fortran77 subroutines designed to solve large scale eigenvalue problems.</p> <p>https://github.com/opencollab/arpack-ng</p>"},{"location":"available_software/detail/arpack-ng/#available-modules","title":"Available modules","text":"<p>The overview below shows which arpack-ng installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using arpack-ng, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load arpack-ng/3.9.0-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 arpack-ng/3.9.0-foss-2023b x x x x x x x x x x x arpack-ng/3.9.0-foss-2023a x x x x x x x x x x x arpack-ng/3.8.0-foss-2022b x x x x x x x x x x x"},{"location":"available_software/detail/arrow-R/","title":"arrow-R","text":"<p>R interface to the Apache Arrow C++ library</p> <p>https://cran.r-project.org/web/packages/arrow</p>"},{"location":"available_software/detail/arrow-R/#available-modules","title":"Available modules","text":"<p>The overview below shows which arrow-R installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using arrow-R, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load arrow-R/14.0.1-foss-2023a-R-4.3.2\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 arrow-R/14.0.1-foss-2023a-R-4.3.2 x x x x x x x x x x x arrow-R/11.0.0.3-foss-2022b-R-4.2.2 x x x x x x x x x x x"},{"location":"available_software/detail/astropy-testing/","title":"astropy-testing","text":"<p>This bundle contains all dependencies needed to test astropy using pytest.</p> <p>https://www.astropy.org/</p>"},{"location":"available_software/detail/astropy-testing/#available-modules","title":"Available modules","text":"<p>The overview below shows which astropy-testing installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using astropy-testing, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load astropy-testing/7.0.0-gfbf-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 astropy-testing/7.0.0-gfbf-2023b x x x x x x x x x x x"},{"location":"available_software/detail/astropy-testing/#astropy-testing700-gfbf-2023b","title":"astropy-testing/7.0.0-gfbf-2023b","text":"<p>This is a list of extensions included in the module:</p> <p>pytest-arraydiff-0.6.1, pytest-astropy-0.11.0, pytest-astropy-header-0.2.2, pytest-cov-5.0.0, pytest-doctestplus-1.3.0, pytest-filter-subpackage-0.2.0, pytest-mock-3.14.0, pytest-remotedata-0.4.1</p>"},{"location":"available_software/detail/astropy/","title":"astropy","text":"<p>The Astropy Project is a community effort to develop a common core package for Astronomy in Python and foster an ecosystem of interoperable astronomy packages.The Astropy community is committed to supporting diversity and inclusion.</p> <p>https://www.astropy.org/</p>"},{"location":"available_software/detail/astropy/#available-modules","title":"Available modules","text":"<p>The overview below shows which astropy installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using astropy, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load astropy/7.0.0-gfbf-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 astropy/7.0.0-gfbf-2023b x x x x x x x x x x x"},{"location":"available_software/detail/astropy/#astropy700-gfbf-2023b","title":"astropy/7.0.0-gfbf-2023b","text":"<p>This is a list of extensions included in the module:</p> <p>astropy-7.0.0, astropy-iers-data-0.2025.1.6.0.33.42, colorlog-6.9.0, extension-helpers-1.2.0, pyerfa-2.0.1.5</p>"},{"location":"available_software/detail/at-spi2-atk/","title":"at-spi2-atk","text":"<p>AT-SPI 2 toolkit bridge</p> <p>https://wiki.gnome.org/Accessibility</p>"},{"location":"available_software/detail/at-spi2-atk/#available-modules","title":"Available modules","text":"<p>The overview below shows which at-spi2-atk installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using at-spi2-atk, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load at-spi2-atk/2.38.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 at-spi2-atk/2.38.0-GCCcore-13.2.0 x x x x x x x x x x x at-spi2-atk/2.38.0-GCCcore-12.3.0 x x x x x x x x x x x at-spi2-atk/2.38.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/at-spi2-core/","title":"at-spi2-core","text":"<p>Assistive Technology Service Provider Interface.</p> <p>https://wiki.gnome.org/Accessibility</p>"},{"location":"available_software/detail/at-spi2-core/#available-modules","title":"Available modules","text":"<p>The overview below shows which at-spi2-core installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using at-spi2-core, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load at-spi2-core/2.50.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 at-spi2-core/2.50.0-GCCcore-13.2.0 x x x x x x x x x x x at-spi2-core/2.49.91-GCCcore-12.3.0 x x x x x x x x x x x at-spi2-core/2.46.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/basemap/","title":"basemap","text":"<p>The matplotlib basemap toolkit is a library for plotting 2D data on maps in Python</p> <p>https://matplotlib.org/basemap/</p>"},{"location":"available_software/detail/basemap/#available-modules","title":"Available modules","text":"<p>The overview below shows which basemap installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using basemap, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load basemap/1.3.9-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 basemap/1.3.9-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/basemap/#basemap139-foss-2023a","title":"basemap/1.3.9-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>basemap-1.3.9, basemap_data-1.3.9, pyshp-2.3.1</p>"},{"location":"available_software/detail/bcgTree/","title":"bcgTree","text":"<p>Automatized phylogenetic tree building from bacterial core genomes.</p> <p>https://github.com/molbiodiv/bcgTree</p>"},{"location":"available_software/detail/bcgTree/#available-modules","title":"Available modules","text":"<p>The overview below shows which bcgTree installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using bcgTree, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load bcgTree/1.2.1-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 bcgTree/1.2.1-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/bokeh/","title":"bokeh","text":"<p>Statistical and novel interactive HTML plots for Python</p> <p>https://github.com/bokeh/bokeh</p>"},{"location":"available_software/detail/bokeh/#available-modules","title":"Available modules","text":"<p>The overview below shows which bokeh installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using bokeh, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load bokeh/3.2.2-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 bokeh/3.2.2-foss-2023a x x x x x x x x x x x bokeh/3.2.1-foss-2022b x x x x x x x x x x x"},{"location":"available_software/detail/bokeh/#bokeh322-foss-2023a","title":"bokeh/3.2.2-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>bokeh-3.2.2, contourpy-1.0.7, xyzservices-2023.7.0</p>"},{"location":"available_software/detail/bokeh/#bokeh321-foss-2022b","title":"bokeh/3.2.1-foss-2022b","text":"<p>This is a list of extensions included in the module:</p> <p>bokeh-3.2.1, contourpy-1.0.7, tornado-6.3.2, xyzservices-2023.7.0</p>"},{"location":"available_software/detail/cURL/","title":"cURL","text":"<p>libcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP. libcurl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, cookies, user+password authentication (Basic, Digest, NTLM, Negotiate, Kerberos), file transfer resume, http proxy tunneling and more.</p> <p>https://curl.haxx.se</p>"},{"location":"available_software/detail/cURL/#available-modules","title":"Available modules","text":"<p>The overview below shows which cURL installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using cURL, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load cURL/8.3.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 cURL/8.3.0-GCCcore-13.2.0 x x x x x x x x x x x cURL/8.0.1-GCCcore-12.3.0 x x x x x x x x x x x cURL/7.86.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/cairo/","title":"cairo","text":"<p>Cairo is a 2D graphics library with support for multiple output devices. Currently supported output targets include the X Window System (via both Xlib and XCB), Quartz, Win32, image buffers, PostScript, PDF, and SVG file output. Experimental backends include OpenGL, BeOS, OS/2, and DirectFB</p> <p>https://cairographics.org</p>"},{"location":"available_software/detail/cairo/#available-modules","title":"Available modules","text":"<p>The overview below shows which cairo installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using cairo, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load cairo/1.18.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 cairo/1.18.0-GCCcore-13.2.0 x x x x x x x x x x x cairo/1.17.8-GCCcore-12.3.0 x x x x x x x x x x x cairo/1.17.4-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/casacore/","title":"casacore","text":"<p>A suite of C++ libraries for radio astronomy data processing.The ephemerides data needs to be in DATA_DIR and the location must be specified at runtime.Thus user's can update them.</p> <p>https://github.com/casacore/casacore</p>"},{"location":"available_software/detail/casacore/#available-modules","title":"Available modules","text":"<p>The overview below shows which casacore installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using casacore, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load casacore/3.5.0-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 casacore/3.5.0-foss-2023b x x x x x x x x x x x"},{"location":"available_software/detail/ccache/","title":"ccache","text":"<p>Ccache (or \u201cccache\u201d) is a compiler cache. It speeds up recompilation bycaching previous compilations and detecting when the same compilation is being done again</p> <p>https://ccache.dev/</p>"},{"location":"available_software/detail/ccache/#available-modules","title":"Available modules","text":"<p>The overview below shows which ccache installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ccache, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ccache/4.9-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ccache/4.9-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/cffi/","title":"cffi","text":"<p>C Foreign Function Interface for Python. Interact with almost any C code fromPython, based on C-like declarations that you can often copy-paste from headerfiles or documentation.</p> <p>https://cffi.readthedocs.io/en/latest/</p>"},{"location":"available_software/detail/cffi/#available-modules","title":"Available modules","text":"<p>The overview below shows which cffi installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using cffi, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load cffi/1.15.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 cffi/1.15.1-GCCcore-13.2.0 x x x x x x x x x x x cffi/1.15.1-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/cffi/#cffi1151-gcccore-1320","title":"cffi/1.15.1-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>cffi-1.15.1, pycparser-2.21</p>"},{"location":"available_software/detail/cffi/#cffi1151-gcccore-1230","title":"cffi/1.15.1-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>cffi-1.15.1, pycparser-2.21</p>"},{"location":"available_software/detail/cimfomfa/","title":"cimfomfa","text":"<p>This library supports both MCL, a cluster algorithm for graphs, and zoem, amacro/DSL language. It supplies abstractions for memory management, I/O,associative arrays, strings, heaps, and a few other things. The string libraryhas had heavy testing as part of zoem. Both understandably and regrettably Ichose long ago to make it C-string-compatible, hence nul bytes may not be partof a string. At some point I hope to rectify this, perhaps unrealistically.</p> <p>https://github.com/micans/cimfomfa</p>"},{"location":"available_software/detail/cimfomfa/#available-modules","title":"Available modules","text":"<p>The overview below shows which cimfomfa installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using cimfomfa, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load cimfomfa/22.273-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 cimfomfa/22.273-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/colorize/","title":"colorize","text":"<p>Ruby gem for colorizing text using ANSI escape sequences.Extends String class or add a ColorizedString with methods to set the text color, background color and text effects.</p> <p>https://github.com/fazibear/colorize</p>"},{"location":"available_software/detail/colorize/#available-modules","title":"Available modules","text":"<p>The overview below shows which colorize installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using colorize, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load colorize/0.7.7-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 colorize/0.7.7-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/cooler/","title":"cooler","text":"<p>Cooler is a support library for a storage format, also called cooler, used to store genomic interaction data of any size, such as Hi-C contact matrices.</p> <p>https://open2c.github.io/cooler</p>"},{"location":"available_software/detail/cooler/#available-modules","title":"Available modules","text":"<p>The overview below shows which cooler installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using cooler, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load cooler/0.10.2-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 cooler/0.10.2-foss-2023b x x x x x x x x x x x"},{"location":"available_software/detail/cooler/#cooler0102-foss-2023b","title":"cooler/0.10.2-foss-2023b","text":"<p>This is a list of extensions included in the module:</p> <p>asciitree-0.3.3, cooler-0.10.2, cytoolz-1.0.0, toolz-1.0.0</p>"},{"location":"available_software/detail/coverage/","title":"coverage","text":"<p>Coverage.py is a tool for measuring code coverage of Python programs. It monitors your program, noting which parts of the code have been executed, then analyzes the source to identify code that could have been executed but was not.</p> <p>https://coverage.readthedocs.io</p>"},{"location":"available_software/detail/coverage/#available-modules","title":"Available modules","text":"<p>The overview below shows which coverage installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using coverage, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load coverage/7.4.4-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 coverage/7.4.4-GCCcore-13.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/coverage/#coverage744-gcccore-1320","title":"coverage/7.4.4-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>coverage-7.4.4</p>"},{"location":"available_software/detail/cpio/","title":"cpio","text":"<p>The cpio package contains tools for archiving.</p> <p>https://savannah.gnu.org/projects/cpio/</p>"},{"location":"available_software/detail/cpio/#available-modules","title":"Available modules","text":"<p>The overview below shows which cpio installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using cpio, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load cpio/2.15-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 cpio/2.15-GCCcore-12.3.0 x x x x x x x x x x x cpio/2.15-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/cppy/","title":"cppy","text":"<p>A small C++ header library which makes it easier to writePython extension modules. The primary feature is a PyObject smart pointerwhich automatically handles reference counting and provides conveniencemethods for performing common object operations.</p> <p>https://github.com/nucleic/cppy</p>"},{"location":"available_software/detail/cppy/#available-modules","title":"Available modules","text":"<p>The overview below shows which cppy installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using cppy, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load cppy/1.2.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 cppy/1.2.1-GCCcore-13.2.0 x x x x x x x x x x x cppy/1.2.1-GCCcore-12.3.0 x x x x x x x x x x x cppy/1.2.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/crb-blast/","title":"crb-blast","text":"<p>Conditional Reciprocal Best BLAST - high confidence ortholog assignment.</p> <p>https://github.com/cboursnell/crb-blast</p>"},{"location":"available_software/detail/crb-blast/#available-modules","title":"Available modules","text":"<p>The overview below shows which crb-blast installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using crb-blast, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load crb-blast/0.6.9-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 crb-blast/0.6.9-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/crb-blast/#crb-blast069-gcc-1230","title":"crb-blast/0.6.9-GCC-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>bindeps-1.2.1, bio-1.6.0.pre.20181210, crb-blast-0.6.9, facade-1.2.1, fixwhich-1.0.2, pathname2-1.8.4, threach-0.2.0, trollop-2.9.10</p>"},{"location":"available_software/detail/cryptography/","title":"cryptography","text":"<p>cryptography is a package designed to expose cryptographic primitives and recipes to Python developers.</p> <p>https://github.com/pyca/cryptography</p>"},{"location":"available_software/detail/cryptography/#available-modules","title":"Available modules","text":"<p>The overview below shows which cryptography installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using cryptography, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load cryptography/41.0.5-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 cryptography/41.0.5-GCCcore-13.2.0 x x x x x x x x x x x cryptography/41.0.1-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/dask/","title":"dask","text":"<p>Dask natively scales Python. Dask provides advanced parallelism for analytics, enabling performance at scale for the tools you love.</p> <p>https://dask.org/</p>"},{"location":"available_software/detail/dask/#available-modules","title":"Available modules","text":"<p>The overview below shows which dask installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using dask, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load dask/2023.9.2-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 dask/2023.9.2-foss-2023a x x x x x x x x x x x dask/2023.7.1-foss-2022b x x x x x x x x x x x"},{"location":"available_software/detail/dask/#dask202392-foss-2023a","title":"dask/2023.9.2-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>dask-2023.9.2, dask-jobqueue-0.8.2, dask-mpi-2022.4.0, distributed-2023.9.2, docrep-0.3.2, HeapDict-1.0.1, locket-1.0.0, partd-1.4.0, tblib-2.0.0, toolz-0.12.0, zict-3.0.0</p>"},{"location":"available_software/detail/dask/#dask202371-foss-2022b","title":"dask/2023.7.1-foss-2022b","text":"<p>This is a list of extensions included in the module:</p> <p>dask-2023.7.1, dask-jobqueue-0.8.2, dask-mpi-2022.4.0, distributed-2023.7.1, docrep-0.3.2, HeapDict-1.0.1, locket-1.0.0, partd-1.4.0, tblib-2.0.0, toolz-0.12.0, versioneer-0.29, zict-3.0.0</p>"},{"location":"available_software/detail/dill/","title":"dill","text":"<p>dill extends python's pickle module for serializing and de-serializing python objects to the majority of the built-in python types. Serialization is the process of converting an object to a byte stream, and the inverse of which is converting a byte stream back to on python object hierarchy.</p> <p>https://pypi.org/project/dill/</p>"},{"location":"available_software/detail/dill/#available-modules","title":"Available modules","text":"<p>The overview below shows which dill installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using dill, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load dill/0.3.8-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 dill/0.3.8-GCCcore-13.2.0 x x x x x x x x x x x dill/0.3.7-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/dlb/","title":"dlb","text":"<p>DLB is a dynamic library designed to speed up HPC hybrid applications (i.e.,two levels of parallelism) by improving the load balance of the outer level ofparallelism (e.g., MPI) by dynamically redistributing the computationalresources at the inner level of parallelism (e.g., OpenMP). at run time.</p> <p>https://pm.bsc.es/dlb/</p>"},{"location":"available_software/detail/dlb/#available-modules","title":"Available modules","text":"<p>The overview below shows which dlb installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using dlb, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load dlb/3.4-gompi-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 dlb/3.4-gompi-2023b x x x x x x x x x x x"},{"location":"available_software/detail/double-conversion/","title":"double-conversion","text":"<p>Efficient binary-decimal and decimal-binary conversion routines for IEEE doubles.</p> <p>https://github.com/google/double-conversion</p>"},{"location":"available_software/detail/double-conversion/#available-modules","title":"Available modules","text":"<p>The overview below shows which double-conversion installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using double-conversion, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load double-conversion/3.3.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 double-conversion/3.3.0-GCCcore-13.2.0 x x x x x x x x x x x double-conversion/3.3.0-GCCcore-12.3.0 x x x x x x x x x x x double-conversion/3.2.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/ecBuild/","title":"ecBuild","text":"<p>A CMake-based build system, consisting of a collection of CMake macros andfunctions that ease the managing of software build systems</p> <p>https://ecbuild.readthedocs.io/</p>"},{"location":"available_software/detail/ecBuild/#available-modules","title":"Available modules","text":"<p>The overview below shows which ecBuild installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ecBuild, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ecBuild/3.8.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ecBuild/3.8.0 x x x x x x x x x x x"},{"location":"available_software/detail/ecCodes/","title":"ecCodes","text":"<p>ecCodes is a package developed by ECMWF which provides an application programming interface and a set of tools for decoding and encoding messages in the following formats: WMO FM-92 GRIB edition 1 and edition 2, WMO FM-94 BUFR edition 3 and edition 4, WMO GTS abbreviated header (only decoding).</p> <p>https://software.ecmwf.int/wiki/display/ECC/ecCodes+Home</p>"},{"location":"available_software/detail/ecCodes/#available-modules","title":"Available modules","text":"<p>The overview below shows which ecCodes installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ecCodes, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ecCodes/2.31.0-gompi-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ecCodes/2.31.0-gompi-2023b x x x x x x x x x x x ecCodes/2.31.0-gompi-2023a x x x x x x x x x x x"},{"location":"available_software/detail/elfutils/","title":"elfutils","text":"<p>The elfutils project provides libraries and tools for ELF files and DWARF data.</p> <p>https://elfutils.org/</p>"},{"location":"available_software/detail/elfutils/#available-modules","title":"Available modules","text":"<p>The overview below shows which elfutils installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using elfutils, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load elfutils/0.190-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 elfutils/0.190-GCCcore-13.2.0 x x x x x x x x x x x elfutils/0.189-GCCcore-12.3.0 x x x x x x x x x x x elfutils/0.189-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/elfx86exts/","title":"elfx86exts","text":"<p>Decode binaries and print out which instruction set extensions they use.</p> <p>https://github.com/pkgw/elfx86exts</p>"},{"location":"available_software/detail/elfx86exts/#available-modules","title":"Available modules","text":"<p>The overview below shows which elfx86exts installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using elfx86exts, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load elfx86exts/0.6.2-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 elfx86exts/0.6.2-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/expat/","title":"expat","text":"<p>Expat is an XML parser library written in C. It is a stream-oriented parserin which an application registers handlers for things the parser might findin the XML document (like start tags).</p> <p>https://libexpat.github.io</p>"},{"location":"available_software/detail/expat/#available-modules","title":"Available modules","text":"<p>The overview below shows which expat installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using expat, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load expat/2.5.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 expat/2.5.0-GCCcore-13.2.0 x x x x x x x x x x x expat/2.5.0-GCCcore-12.3.0 x x x x x x x x x x x expat/2.4.9-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/expecttest/","title":"expecttest","text":"<p>This library implements expect tests (also known as \"golden\" tests). Expect tests are a method of writing tests where instead of hard-coding the expected output of a test, you run the test to get the output, and the test framework automatically populates the expected output. If the output of the test changes, you can rerun the test with the environment variable EXPECTTEST_ACCEPT=1 to automatically update the expected output.</p> <p>https://github.com/ezyang/expecttest</p>"},{"location":"available_software/detail/expecttest/#available-modules","title":"Available modules","text":"<p>The overview below shows which expecttest installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using expecttest, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load expecttest/0.1.5-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 expecttest/0.1.5-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/f90wrap/","title":"f90wrap","text":"<p>f90wrap is a tool to automatically generate Python extension modules whichinterface to Fortran code that makes use of derived types. It builds on thecapabilities of the popular f2py utility by generating a simpler Fortran 90interface to the original Fortran code which is then suitable for wrapping withf2py, together with a higher-level Pythonic wrapper that makes the existance ofan additional layer transparent to the final user.</p> <p>https://github.com/jameskermode/f90wrap</p>"},{"location":"available_software/detail/f90wrap/#available-modules","title":"Available modules","text":"<p>The overview below shows which f90wrap installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using f90wrap, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load f90wrap/0.2.13-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 f90wrap/0.2.13-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/fastjet-contrib/","title":"fastjet-contrib","text":"<p>3rd party extensions of FastJet</p> <p>https://fastjet.hepforge.org/contrib/</p>"},{"location":"available_software/detail/fastjet-contrib/#available-modules","title":"Available modules","text":"<p>The overview below shows which fastjet-contrib installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using fastjet-contrib, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load fastjet-contrib/1.053-gompi-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 fastjet-contrib/1.053-gompi-2023a x x x x x x x x x x x"},{"location":"available_software/detail/fastjet/","title":"fastjet","text":"<p>A software package for jet finding in pp and e+e- collisions</p> <p>https://fastjet.fr/</p>"},{"location":"available_software/detail/fastjet/#available-modules","title":"Available modules","text":"<p>The overview below shows which fastjet installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using fastjet, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load fastjet/3.4.2-gompi-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 fastjet/3.4.2-gompi-2023a x x x x x x x x x x x"},{"location":"available_software/detail/fastp/","title":"fastp","text":"<p>A tool designed to provide fast all-in-one preprocessing for FastQ files. This tool is developed in C++ with multithreading supported to afford high performance.</p> <p>https://github.com/OpenGene/fastp</p>"},{"location":"available_software/detail/fastp/#available-modules","title":"Available modules","text":"<p>The overview below shows which fastp installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using fastp, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load fastp/0.23.4-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 fastp/0.23.4-GCC-12.3.0 x x x x x x x x x x x fastp/0.23.4-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/ffnvcodec/","title":"ffnvcodec","text":"<p>FFmpeg nvidia headers. Adds support for nvenc and nvdec. Requires Nvidia GPU and drivers to be present(picked up dynamically).</p> <p>https://git.videolan.org/?p=ffmpeg/nv-codec-headers.git</p>"},{"location":"available_software/detail/ffnvcodec/#available-modules","title":"Available modules","text":"<p>The overview below shows which ffnvcodec installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ffnvcodec, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ffnvcodec/12.1.14.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ffnvcodec/12.1.14.0 x x x x x x x x x x x ffnvcodec/12.0.16.0 x x x x x x x x x x x ffnvcodec/11.1.5.2 x x x x x x x x x x x"},{"location":"available_software/detail/flatbuffers-python/","title":"flatbuffers-python","text":"<p>Python Flatbuffers runtime library.</p> <p>https://github.com/google/flatbuffers/</p>"},{"location":"available_software/detail/flatbuffers-python/#available-modules","title":"Available modules","text":"<p>The overview below shows which flatbuffers-python installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using flatbuffers-python, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load flatbuffers-python/23.5.26-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 flatbuffers-python/23.5.26-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/flatbuffers/","title":"flatbuffers","text":"<p>FlatBuffers: Memory Efficient Serialization Library</p> <p>https://github.com/google/flatbuffers/</p>"},{"location":"available_software/detail/flatbuffers/#available-modules","title":"Available modules","text":"<p>The overview below shows which flatbuffers installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using flatbuffers, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load flatbuffers/23.5.26-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 flatbuffers/23.5.26-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/flit/","title":"flit","text":"<p>A simple packaging tool for simple packages.</p> <p>https://github.com/pypa/flit</p>"},{"location":"available_software/detail/flit/#available-modules","title":"Available modules","text":"<p>The overview below shows which flit installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using flit, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load flit/3.9.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 flit/3.9.0-GCCcore-13.2.0 x x x x x x x x x x x flit/3.9.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/flit/#flit390-gcccore-1320","title":"flit/3.9.0-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>certifi-2023.7.22, charset-normalizer-3.3.1, docutils-0.20.1, flit-3.9.0, flit_scm-1.7.0, idna-3.4, packaging-23.2, requests-2.31.0, setuptools-scm-8.0.4, tomli_w-1.0.0, typing_extensions-4.8.0, urllib3-2.0.7</p>"},{"location":"available_software/detail/flit/#flit390-gcccore-1230","title":"flit/3.9.0-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>certifi-2023.5.7, charset-normalizer-3.1.0, docutils-0.20.1, flit-3.9.0, flit_scm-1.7.0, idna-3.4, packaging-23.1, requests-2.31.0, setuptools_scm-7.1.0, tomli_w-1.0.0, typing_extensions-4.6.3, urllib3-1.26.16</p>"},{"location":"available_software/detail/flook/","title":"flook","text":"<p>The fortran-Lua-hook library.</p> <p>https://github.com/ElectronicStructureLibrary/flook</p>"},{"location":"available_software/detail/flook/#available-modules","title":"Available modules","text":"<p>The overview below shows which flook installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using flook, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load flook/0.8.4-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 flook/0.8.4-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/fontconfig/","title":"fontconfig","text":"<p>Fontconfig is a library designed to provide system-wide font configuration, customization and application access.</p> <p>https://www.freedesktop.org/wiki/Software/fontconfig/</p>"},{"location":"available_software/detail/fontconfig/#available-modules","title":"Available modules","text":"<p>The overview below shows which fontconfig installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using fontconfig, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load fontconfig/2.14.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 fontconfig/2.14.2-GCCcore-13.2.0 x x x x x x x x x x x fontconfig/2.14.2-GCCcore-12.3.0 x x x x x x x x x x x fontconfig/2.14.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/foss/","title":"foss","text":"<p>GNU Compiler Collection (GCC) based compiler toolchain, including OpenMPI for MPI support, OpenBLAS (BLAS and LAPACK support), FFTW and ScaLAPACK.</p> <p>https://easybuild.readthedocs.io/en/master/Common-toolchains.html#foss-toolchain</p>"},{"location":"available_software/detail/foss/#available-modules","title":"Available modules","text":"<p>The overview below shows which foss installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using foss, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load foss/2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 foss/2023b x x x x x x x x x x x foss/2023a x x x x x x x x x x x foss/2022b x x x x x x x x x x x"},{"location":"available_software/detail/freeglut/","title":"freeglut","text":"<p>freeglut is a completely OpenSourced alternative to the OpenGL Utility Toolkit (GLUT) library.</p> <p>http://freeglut.sourceforge.net/</p>"},{"location":"available_software/detail/freeglut/#available-modules","title":"Available modules","text":"<p>The overview below shows which freeglut installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using freeglut, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load freeglut/3.4.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 freeglut/3.4.0-GCCcore-12.3.0 x x x x x x x x x x x freeglut/3.4.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/freetype/","title":"freetype","text":"<p>FreeType 2 is a software font engine that is designed to be small, efficient, highly customizable, and portable while capable of producing high-quality output (glyph images). It can be used in graphics libraries, display servers, font conversion tools, text image generation tools, and many other products as well.</p> <p>https://www.freetype.org</p>"},{"location":"available_software/detail/freetype/#available-modules","title":"Available modules","text":"<p>The overview below shows which freetype installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using freetype, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load freetype/2.13.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 freetype/2.13.2-GCCcore-13.2.0 x x x x x x x x x x x freetype/2.13.0-GCCcore-12.3.0 x x x x x x x x x x x freetype/2.12.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/geopandas/","title":"geopandas","text":"<p>GeoPandas is a project to add support for geographic data to pandas objects.It currently implements GeoSeries and GeoDataFrame types which are subclasses of pandas.Seriesand pandas.DataFrame respectively. GeoPandas objects can act on shapely geometry objects andperform geometric operations.</p> <p>https://geopandas.org</p>"},{"location":"available_software/detail/geopandas/#available-modules","title":"Available modules","text":"<p>The overview below shows which geopandas installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using geopandas, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load geopandas/0.14.2-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 geopandas/0.14.2-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/geopandas/#geopandas0142-foss-2023a","title":"geopandas/0.14.2-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>geopandas-0.14.2, mapclassify-2.6.1</p>"},{"location":"available_software/detail/gfbf/","title":"gfbf","text":"<p>GNU Compiler Collection (GCC) based compiler toolchain, including FlexiBLAS (BLAS and LAPACK support) and (serial) FFTW.</p> <p>(none)</p>"},{"location":"available_software/detail/gfbf/#available-modules","title":"Available modules","text":"<p>The overview below shows which gfbf installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using gfbf, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load gfbf/2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 gfbf/2023b x x x x x x x x x x x gfbf/2023a x x x x x x x x x x x gfbf/2022b x x x x x x x x x x x"},{"location":"available_software/detail/giflib/","title":"giflib","text":"<p>giflib is a library for reading and writing gif images.It is API and ABI compatible with libungif which was in wide use whilethe LZW compression algorithm was patented.</p> <p>http://giflib.sourceforge.net/</p>"},{"location":"available_software/detail/giflib/#available-modules","title":"Available modules","text":"<p>The overview below shows which giflib installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using giflib, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load giflib/5.2.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 giflib/5.2.1-GCCcore-13.2.0 x x x x x x x x x x x giflib/5.2.1-GCCcore-12.3.0 x x x x x x x x x x x giflib/5.2.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/git/","title":"git","text":"<p>Git is a free and open source distributed version control system designedto handle everything from small to very large projects with speed and efficiency.</p> <p>https://git-scm.com</p>"},{"location":"available_software/detail/git/#available-modules","title":"Available modules","text":"<p>The overview below shows which git installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using git, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load git/2.42.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 git/2.42.0-GCCcore-13.2.0 x x x x x x x x x x x git/2.41.0-GCCcore-12.3.0-nodocs x x x x x x x x x x x git/2.38.1-GCCcore-12.2.0-nodocs x x x x x x x x x x x"},{"location":"available_software/detail/gmpy2/","title":"gmpy2","text":"<p>GMP/MPIR, MPFR, and MPC interface to Python 2.6+ and 3.x</p> <p>https://github.com/aleaxit/gmpy</p>"},{"location":"available_software/detail/gmpy2/#available-modules","title":"Available modules","text":"<p>The overview below shows which gmpy2 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using gmpy2, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load gmpy2/2.1.5-GCC-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 gmpy2/2.1.5-GCC-13.2.0 x x x x x x x x x x x gmpy2/2.1.5-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/gmsh/","title":"gmsh","text":"<p>Gmsh is a 3D finite element grid generator with a build-in CAD engine and post-processor.</p> <p>https://gmsh.info/</p>"},{"location":"available_software/detail/gmsh/#available-modules","title":"Available modules","text":"<p>The overview below shows which gmsh installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using gmsh, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load gmsh/4.12.2-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 gmsh/4.12.2-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/gnuplot/","title":"gnuplot","text":"<p>Portable interactive, function plotting utility</p> <p>http://gnuplot.sourceforge.net</p>"},{"location":"available_software/detail/gnuplot/#available-modules","title":"Available modules","text":"<p>The overview below shows which gnuplot installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using gnuplot, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load gnuplot/5.4.8-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 gnuplot/5.4.8-GCCcore-12.3.0 x x x x x x x x x x x gnuplot/5.4.6-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/gompi/","title":"gompi","text":"<p>GNU Compiler Collection (GCC) based compiler toolchain, including OpenMPI for MPI support.</p> <p>(none)</p>"},{"location":"available_software/detail/gompi/#available-modules","title":"Available modules","text":"<p>The overview below shows which gompi installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using gompi, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load gompi/2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 gompi/2023b x x x x x x x x x x x gompi/2023a x x x x x x x x x x x gompi/2022b x x x x x x x x x x x"},{"location":"available_software/detail/googletest/","title":"googletest","text":"<p>Google's framework for writing C++ tests on a variety of platforms</p> <p>https://github.com/google/googletest</p>"},{"location":"available_software/detail/googletest/#available-modules","title":"Available modules","text":"<p>The overview below shows which googletest installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using googletest, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load googletest/1.14.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 googletest/1.14.0-GCCcore-13.2.0 x x x x x x x x x x x googletest/1.13.0-GCCcore-12.3.0 x x x x x x x x x x x googletest/1.12.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/graphite2/","title":"graphite2","text":"<p>Graphite is a \"smart font\" system developed specifically to handle the complexities of lesser-known languages of the world.</p> <p>https://scripts.sil.org/cms/scripts/page.php?site_id=projects&amp;item_id=graphite_home</p>"},{"location":"available_software/detail/graphite2/#available-modules","title":"Available modules","text":"<p>The overview below shows which graphite2 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using graphite2, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load graphite2/1.3.14-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 graphite2/1.3.14-GCCcore-13.2.0 x x x x x x x x x x x graphite2/1.3.14-GCCcore-12.3.0 x x x x x x x x x x x graphite2/1.3.14-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/groff/","title":"groff","text":"<p>Groff (GNU troff) is a typesetting system that reads plain text mixed with formatting commands and produces formatted output.</p> <p>https://www.gnu.org/software/groff</p>"},{"location":"available_software/detail/groff/#available-modules","title":"Available modules","text":"<p>The overview below shows which groff installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using groff, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load groff/1.22.4-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 groff/1.22.4-GCCcore-12.3.0 x x x x x x x x x x x groff/1.22.4-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/grpcio/","title":"grpcio","text":"<p>gRPC is a modern, open source, high-performance remote procedure call (RPC)framework that can run anywhere. gRPC enables client and server applications tocommunicate transparently, and simplifies the building of connected systems.</p> <p>https://grpc.io/</p>"},{"location":"available_software/detail/grpcio/#available-modules","title":"Available modules","text":"<p>The overview below shows which grpcio installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using grpcio, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load grpcio/1.57.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 grpcio/1.57.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/grpcio/#grpcio1570-gcccore-1230","title":"grpcio/1.57.0-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>grpcio-1.57.0</p>"},{"location":"available_software/detail/gtk-doc/","title":"gtk-doc","text":"<p>Documentation tool for public library API</p> <p>https://gitlab.gnome.org/GNOME/gtk-doc</p>"},{"location":"available_software/detail/gtk-doc/#available-modules","title":"Available modules","text":"<p>The overview below shows which gtk-doc installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using gtk-doc, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load gtk-doc/1.34.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 gtk-doc/1.34.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/gzip/","title":"gzip","text":"<p>gzip (GNU zip) is a popular data compression program as a replacement for compress</p> <p>https://www.gnu.org/software/gzip/</p>"},{"location":"available_software/detail/gzip/#available-modules","title":"Available modules","text":"<p>The overview below shows which gzip installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using gzip, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load gzip/1.13-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 gzip/1.13-GCCcore-13.2.0 x x x x x x x x x x x gzip/1.12-GCCcore-12.3.0 x x x x x x x x x x x gzip/1.12-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/h5netcdf/","title":"h5netcdf","text":"<p>A Python interface for the netCDF4 file-format that reads and writes local orremote HDF5 files directly via h5py or h5pyd, without relying on the UnidatanetCDF library.</p> <p>https://h5netcdf.org/</p>"},{"location":"available_software/detail/h5netcdf/#available-modules","title":"Available modules","text":"<p>The overview below shows which h5netcdf installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using h5netcdf, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load h5netcdf/1.2.0-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 h5netcdf/1.2.0-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/h5netcdf/#h5netcdf120-foss-2023a","title":"h5netcdf/1.2.0-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>h5netcdf-1.2.0</p>"},{"location":"available_software/detail/h5py/","title":"h5py","text":"<p>HDF5 for Python (h5py) is a general-purpose Python interface to the Hierarchical Data Format library, version 5. HDF5 is a versatile, mature scientific software library designed for the fast, flexible storage of enormous amounts of data.</p> <p>https://www.h5py.org/</p>"},{"location":"available_software/detail/h5py/#available-modules","title":"Available modules","text":"<p>The overview below shows which h5py installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using h5py, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load h5py/3.11.0-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 h5py/3.11.0-foss-2023b x x x x x x x x x x x h5py/3.9.0-foss-2023a x x x x x x x x x x x h5py/3.8.0-foss-2022b x x x x x x x x x x x"},{"location":"available_software/detail/hatch-jupyter-builder/","title":"hatch-jupyter-builder","text":"<p>Hatch Jupyter Builder is a plugin for the hatchling Python build backend. It isprimarily targeted for package authors who are providing JavaScript as part oftheir Python packages.Typical use cases are Jupyter Lab Extensions and Jupyter Widgets.</p> <p>https://hatch-jupyter-builder.readthedocs.io</p>"},{"location":"available_software/detail/hatch-jupyter-builder/#available-modules","title":"Available modules","text":"<p>The overview below shows which hatch-jupyter-builder installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using hatch-jupyter-builder, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load hatch-jupyter-builder/0.9.1-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 hatch-jupyter-builder/0.9.1-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/hatch-jupyter-builder/#hatch-jupyter-builder091-gcccore-1230","title":"hatch-jupyter-builder/0.9.1-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>hatch_jupyter_builder-0.9.1, hatch_nodejs_version-0.3.2</p>"},{"location":"available_software/detail/hatchling/","title":"hatchling","text":"<p>Extensible, standards compliant build backend used by Hatch,a modern, extensible Python project manager.</p> <p>https://hatch.pypa.io</p>"},{"location":"available_software/detail/hatchling/#available-modules","title":"Available modules","text":"<p>The overview below shows which hatchling installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using hatchling, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load hatchling/1.18.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 hatchling/1.18.0-GCCcore-13.2.0 x x x x x x x x x x x hatchling/1.18.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/hatchling/#hatchling1180-gcccore-1320","title":"hatchling/1.18.0-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>editables-0.5, hatch-requirements-txt-0.4.1, hatch_fancy_pypi_readme-23.1.0, hatch_vcs-0.3.0, hatchling-1.18.0, pathspec-0.11.2, pluggy-1.3.0, trove_classifiers-2023.10.18</p>"},{"location":"available_software/detail/hatchling/#hatchling1180-gcccore-1230","title":"hatchling/1.18.0-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>editables-0.3, hatch-requirements-txt-0.4.1, hatch_fancy_pypi_readme-23.1.0, hatch_vcs-0.3.0, hatchling-1.18.0, pathspec-0.11.1, pluggy-1.2.0, trove_classifiers-2023.5.24</p>"},{"location":"available_software/detail/hic-straw/","title":"hic-straw","text":"<p>Straw is a library which allows rapid streaming of contact data from .hic files.</p> <p>https://github.com/aidenlab/straw</p>"},{"location":"available_software/detail/hic-straw/#available-modules","title":"Available modules","text":"<p>The overview below shows which hic-straw installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using hic-straw, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load hic-straw/1.3.1-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 hic-straw/1.3.1-foss-2023b x x x x x x x x x x x"},{"location":"available_software/detail/hiredis/","title":"hiredis","text":"<p>Hiredis is a minimalistic C client library for the Redis database.It is minimalistic because it just adds minimal support for the protocol,but at the same time it uses a high level printf-alike API in order tomake it much higher level than otherwise suggested by its minimal code baseand the lack of explicit bindings for every Redis command.</p> <p>https://github.com/redis/hiredis</p>"},{"location":"available_software/detail/hiredis/#available-modules","title":"Available modules","text":"<p>The overview below shows which hiredis installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using hiredis, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load hiredis/1.2.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 hiredis/1.2.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/hwloc/","title":"hwloc","text":"<p>The Portable Hardware Locality (hwloc) software package provides a portable abstraction (across OS, versions, architectures, ...) of the hierarchical topology of modern architectures, including NUMA memory nodes, sockets, shared caches, cores and simultaneous multithreading. It also gathers various system attributes such as cache and memory information as well as the locality of I/O devices such as network interfaces, InfiniBand HCAs or GPUs. It primarily aims at helping applications with gathering information about modern computing hardware so as to exploit it accordingly and efficiently.</p> <p>https://www.open-mpi.org/projects/hwloc/</p>"},{"location":"available_software/detail/hwloc/#available-modules","title":"Available modules","text":"<p>The overview below shows which hwloc installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using hwloc, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load hwloc/2.9.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 hwloc/2.9.2-GCCcore-13.2.0 x x x x x x x x x x x hwloc/2.9.1-GCCcore-12.3.0 x x x x x x x x x x x hwloc/2.8.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/hypothesis/","title":"hypothesis","text":"<p>Hypothesis is an advanced testing library for Python. It lets you write tests which are parametrized by a source of examples, and then generates simple and comprehensible examples that make your tests fail. This lets you find more bugs in your code with less work.</p> <p>https://github.com/HypothesisWorks/hypothesis</p>"},{"location":"available_software/detail/hypothesis/#available-modules","title":"Available modules","text":"<p>The overview below shows which hypothesis installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using hypothesis, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load hypothesis/6.90.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 hypothesis/6.90.0-GCCcore-13.2.0 x x x x x x x x x x x hypothesis/6.82.0-GCCcore-12.3.0 x x x x x x x x x x x hypothesis/6.68.2-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/ipympl/","title":"ipympl","text":"<p>Leveraging the Jupyter interactive widgets framework, ipympl enables theinteractive features of matplotlib in the Jupyter notebook and in JupyterLab.Besides, the figure canvas element is a proper Jupyter interactive widget whichcan be positioned in interactive widget layouts.</p> <p>https://matplotlib.org/ipympl</p>"},{"location":"available_software/detail/ipympl/#available-modules","title":"Available modules","text":"<p>The overview below shows which ipympl installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ipympl, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ipympl/0.9.3-gfbf-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ipympl/0.9.3-gfbf-2023a x x x x x x x x x x x"},{"location":"available_software/detail/ipympl/#ipympl093-gfbf-2023a","title":"ipympl/0.9.3-gfbf-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>ipympl-0.9.3</p>"},{"location":"available_software/detail/jbigkit/","title":"jbigkit","text":"<p>JBIG-KIT is a software implementation of the JBIG1 data compression standard (ITU-T T.82), which was designed for bi-level image data, such as scanned documents.</p> <p>https://www.cl.cam.ac.uk/~mgk25/jbigkit/</p>"},{"location":"available_software/detail/jbigkit/#available-modules","title":"Available modules","text":"<p>The overview below shows which jbigkit installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using jbigkit, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load jbigkit/2.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 jbigkit/2.1-GCCcore-13.2.0 x x x x x x x x x x x jbigkit/2.1-GCCcore-12.3.0 x x x x x x x x x x x jbigkit/2.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/jedi/","title":"jedi","text":"<p>Jedi - an awesome autocompletion, static analysis and refactoring library for Python.</p> <p>https://github.com/davidhalter/jedi</p>"},{"location":"available_software/detail/jedi/#available-modules","title":"Available modules","text":"<p>The overview below shows which jedi installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using jedi, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load jedi/0.19.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 jedi/0.19.1-GCCcore-13.2.0 x x x x x x x x x x x jedi/0.19.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/jedi/#jedi0191-gcccore-1320","title":"jedi/0.19.1-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>jedi-0.19.1, parso-0.8.3</p>"},{"location":"available_software/detail/jedi/#jedi0190-gcccore-1230","title":"jedi/0.19.0-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>jedi-0.19.0, parso-0.8.3</p>"},{"location":"available_software/detail/jemalloc/","title":"jemalloc","text":"<p>jemalloc is a general purpose malloc(3) implementation that emphasizes fragmentation avoidance and scalable concurrency support.</p> <p>http://jemalloc.net</p>"},{"location":"available_software/detail/jemalloc/#available-modules","title":"Available modules","text":"<p>The overview below shows which jemalloc installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using jemalloc, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load jemalloc/5.3.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 jemalloc/5.3.0-GCCcore-12.3.0 x x x x x x x x x x x jemalloc/5.3.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/jq/","title":"jq","text":"<p>jq is a lightweight and flexible command-line JSON processor.</p> <p>https://stedolan.github.io/jq/</p>"},{"location":"available_software/detail/jq/#available-modules","title":"Available modules","text":"<p>The overview below shows which jq installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using jq, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load jq/1.6-GCCcore-12.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 jq/1.6-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/json-c/","title":"json-c","text":"<p>JSON-C implements a reference counting object model that allows you to easily construct JSON objects in C, output them as JSON formatted strings and parse JSON formatted strings back into the C representation of JSONobjects.</p> <p>https://github.com/json-c/json-c</p>"},{"location":"available_software/detail/json-c/#available-modules","title":"Available modules","text":"<p>The overview below shows which json-c installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using json-c, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load json-c/0.17-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 json-c/0.17-GCCcore-13.2.0 x x x x x x x x x x x json-c/0.16-GCCcore-12.3.0 x x x x x x x x x x x json-c/0.16-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/json-fortran/","title":"json-fortran","text":"<p>JSON-Fortran: A Modern Fortran JSON API</p> <p>https://github.com/jacobwilliams/json-fortran</p>"},{"location":"available_software/detail/json-fortran/#available-modules","title":"Available modules","text":"<p>The overview below shows which json-fortran installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using json-fortran, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load json-fortran/9.0.2-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 json-fortran/9.0.2-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/jupyter-server/","title":"jupyter-server","text":"<p>The Jupyter Server provides the backend (i.e. the core services, APIs, and RESTendpoints) for Jupyter web applications like Jupyter notebook, JupyterLab, andVoila.</p> <p>https://jupyter.org/</p>"},{"location":"available_software/detail/jupyter-server/#available-modules","title":"Available modules","text":"<p>The overview below shows which jupyter-server installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using jupyter-server, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load jupyter-server/2.7.2-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 jupyter-server/2.7.2-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/jupyter-server/#jupyter-server272-gcccore-1230","title":"jupyter-server/2.7.2-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>anyio-3.7.1, argon2-cffi-bindings-21.2.0, argon2_cffi-23.1.0, arrow-1.2.3, bleach-6.0.0, comm-0.1.4, debugpy-1.6.7.post1, defusedxml-0.7.1, deprecation-2.1.0, fastjsonschema-2.18.0, hatch_jupyter_builder-0.8.3, hatch_nodejs_version-0.3.1, ipykernel-6.25.1, ipython_genutils-0.2.0, ipywidgets-8.1.0, jsonschema-4.18.0, jsonschema_specifications-2023.7.1, jupyter_client-8.3.0, jupyter_core-5.3.1, jupyter_events-0.7.0, jupyter_packaging-0.12.3, jupyter_server-2.7.2, jupyter_server_terminals-0.4.4, jupyterlab_pygments-0.2.2, jupyterlab_widgets-3.0.8, mistune-3.0.1, nbclient-0.8.0, nbconvert-7.7.4, nbformat-5.9.2, nest_asyncio-1.5.7, notebook_shim-0.2.3, overrides-7.4.0, pandocfilters-1.5.0, prometheus_client-0.17.1, python-json-logger-2.0.7, referencing-0.30.2, rfc3339_validator-0.1.4, rfc3986_validator-0.1.1, rpds_py-0.9.2, Send2Trash-1.8.2, sniffio-1.3.0, terminado-0.17.1, tinycss2-1.2.1, websocket-client-1.6.1, widgetsnbextension-4.0.8</p>"},{"location":"available_software/detail/kim-api/","title":"kim-api","text":"<p>Open Knowledgebase of Interatomic Models.KIM is an API and OpenKIM is a collection of interatomic models (potentials) foratomistic simulations.  This is a library that can be used by simulation programsto get access to the models in the OpenKIM database.This EasyBuild only installs the API, the models can be installed with thepackage openkim-models, or the user can install them manually by running    kim-api-collections-management install user MODELNAMEor    kim-api-collections-management install user OpenKIMto install them all.</p> <p>https://openkim.org/</p>"},{"location":"available_software/detail/kim-api/#available-modules","title":"Available modules","text":"<p>The overview below shows which kim-api installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using kim-api, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load kim-api/2.3.0-GCC-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 kim-api/2.3.0-GCC-13.2.0 x x x x x x x x x x x kim-api/2.3.0-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/libGLU/","title":"libGLU","text":"<p>The OpenGL Utility Library (GLU) is a computer graphics library for OpenGL.</p> <p>https://mesa.freedesktop.org/archive/glu/</p>"},{"location":"available_software/detail/libGLU/#available-modules","title":"Available modules","text":"<p>The overview below shows which libGLU installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libGLU, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libGLU/9.0.3-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libGLU/9.0.3-GCCcore-13.2.0 x x x x x x x x x x x libGLU/9.0.3-GCCcore-12.3.0 x x x x x x x x x x x libGLU/9.0.2-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libGridXC/","title":"libGridXC","text":"<p>A library to compute the exchange and correlation energy and potential in spherical (i.e. atoms) or periodic systems.</p> <p>https://gitlab.com/siesta-project/libraries/libgridxc</p>"},{"location":"available_software/detail/libGridXC/#available-modules","title":"Available modules","text":"<p>The overview below shows which libGridXC installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libGridXC, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libGridXC/2.0.2-gompi-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libGridXC/2.0.2-gompi-2023a x x x x x x x x x x x"},{"location":"available_software/detail/libPSML/","title":"libPSML","text":"<p>A library to handle pseudopotentials in PSML format</p> <p>https://gitlab.com/siesta-project/libraries/libpsml</p>"},{"location":"available_software/detail/libPSML/#available-modules","title":"Available modules","text":"<p>The overview below shows which libPSML installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libPSML, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libPSML/2.1.0-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libPSML/2.1.0-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/libaec/","title":"libaec","text":"<p>Libaec provides fast lossless compression of 1 up to 32 bit wide signed or unsigned integers(samples). The library achieves best results for low entropy data as often encountered in space imaginginstrument data or numerical model output from weather or climate simulations. While floating point representationsare not directly supported, they can also be efficiently coded by grouping exponents and mantissa.</p> <p>https://gitlab.dkrz.de/k202009/libaec</p>"},{"location":"available_software/detail/libaec/#available-modules","title":"Available modules","text":"<p>The overview below shows which libaec installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libaec, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libaec/1.0.6-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libaec/1.0.6-GCCcore-13.2.0 x x x x x x x x x x x libaec/1.0.6-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/libaio/","title":"libaio","text":"<p>Asynchronous input/output library that uses the kernels native interface.</p> <p>https://pagure.io/libaio</p>"},{"location":"available_software/detail/libaio/#available-modules","title":"Available modules","text":"<p>The overview below shows which libaio installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libaio, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libaio/0.3.113-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libaio/0.3.113-GCCcore-12.3.0 x x x x x x x x x x x libaio/0.3.113-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libarchive/","title":"libarchive","text":"<p>Multi-format archive and compression library</p> <p>https://www.libarchive.org/</p>"},{"location":"available_software/detail/libarchive/#available-modules","title":"Available modules","text":"<p>The overview below shows which libarchive installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libarchive, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libarchive/3.7.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libarchive/3.7.2-GCCcore-13.2.0 x x x x x x x x x x x libarchive/3.6.2-GCCcore-12.3.0 x x x x x x x x x x x libarchive/3.6.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libcerf/","title":"libcerf","text":"<p>libcerf is a self-contained numeric library that provides an efficient and accurate implementation of complex error functions, along with Dawson, Faddeeva, and Voigt functions.</p> <p>https://jugit.fz-juelich.de/mlz/libcerf</p>"},{"location":"available_software/detail/libcerf/#available-modules","title":"Available modules","text":"<p>The overview below shows which libcerf installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libcerf, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libcerf/2.3-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libcerf/2.3-GCCcore-12.3.0 x x x x x x x x x x x libcerf/2.3-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libcint/","title":"libcint","text":"<p>libcint is an open source library for analytical Gaussian integrals.</p> <p>https://github.com/sunqm/libcint</p>"},{"location":"available_software/detail/libcint/#available-modules","title":"Available modules","text":"<p>The overview below shows which libcint installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libcint, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libcint/5.4.0-gfbf-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libcint/5.4.0-gfbf-2023a x x x x x x x x x x x"},{"location":"available_software/detail/libdeflate/","title":"libdeflate","text":"<p>Heavily optimized library for DEFLATE/zlib/gzip compression and decompression.</p> <p>https://github.com/ebiggers/libdeflate</p>"},{"location":"available_software/detail/libdeflate/#available-modules","title":"Available modules","text":"<p>The overview below shows which libdeflate installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libdeflate, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libdeflate/1.19-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libdeflate/1.19-GCCcore-13.2.0 x x x x x x x x x x x libdeflate/1.18-GCCcore-12.3.0 x x x x x x x x x x x libdeflate/1.15-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libdrm/","title":"libdrm","text":"<p>Direct Rendering Manager runtime library.</p> <p>https://dri.freedesktop.org</p>"},{"location":"available_software/detail/libdrm/#available-modules","title":"Available modules","text":"<p>The overview below shows which libdrm installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libdrm, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libdrm/2.4.117-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libdrm/2.4.117-GCCcore-13.2.0 x x x x x x x x x x x libdrm/2.4.115-GCCcore-12.3.0 x x x x x x x x x x x libdrm/2.4.114-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libdwarf/","title":"libdwarf","text":"<p>The DWARF Debugging Information Format is of interest to programmers working on compilersand debuggers (and anyone interested in reading or writing DWARF information))</p> <p>https://www.prevanders.net/dwarf.html</p>"},{"location":"available_software/detail/libdwarf/#available-modules","title":"Available modules","text":"<p>The overview below shows which libdwarf installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libdwarf, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libdwarf/0.9.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libdwarf/0.9.2-GCCcore-13.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libepoxy/","title":"libepoxy","text":"<p>Epoxy is a library for handling OpenGL function pointer management for you</p> <p>https://github.com/anholt/libepoxy</p>"},{"location":"available_software/detail/libepoxy/#available-modules","title":"Available modules","text":"<p>The overview below shows which libepoxy installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libepoxy, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libepoxy/1.5.10-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libepoxy/1.5.10-GCCcore-13.2.0 x x x x x x x x x x x libepoxy/1.5.10-GCCcore-12.3.0 x x x x x x x x x x x libepoxy/1.5.10-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libevent/","title":"libevent","text":"<p>The libevent API provides a mechanism to execute a callback function when a specific event occurs on a file descriptor or after a timeout has been reached.  Furthermore, libevent also support callbacks due to signals or regular timeouts.</p> <p>https://libevent.org/</p>"},{"location":"available_software/detail/libevent/#available-modules","title":"Available modules","text":"<p>The overview below shows which libevent installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libevent, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libevent/2.1.12-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libevent/2.1.12-GCCcore-13.2.0 x x x x x x x x x x x libevent/2.1.12-GCCcore-12.3.0 x x x x x x x x x x x libevent/2.1.12-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libfabric/","title":"libfabric","text":"<p>Libfabric is a core component of OFI. It is the library that defines and exportsthe user-space API of OFI, and is typically the only software that applicationsdeal with directly. It works in conjunction with provider libraries, which areoften integrated directly into libfabric.</p> <p>https://ofiwg.github.io/libfabric/</p>"},{"location":"available_software/detail/libfabric/#available-modules","title":"Available modules","text":"<p>The overview below shows which libfabric installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libfabric, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libfabric/1.19.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libfabric/1.19.0-GCCcore-13.2.0 x x x x x x x x x x x libfabric/1.18.0-GCCcore-12.3.0 x x x x x x x x x x x libfabric/1.16.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libfdf/","title":"libfdf","text":"<p>LibFDF is the official implementation of the FDF specifications for use in client codes.</p> <p>https://gitlab.com/siesta-project/libraries/libfdf</p>"},{"location":"available_software/detail/libfdf/#available-modules","title":"Available modules","text":"<p>The overview below shows which libfdf installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libfdf, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libfdf/0.5.1-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libfdf/0.5.1-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/libffi/","title":"libffi","text":"<p>The libffi library provides a portable, high level programming interface to various calling conventions. This allows a programmer to call any function specified by a call interface description at run-time.</p> <p>https://sourceware.org/libffi/</p>"},{"location":"available_software/detail/libffi/#available-modules","title":"Available modules","text":"<p>The overview below shows which libffi installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libffi, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libffi/3.4.4-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libffi/3.4.4-GCCcore-13.2.0 x x x x x x x x x x x libffi/3.4.4-GCCcore-12.3.0 x x x x x x x x x x x libffi/3.4.4-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libgcrypt/","title":"libgcrypt","text":"<p>Libgcrypt is a general purpose cryptographic library originally based on code from GnuPG</p> <p>https://gnupg.org/related_software/libgcrypt/index.html</p>"},{"location":"available_software/detail/libgcrypt/#available-modules","title":"Available modules","text":"<p>The overview below shows which libgcrypt installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libgcrypt, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libgcrypt/1.10.3-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libgcrypt/1.10.3-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/libgd/","title":"libgd","text":"<p>GD is an open source code library for the dynamic creation of images by programmers.</p> <p>https://libgd.github.io</p>"},{"location":"available_software/detail/libgd/#available-modules","title":"Available modules","text":"<p>The overview below shows which libgd installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libgd, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libgd/2.3.3-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libgd/2.3.3-GCCcore-12.3.0 x x x x x x x x x x x libgd/2.3.3-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libgeotiff/","title":"libgeotiff","text":"<p>Library for reading and writing coordinate system information from/to GeoTIFF files</p> <p>https://directory.fsf.org/wiki/Libgeotiff</p>"},{"location":"available_software/detail/libgeotiff/#available-modules","title":"Available modules","text":"<p>The overview below shows which libgeotiff installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libgeotiff, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libgeotiff/1.7.3-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libgeotiff/1.7.3-GCCcore-13.2.0 x x x x x x x x x x x libgeotiff/1.7.1-GCCcore-12.3.0 x x x x x x x x x x x libgeotiff/1.7.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libgit2/","title":"libgit2","text":"<p>libgit2 is a portable, pure C implementation of the Git core methods provided as a re-entrantlinkable library with a solid API, allowing you to write native speed custom Git applications in any languagewhich supports C bindings.</p> <p>https://libgit2.org/</p>"},{"location":"available_software/detail/libgit2/#available-modules","title":"Available modules","text":"<p>The overview below shows which libgit2 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libgit2, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libgit2/1.7.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libgit2/1.7.2-GCCcore-13.2.0 x x x x x x x x x x x libgit2/1.7.1-GCCcore-12.3.0 x x x x x x x x x x x libgit2/1.5.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libglvnd/","title":"libglvnd","text":"<p>libglvnd is a vendor-neutral dispatch layer for arbitrating OpenGL API calls between multiple vendors.</p> <p>https://gitlab.freedesktop.org/glvnd/libglvnd</p>"},{"location":"available_software/detail/libglvnd/#available-modules","title":"Available modules","text":"<p>The overview below shows which libglvnd installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libglvnd, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libglvnd/1.7.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libglvnd/1.7.0-GCCcore-13.2.0 x x x x x x x x x x x libglvnd/1.6.0-GCCcore-12.3.0 x x x x x x x x x x x libglvnd/1.6.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libgpg-error/","title":"libgpg-error","text":"<p>Libgpg-error is a small library that defines common error values for all GnuPG components.</p> <p>https://gnupg.org/related_software/libgpg-error/index.html</p>"},{"location":"available_software/detail/libgpg-error/#available-modules","title":"Available modules","text":"<p>The overview below shows which libgpg-error installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libgpg-error, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libgpg-error/1.48-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libgpg-error/1.48-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/libiconv/","title":"libiconv","text":"<p>Libiconv converts from one character encoding to another through Unicode conversion</p> <p>https://www.gnu.org/software/libiconv</p>"},{"location":"available_software/detail/libiconv/#available-modules","title":"Available modules","text":"<p>The overview below shows which libiconv installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libiconv, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libiconv/1.17-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libiconv/1.17-GCCcore-13.2.0 x x x x x x x x x x x libiconv/1.17-GCCcore-12.3.0 x x x x x x x x x x x libiconv/1.17-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libidn2/","title":"libidn2","text":"<p>Libidn2 implements the revised algorithm for internationalized domain names called IDNA2008/TR46.</p> <p>http://www.gnu.org/software/libidn2</p>"},{"location":"available_software/detail/libidn2/#available-modules","title":"Available modules","text":"<p>The overview below shows which libidn2 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libidn2, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libidn2/2.3.7-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libidn2/2.3.7-GCCcore-12.3.0 x x x x x x x x x x x libidn2/2.3.2-GCCcore-13.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libjpeg-turbo/","title":"libjpeg-turbo","text":"<p>libjpeg-turbo is a fork of the original IJG libjpeg which uses SIMD to accelerate baseline JPEG compression and decompression. libjpeg is a library that implements JPEG image encoding, decoding and transcoding.</p> <p>https://sourceforge.net/projects/libjpeg-turbo/</p>"},{"location":"available_software/detail/libjpeg-turbo/#available-modules","title":"Available modules","text":"<p>The overview below shows which libjpeg-turbo installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libjpeg-turbo, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libjpeg-turbo/3.0.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libjpeg-turbo/3.0.1-GCCcore-13.2.0 x x x x x x x x x x x libjpeg-turbo/2.1.5.1-GCCcore-12.3.0 x x x x x x x x x x x libjpeg-turbo/2.1.4-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libogg/","title":"libogg","text":"<p>Ogg is a multimedia container format, and the native file and stream format for the Xiph.orgmultimedia codecs.</p> <p>https://xiph.org/ogg/</p>"},{"location":"available_software/detail/libogg/#available-modules","title":"Available modules","text":"<p>The overview below shows which libogg installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libogg, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libogg/1.3.5-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libogg/1.3.5-GCCcore-13.2.0 x x x x x x x x x x x libogg/1.3.5-GCCcore-12.3.0 x x x x x x x x x x x libogg/1.3.5-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libopus/","title":"libopus","text":"<p>Opus is a totally open, royalty-free, highly versatile audio codec. Opus is unmatched for interactive speech and music transmission over the Internet, but is also intended for storage and streaming applications. It is standardized by the Internet Engineering Task Force (IETF) as RFC 6716 which incorporated technology from Skype\u2019s SILK codec and Xiph.Org\u2019s CELT codec.</p> <p>https://www.opus-codec.org/</p>"},{"location":"available_software/detail/libopus/#available-modules","title":"Available modules","text":"<p>The overview below shows which libopus installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libopus, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libopus/1.5.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libopus/1.5.2-GCCcore-13.2.0 x x x x x x x x x x x libopus/1.4-GCCcore-12.3.0 x x x x x x x x x x x libopus/1.3.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libpciaccess/","title":"libpciaccess","text":"<p>Generic PCI access library.</p> <p>https://cgit.freedesktop.org/xorg/lib/libpciaccess/</p>"},{"location":"available_software/detail/libpciaccess/#available-modules","title":"Available modules","text":"<p>The overview below shows which libpciaccess installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libpciaccess, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libpciaccess/0.17-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libpciaccess/0.17-GCCcore-13.2.0 x x x x x x x x x x x libpciaccess/0.17-GCCcore-12.3.0 x x x x x x x x x x x libpciaccess/0.17-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libpng/","title":"libpng","text":"<p>libpng is the official PNG reference library</p> <p>http://www.libpng.org/pub/png/libpng.html</p>"},{"location":"available_software/detail/libpng/#available-modules","title":"Available modules","text":"<p>The overview below shows which libpng installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libpng, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libpng/1.6.40-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libpng/1.6.40-GCCcore-13.2.0 x x x x x x x x x x x libpng/1.6.39-GCCcore-12.3.0 x x x x x x x x x x x libpng/1.6.38-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/librosa/","title":"librosa","text":"<p>Audio and music processing in Python</p> <p>https://librosa.org/</p>"},{"location":"available_software/detail/librosa/#available-modules","title":"Available modules","text":"<p>The overview below shows which librosa installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using librosa, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load librosa/0.10.1-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 librosa/0.10.1-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/librosa/#librosa0101-foss-2023a","title":"librosa/0.10.1-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>audioread-3.0.1, lazy_loader-0.3, librosa-0.10.1, resampy-0.4.3, soundfile-0.12.1, soxr-0.3.7</p>"},{"location":"available_software/detail/libsndfile/","title":"libsndfile","text":"<p>Libsndfile is a C library for reading and writing files containing sampled sound (such as MS Windows WAV and the Apple/SGI AIFF format) through one standard library interface.</p> <p>http://www.mega-nerd.com/libsndfile</p>"},{"location":"available_software/detail/libsndfile/#available-modules","title":"Available modules","text":"<p>The overview below shows which libsndfile installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libsndfile, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libsndfile/1.2.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libsndfile/1.2.2-GCCcore-13.2.0 x x x x x x x x x x x libsndfile/1.2.2-GCCcore-12.3.0 x x x x x x x x x x x libsndfile/1.2.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libsodium/","title":"libsodium","text":"<p>Sodium is a modern, easy-to-use software library for encryption, decryption, signatures, password hashing and more.</p> <p>https://doc.libsodium.org/</p>"},{"location":"available_software/detail/libsodium/#available-modules","title":"Available modules","text":"<p>The overview below shows which libsodium installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libsodium, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libsodium/1.0.19-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libsodium/1.0.19-GCCcore-13.2.0 x x x x x x x x x x x libsodium/1.0.18-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/libspatialindex/","title":"libspatialindex","text":"<p>C++ implementation of R*-tree, an MVR-tree and a TPR-tree with C API</p> <p>https://libspatialindex.org</p>"},{"location":"available_software/detail/libspatialindex/#available-modules","title":"Available modules","text":"<p>The overview below shows which libspatialindex installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libspatialindex, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libspatialindex/1.9.3-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libspatialindex/1.9.3-GCCcore-13.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libtirpc/","title":"libtirpc","text":"<p>Libtirpc is a port of Suns Transport-Independent RPC library to Linux.</p> <p>https://sourceforge.net/projects/libtirpc/</p>"},{"location":"available_software/detail/libtirpc/#available-modules","title":"Available modules","text":"<p>The overview below shows which libtirpc installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libtirpc, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libtirpc/1.3.4-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libtirpc/1.3.4-GCCcore-13.2.0 x x x x x x x x x x x libtirpc/1.3.3-GCCcore-12.3.0 x x x x x x x x x x x libtirpc/1.3.3-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libunwind/","title":"libunwind","text":"<p>The primary goal of libunwind is to define a portable and efficient C programming interface (API) to determine the call-chain of a program. The API additionally provides the means to manipulate the preserved (callee-saved) state of each call-frame and to resume execution at any point in the call-chain (non-local goto). The API supports both local (same-process) and remote (across-process) operation. As such, the API is useful in a number of applications</p> <p>https://www.nongnu.org/libunwind/</p>"},{"location":"available_software/detail/libunwind/#available-modules","title":"Available modules","text":"<p>The overview below shows which libunwind installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libunwind, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libunwind/1.6.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libunwind/1.6.2-GCCcore-13.2.0 x x x x x x x x x x x libunwind/1.6.2-GCCcore-12.3.0 x x x x x x x x x x x libunwind/1.6.2-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libvorbis/","title":"libvorbis","text":"<p>Ogg Vorbis is a fully open, non-proprietary, patent-and-royalty-free, general-purpose compressedaudio format</p> <p>https://xiph.org/vorbis/</p>"},{"location":"available_software/detail/libvorbis/#available-modules","title":"Available modules","text":"<p>The overview below shows which libvorbis installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libvorbis, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libvorbis/1.3.7-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libvorbis/1.3.7-GCCcore-13.2.0 x x x x x x x x x x x libvorbis/1.3.7-GCCcore-12.3.0 x x x x x x x x x x x libvorbis/1.3.7-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libvori/","title":"libvori","text":"<p>C++ library implementing the Voronoi integration as well as the compressed bqbfile format. The present version of libvori is a very early developmentversion, which is hard-coded to work with the CP2k program package.</p> <p>https://brehm-research.de/libvori.php</p>"},{"location":"available_software/detail/libvori/#available-modules","title":"Available modules","text":"<p>The overview below shows which libvori installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libvori, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libvori/220621-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libvori/220621-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/libwebp/","title":"libwebp","text":"<p>WebP is a modern image format that provides superiorlossless and lossy compression for images on the web. Using WebP,webmasters and web developers can create smaller, richer images thatmake the web faster.</p> <p>https://developers.google.com/speed/webp/</p>"},{"location":"available_software/detail/libwebp/#available-modules","title":"Available modules","text":"<p>The overview below shows which libwebp installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libwebp, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libwebp/1.3.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libwebp/1.3.2-GCCcore-13.2.0 x x x x x x x x x x x libwebp/1.3.1-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/libxc/","title":"libxc","text":"<p>Libxc is a library of exchange-correlation functionals for density-functional theory. The aim is to provide a portable, well tested and reliable set of exchange and correlation functionals.</p> <p>https://www.tddft.org/programs/libxc</p>"},{"location":"available_software/detail/libxc/#available-modules","title":"Available modules","text":"<p>The overview below shows which libxc installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libxc, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libxc/6.2.2-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libxc/6.2.2-GCC-12.3.0 x x x x x x x x x x x libxc/6.1.0-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libxml2-python/","title":"libxml2-python","text":"<p>Libxml2 is the XML C parser and toolchain developed for the Gnome project (but usable outside of the Gnome platform). This is the Python binding.</p> <p>http://xmlsoft.org/</p>"},{"location":"available_software/detail/libxml2-python/#available-modules","title":"Available modules","text":"<p>The overview below shows which libxml2-python installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libxml2-python, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libxml2-python/2.11.4-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libxml2-python/2.11.4-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/libxml2/","title":"libxml2","text":"<p>Libxml2 is the XML C parser and toolchain developed for the Gnome project (but usable outside of the Gnome platform).</p> <p>http://xmlsoft.org/</p>"},{"location":"available_software/detail/libxml2/#available-modules","title":"Available modules","text":"<p>The overview below shows which libxml2 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libxml2, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libxml2/2.11.5-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libxml2/2.11.5-GCCcore-13.2.0 x x x x x x x x x x x libxml2/2.11.4-GCCcore-12.3.0 x x x x x x x x x x x libxml2/2.10.3-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libxslt/","title":"libxslt","text":"<p>Libxslt is the XSLT C library developed for the GNOME project (but usable outside of the Gnome platform).</p> <p>http://xmlsoft.org/</p>"},{"location":"available_software/detail/libxslt/#available-modules","title":"Available modules","text":"<p>The overview below shows which libxslt installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libxslt, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libxslt/1.1.38-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libxslt/1.1.38-GCCcore-13.2.0 x x x x x x x x x x x libxslt/1.1.38-GCCcore-12.3.0 x x x x x x x x x x x libxslt/1.1.37-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/libxsmm/","title":"libxsmm","text":"<p>LIBXSMM is a library for small dense and small sparse matrix-matrix multiplicationstargeting Intel Architecture (x86).</p> <p>https://github.com/hfp/libxsmm</p>"},{"location":"available_software/detail/libxsmm/#available-modules","title":"Available modules","text":"<p>The overview below shows which libxsmm installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libxsmm, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libxsmm/1.17-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libxsmm/1.17-GCC-12.3.0 - - - - x x x x x x x"},{"location":"available_software/detail/libyaml/","title":"libyaml","text":"<p>LibYAML is a YAML parser and emitter written in C.</p> <p>https://pyyaml.org/wiki/LibYAML</p>"},{"location":"available_software/detail/libyaml/#available-modules","title":"Available modules","text":"<p>The overview below shows which libyaml installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using libyaml, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load libyaml/0.2.5-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 libyaml/0.2.5-GCCcore-13.2.0 x x x x x x x x x x x libyaml/0.2.5-GCCcore-12.3.0 x x x x x x x x x x x libyaml/0.2.5-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/lit/","title":"lit","text":"<p>lit is a portable tool for executing LLVM and Clang style test suites, summarizing their results, andproviding indication of failures.</p> <p>https://llvm.org/docs/CommandGuide/lit.html</p>"},{"location":"available_software/detail/lit/#available-modules","title":"Available modules","text":"<p>The overview below shows which lit installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using lit, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load lit/18.1.7-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 lit/18.1.7-GCCcore-13.2.0 x x x x x x x x x x x lit/18.1.2-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/lit/#lit1817-gcccore-1320","title":"lit/18.1.7-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>lit-18.1.7, pexpect-4.9.0, ptyprocess-0.7.0</p>"},{"location":"available_software/detail/lit/#lit1812-gcccore-1230","title":"lit/18.1.2-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>lit-18.1.2</p>"},{"location":"available_software/detail/lpsolve/","title":"lpsolve","text":"<p>Mixed Integer Linear Programming (MILP) solver</p> <p>https://sourceforge.net/projects/lpsolve/</p>"},{"location":"available_software/detail/lpsolve/#available-modules","title":"Available modules","text":"<p>The overview below shows which lpsolve installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using lpsolve, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load lpsolve/5.5.2.11-GCC-12.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 lpsolve/5.5.2.11-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/lxml/","title":"lxml","text":"<p>The lxml XML toolkit is a Pythonic binding for the C libraries libxml2 and libxslt.</p> <p>https://lxml.de/</p>"},{"location":"available_software/detail/lxml/#available-modules","title":"Available modules","text":"<p>The overview below shows which lxml installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using lxml, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load lxml/4.9.3-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 lxml/4.9.3-GCCcore-13.2.0 x x x x x x x x x x x lxml/4.9.2-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/lz4/","title":"lz4","text":"<p>LZ4 is lossless compression algorithm, providing compression speed at 400 MB/s per core. It features an extremely fast decoder, with speed in multiple GB/s per core.</p> <p>https://lz4.github.io/lz4/</p>"},{"location":"available_software/detail/lz4/#available-modules","title":"Available modules","text":"<p>The overview below shows which lz4 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using lz4, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load lz4/1.9.4-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 lz4/1.9.4-GCCcore-13.2.0 x x x x x x x x x x x lz4/1.9.4-GCCcore-12.3.0 x x x x x x x x x x x lz4/1.9.4-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/make/","title":"make","text":"<p>GNU version of make utility</p> <p>https://www.gnu.org/software/make/make.html</p>"},{"location":"available_software/detail/make/#available-modules","title":"Available modules","text":"<p>The overview below shows which make installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using make, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load make/4.4.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 make/4.4.1-GCCcore-13.2.0 x x x x x x x x x x x make/4.4.1-GCCcore-12.3.0 x x x x x x x x x x x make/4.3-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/mallard-ducktype/","title":"mallard-ducktype","text":"<p>Parser for the lightweight Ducktype syntax for Mallard</p> <p>https://github.com/projectmallard/mallard-ducktype</p>"},{"location":"available_software/detail/mallard-ducktype/#available-modules","title":"Available modules","text":"<p>The overview below shows which mallard-ducktype installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using mallard-ducktype, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load mallard-ducktype/1.0.2-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 mallard-ducktype/1.0.2-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/matplotlib/","title":"matplotlib","text":"<p>matplotlib is a python 2D plotting library which produces publication quality figures in a variety of hardcopy formats and interactive environments across platforms. matplotlib can be used in python scripts, the python and ipython shell, web application servers, and six graphical user interface toolkits.</p> <p>https://matplotlib.org</p>"},{"location":"available_software/detail/matplotlib/#available-modules","title":"Available modules","text":"<p>The overview below shows which matplotlib installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using matplotlib, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load matplotlib/3.8.2-gfbf-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 matplotlib/3.8.2-gfbf-2023b x x x x x x x x x x x matplotlib/3.7.2-gfbf-2023a x x x x x x x x x x x matplotlib/3.7.0-gfbf-2022b x x x x x x x x x x x"},{"location":"available_software/detail/matplotlib/#matplotlib382-gfbf-2023b","title":"matplotlib/3.8.2-gfbf-2023b","text":"<p>This is a list of extensions included in the module:</p> <p>contourpy-1.2.0, Cycler-0.12.1, fonttools-4.47.0, kiwisolver-1.4.5, matplotlib-3.8.2</p>"},{"location":"available_software/detail/matplotlib/#matplotlib372-gfbf-2023a","title":"matplotlib/3.7.2-gfbf-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>contourpy-1.1.0, Cycler-0.11.0, fonttools-4.42.0, kiwisolver-1.4.4, matplotlib-3.7.2</p>"},{"location":"available_software/detail/matplotlib/#matplotlib370-gfbf-2022b","title":"matplotlib/3.7.0-gfbf-2022b","text":"<p>This is a list of extensions included in the module:</p> <p>contourpy-1.0.7, Cycler-0.11.0, fonttools-4.38.0, kiwisolver-1.4.4, matplotlib-3.7.0</p>"},{"location":"available_software/detail/maturin/","title":"maturin","text":"<p>This project is meant as a zero configurationreplacement for setuptools-rust and milksnake. It supports buildingwheels for python 3.5+ on windows, linux, mac and freebsd, can uploadthem to pypi and has basic pypy and graalpy support.</p> <p>https://github.com/pyo3/maturin</p>"},{"location":"available_software/detail/maturin/#available-modules","title":"Available modules","text":"<p>The overview below shows which maturin installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using maturin, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load maturin/1.5.0-GCCcore-13.2.0-Rust-1.76.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 maturin/1.5.0-GCCcore-13.2.0-Rust-1.76.0 x x x x x x x x x x x maturin/1.4.0-GCCcore-12.3.0-Rust-1.75.0 x x x x x x x x x x x maturin/1.1.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/mctc-lib/","title":"mctc-lib","text":"<p>Common tool chain for working with molecular structure data in variousapplications. This library provides a unified way to perform operations onmolecular structure data, like reading and writing to common geometry fileformats.</p> <p>https://grimme-lab.github.io/mctc-lib</p>"},{"location":"available_software/detail/mctc-lib/#available-modules","title":"Available modules","text":"<p>The overview below shows which mctc-lib installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using mctc-lib, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load mctc-lib/0.3.1-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 mctc-lib/0.3.1-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/meson-python/","title":"meson-python","text":"<p>Python build backend (PEP 517) for Meson projects</p> <p>https://github.com/mesonbuild/meson-python</p>"},{"location":"available_software/detail/meson-python/#available-modules","title":"Available modules","text":"<p>The overview below shows which meson-python installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using meson-python, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load meson-python/0.15.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 meson-python/0.15.0-GCCcore-13.2.0 x x x x x x x x x x x meson-python/0.15.0-GCCcore-12.3.0 x x x x x x x x x x x meson-python/0.13.2-GCCcore-12.3.0 x x x x x x x x x x x meson-python/0.11.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/meson-python/#meson-python0150-gcccore-1320","title":"meson-python/0.15.0-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>meson-python-0.15.0, pyproject-metadata-0.7.1</p>"},{"location":"available_software/detail/meson-python/#meson-python0150-gcccore-1230","title":"meson-python/0.15.0-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>meson-python-0.15.0, pyproject-metadata-0.7.1</p>"},{"location":"available_software/detail/meson-python/#meson-python0132-gcccore-1230","title":"meson-python/0.13.2-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>meson-python-0.13.2, pyproject-metadata-0.7.1</p>"},{"location":"available_software/detail/meson-python/#meson-python0110-gcccore-1220","title":"meson-python/0.11.0-GCCcore-12.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>meson-python-0.11.0, pyproject-metadata-0.6.1</p>"},{"location":"available_software/detail/mpi4py/","title":"mpi4py","text":"<p>MPI for Python (mpi4py) provides bindings of the Message Passing Interface (MPI) standard for the Python programming language, allowing any Python program to exploit multiple processors.</p> <p>https://github.com/mpi4py/mpi4py</p>"},{"location":"available_software/detail/mpi4py/#available-modules","title":"Available modules","text":"<p>The overview below shows which mpi4py installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using mpi4py, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load mpi4py/3.1.5-gompi-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 mpi4py/3.1.5-gompi-2023b x x x x x x x x x x x mpi4py/3.1.4-gompi-2023a x x x x x x x x x x x mpi4py/3.1.4-gompi-2022b x x x x x x x x x x x"},{"location":"available_software/detail/mpi4py/#mpi4py315-gompi-2023b","title":"mpi4py/3.1.5-gompi-2023b","text":"<p>This is a list of extensions included in the module:</p> <p>mpi4py-3.1.5</p>"},{"location":"available_software/detail/mpi4py/#mpi4py314-gompi-2023a","title":"mpi4py/3.1.4-gompi-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>mpi4py-3.1.4</p>"},{"location":"available_software/detail/mpi4py/#mpi4py314-gompi-2022b","title":"mpi4py/3.1.4-gompi-2022b","text":"<p>This is a list of extensions included in the module:</p> <p>mpi4py-3.1.4</p>"},{"location":"available_software/detail/mpl-ascii/","title":"mpl-ascii","text":"<p>A matplotlib backend that produces plots using only ASCII characters</p> <p>https://github.com/chriscave/mpl_ascii</p>"},{"location":"available_software/detail/mpl-ascii/#available-modules","title":"Available modules","text":"<p>The overview below shows which mpl-ascii installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using mpl-ascii, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load mpl-ascii/0.10.0-gfbf-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 mpl-ascii/0.10.0-gfbf-2023a x x x x x x x x x x x"},{"location":"available_software/detail/mpl-ascii/#mpl-ascii0100-gfbf-2023a","title":"mpl-ascii/0.10.0-gfbf-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>mpl-ascii-0.10.0</p>"},{"location":"available_software/detail/mstore/","title":"mstore","text":"<p>Molecular structure store for testing</p> <p>https://github.com/grimme-lab/mstore</p>"},{"location":"available_software/detail/mstore/#available-modules","title":"Available modules","text":"<p>The overview below shows which mstore installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using mstore, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load mstore/0.3.0-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 mstore/0.3.0-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/multiprocess/","title":"multiprocess","text":"<p>better multiprocessing and multithreading in python</p> <p>https://github.com/uqfoundation/multiprocess</p>"},{"location":"available_software/detail/multiprocess/#available-modules","title":"Available modules","text":"<p>The overview below shows which multiprocess installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using multiprocess, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load multiprocess/0.70.16-gfbf-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 multiprocess/0.70.16-gfbf-2023b x x x x x x x x x x x"},{"location":"available_software/detail/ncbi-vdb/","title":"ncbi-vdb","text":"<p>The SRA Toolkit and SDK from NCBI is a collection of tools and libraries for using data in the INSDC Sequence Read Archives.</p> <p>https://github.com/ncbi/ncbi-vdb</p>"},{"location":"available_software/detail/ncbi-vdb/#available-modules","title":"Available modules","text":"<p>The overview below shows which ncbi-vdb installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ncbi-vdb, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ncbi-vdb/3.0.10-gompi-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ncbi-vdb/3.0.10-gompi-2023a x x x x x x x x x x x ncbi-vdb/3.0.5-gompi-2022b x x x x x x x x x x x"},{"location":"available_software/detail/ncdu/","title":"ncdu","text":"<p>Ncdu is a disk usage analyzer with an ncurses interface. It is designed to find space hogs on a remote server where you don't have an entire graphical setup available, but it is a useful tool even on regular desktop systems. Ncdu aims to be fast, simple and easy to use, and should be able to run in any minimal POSIX-like environment with ncurses installed.</p> <p>https://dev.yorhel.nl/ncdu</p>"},{"location":"available_software/detail/ncdu/#available-modules","title":"Available modules","text":"<p>The overview below shows which ncdu installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ncdu, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ncdu/1.18-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ncdu/1.18-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/netCDF-Fortran/","title":"netCDF-Fortran","text":"<p>NetCDF (network Common Data Form) is a set of software libraries and machine-independent data formats that support the creation, access, and sharing of array-oriented scientific data.</p> <p>https://www.unidata.ucar.edu/software/netcdf/</p>"},{"location":"available_software/detail/netCDF-Fortran/#available-modules","title":"Available modules","text":"<p>The overview below shows which netCDF-Fortran installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using netCDF-Fortran, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load netCDF-Fortran/4.6.1-gompi-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 netCDF-Fortran/4.6.1-gompi-2023a x x x x x x x x x x x netCDF-Fortran/4.6.0-gompi-2022b x x x x x x x x x x x"},{"location":"available_software/detail/netCDF/","title":"netCDF","text":"<p>NetCDF (network Common Data Form) is a set of software libraries and machine-independent data formats that support the creation, access, and sharing of array-oriented scientific data.</p> <p>https://www.unidata.ucar.edu/software/netcdf/</p>"},{"location":"available_software/detail/netCDF/#available-modules","title":"Available modules","text":"<p>The overview below shows which netCDF installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using netCDF, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load netCDF/4.9.2-gompi-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 netCDF/4.9.2-gompi-2023b x x x x x x x x x x x netCDF/4.9.2-gompi-2023a x x x x x x x x x x x netCDF/4.9.0-gompi-2022b x x x x x x x x x x x"},{"location":"available_software/detail/netcdf4-python/","title":"netcdf4-python","text":"<p>Python/numpy interface to netCDF.</p> <p>https://unidata.github.io/netcdf4-python/</p>"},{"location":"available_software/detail/netcdf4-python/#available-modules","title":"Available modules","text":"<p>The overview below shows which netcdf4-python installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using netcdf4-python, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load netcdf4-python/1.6.4-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 netcdf4-python/1.6.4-foss-2023a x x x x x x x x x x x netcdf4-python/1.6.3-foss-2022b x x x x x x x x x x x"},{"location":"available_software/detail/netcdf4-python/#netcdf4-python164-foss-2023a","title":"netcdf4-python/1.6.4-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>cftime-1.6.2, netcdf4-python-1.6.4</p>"},{"location":"available_software/detail/netcdf4-python/#netcdf4-python163-foss-2022b","title":"netcdf4-python/1.6.3-foss-2022b","text":"<p>This is a list of extensions included in the module:</p> <p>cftime-1.6.2, netcdf4-python-1.6.3</p>"},{"location":"available_software/detail/nettle/","title":"nettle","text":"<p>Nettle is a cryptographic library that is designed to fit easily in more or less any context: In crypto toolkits for object-oriented languages (C++, Python, Pike, ...), in applications like LSH or GNUPG, or even in kernel space.</p> <p>https://www.lysator.liu.se/~nisse/nettle/</p>"},{"location":"available_software/detail/nettle/#available-modules","title":"Available modules","text":"<p>The overview below shows which nettle installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using nettle, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load nettle/3.9.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 nettle/3.9.1-GCCcore-13.2.0 x x x x x x x x x x x nettle/3.9.1-GCCcore-12.3.0 x x x x x x x x x x x nettle/3.8.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/networkx/","title":"networkx","text":"<p>NetworkX is a Python package for the creation, manipulation,and study of the structure, dynamics, and functions of complex networks.</p> <p>https://pypi.python.org/pypi/networkx</p>"},{"location":"available_software/detail/networkx/#available-modules","title":"Available modules","text":"<p>The overview below shows which networkx installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using networkx, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load networkx/3.2.1-gfbf-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 networkx/3.2.1-gfbf-2023b x x x x x x x x x x x networkx/3.1-gfbf-2023a x x x x x x x x x x x networkx/3.0-gfbf-2022b x x x x x x x x x x x"},{"location":"available_software/detail/nlohmann_json/","title":"nlohmann_json","text":"<p>JSON for Modern C++</p> <p>https://github.com/nlohmann/json</p>"},{"location":"available_software/detail/nlohmann_json/#available-modules","title":"Available modules","text":"<p>The overview below shows which nlohmann_json installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using nlohmann_json, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load nlohmann_json/3.11.3-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 nlohmann_json/3.11.3-GCCcore-13.2.0 x x x x x x x x x x x nlohmann_json/3.11.2-GCCcore-12.3.0 x x x x x x x x x x x nlohmann_json/3.11.2-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/nodejs/","title":"nodejs","text":"<p>Node.js is a platform built on Chrome's JavaScript runtime for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.</p> <p>https://nodejs.org</p>"},{"location":"available_software/detail/nodejs/#available-modules","title":"Available modules","text":"<p>The overview below shows which nodejs installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using nodejs, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load nodejs/20.9.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 nodejs/20.9.0-GCCcore-13.2.0 x x x x x x x x x x x nodejs/18.17.1-GCCcore-12.3.0 x x x x x x x x x x x nodejs/18.12.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/nsync/","title":"nsync","text":"<p>nsync is a C library that exports various synchronization primitives, such as mutexes</p> <p>https://github.com/google/nsync</p>"},{"location":"available_software/detail/nsync/#available-modules","title":"Available modules","text":"<p>The overview below shows which nsync installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using nsync, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load nsync/1.26.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 nsync/1.26.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/numactl/","title":"numactl","text":"<p>The numactl program allows you to run your application program on specific cpu's and memory nodes. It does this by supplying a NUMA memory policy to the operating system before running your program. The libnuma library provides convenient ways for you to add NUMA memory policies into your own program.</p> <p>https://github.com/numactl/numactl</p>"},{"location":"available_software/detail/numactl/#available-modules","title":"Available modules","text":"<p>The overview below shows which numactl installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using numactl, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load numactl/2.0.16-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 numactl/2.0.16-GCCcore-13.2.0 x x x x x x x x x x x numactl/2.0.16-GCCcore-12.3.0 x x x x x x x x x x x numactl/2.0.16-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/numba/","title":"numba","text":"<p>Numba is an Open Source NumPy-aware optimizing compiler forPython sponsored by Continuum Analytics, Inc. It uses the remarkable LLVMcompiler infrastructure to compile Python syntax to machine code.</p> <p>https://numba.pydata.org/</p>"},{"location":"available_software/detail/numba/#available-modules","title":"Available modules","text":"<p>The overview below shows which numba installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using numba, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load numba/0.58.1-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 numba/0.58.1-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/numba/#numba0581-foss-2023a","title":"numba/0.58.1-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>llvmlite-0.41.1, numba-0.58.1</p>"},{"location":"available_software/detail/occt/","title":"occt","text":"<p>Open CASCADE Technology (OCCT) is an object-oriented C++class library designed for rapid production of sophisticated domain-specificCAD/CAM/CAE applications.</p> <p>https://www.opencascade.com/</p>"},{"location":"available_software/detail/occt/#available-modules","title":"Available modules","text":"<p>The overview below shows which occt installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using occt, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load occt/7.8.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 occt/7.8.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/orjson/","title":"orjson","text":"<p>Fast, correct Python JSON library supporting dataclasses, datetimes, and numpy.</p> <p>https://github.com/ijl/orjson</p>"},{"location":"available_software/detail/orjson/#available-modules","title":"Available modules","text":"<p>The overview below shows which orjson installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using orjson, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load orjson/3.9.15-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 orjson/3.9.15-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/orjson/#orjson3915-gcccore-1230","title":"orjson/3.9.15-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>mypy-1.10.0, mypy_extensions-1.0.0, orjson-3.9.15, ruff-0.4.8</p>"},{"location":"available_software/detail/parallel/","title":"parallel","text":"<p>parallel: Build and execute shell commands in parallel</p> <p>https://savannah.gnu.org/projects/parallel/</p>"},{"location":"available_software/detail/parallel/#available-modules","title":"Available modules","text":"<p>The overview below shows which parallel installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using parallel, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load parallel/20230722-GCCcore-12.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 parallel/20230722-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/patchelf/","title":"patchelf","text":"<p>PatchELF is a small utility to modify the dynamic linker and RPATH of ELF executables.</p> <p>https://github.com/NixOS/patchelf</p>"},{"location":"available_software/detail/patchelf/#available-modules","title":"Available modules","text":"<p>The overview below shows which patchelf installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using patchelf, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load patchelf/0.18.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 patchelf/0.18.0-GCCcore-13.2.0 x x x x x x x x x x x patchelf/0.18.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/pixman/","title":"pixman","text":"<p>Pixman is a low-level software library for pixel manipulation, providing features such as image compositing and trapezoid rasterization. Important users of pixman are the cairo graphics library and the X server.</p> <p>http://www.pixman.org/</p>"},{"location":"available_software/detail/pixman/#available-modules","title":"Available modules","text":"<p>The overview below shows which pixman installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using pixman, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load pixman/0.42.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 pixman/0.42.2-GCCcore-13.2.0 x x x x x x x x x x x pixman/0.42.2-GCCcore-12.3.0 x x x x x x x x x x x pixman/0.42.2-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/pkgconf/","title":"pkgconf","text":"<p>pkgconf is a program which helps to configure compiler and linker flags for development libraries. It is similar to pkg-config from freedesktop.org.</p> <p>https://github.com/pkgconf/pkgconf</p>"},{"location":"available_software/detail/pkgconf/#available-modules","title":"Available modules","text":"<p>The overview below shows which pkgconf installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using pkgconf, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load pkgconf/2.0.3-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 pkgconf/2.0.3-GCCcore-13.2.0 x x x x x x x x x x x pkgconf/1.9.5-GCCcore-12.3.0 x x x x x x x x x x x pkgconf/1.9.3-GCCcore-12.2.0 x x x x x x x x x x x pkgconf/1.8.0 x x x x x x x x x x x"},{"location":"available_software/detail/pkgconfig/","title":"pkgconfig","text":"<p>pkgconfig is a Python module to interface with the pkg-config command line tool</p> <p>https://github.com/matze/pkgconfig</p>"},{"location":"available_software/detail/pkgconfig/#available-modules","title":"Available modules","text":"<p>The overview below shows which pkgconfig installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using pkgconfig, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load pkgconfig/1.5.5-GCCcore-12.3.0-python\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 pkgconfig/1.5.5-GCCcore-12.3.0-python x x x x x x x x x x x pkgconfig/1.5.5-GCCcore-12.2.0-python x x x x x x x x x x x"},{"location":"available_software/detail/poetry/","title":"poetry","text":"<p>Python packaging and dependency management made easy. Poetry helps you declare, manage and install dependencies of Python projects, ensuring you have the right stack everywhere.</p> <p>https://python-poetry.org</p>"},{"location":"available_software/detail/poetry/#available-modules","title":"Available modules","text":"<p>The overview below shows which poetry installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using poetry, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load poetry/1.6.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 poetry/1.6.1-GCCcore-13.2.0 x x x x x x x x x x x poetry/1.5.1-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/poetry/#poetry161-gcccore-1320","title":"poetry/1.6.1-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>attrs-23.1.0, build-0.10.0, cachecontrol-0.13.1, certifi-2023.7.22, charset-normalizer-3.3.1, cleo-2.0.1, crashtest-0.4.1, dulwich-0.21.6, html5lib-1.1, idna-3.4, importlib_metadata-6.8.0, installer-0.7.0, jaraco.classes-3.3.0, jeepney-0.8.0, jsonschema-4.17.3, keyring-24.2.0, lockfile-0.12.2, more-itertools-10.1.0, msgpack-1.0.7, pexpect-4.8.0, pkginfo-1.9.6, platformdirs-3.11.0, poetry-1.6.1, poetry_core-1.7.0, poetry_plugin_export-1.5.0, ptyprocess-0.7.0, pyproject_hooks-1.0.0, pyrsistent-0.20.0, rapidfuzz-2.15.2, requests-2.31.0, requests-toolbelt-1.0.0, SecretStorage-3.3.3, shellingham-1.5.4, six-1.16.0, tomlkit-0.12.1, urllib3-2.0.7, webencodings-0.5.1, zipp-3.17.0</p>"},{"location":"available_software/detail/poetry/#poetry151-gcccore-1230","title":"poetry/1.5.1-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>attrs-23.1.0, build-0.10.0, CacheControl-0.12.14, certifi-2023.5.7, charset-normalizer-3.1.0, cleo-2.0.1, crashtest-0.4.1, dulwich-0.21.5, html5lib-1.1, idna-3.4, importlib_metadata-6.7.0, installer-0.7.0, jaraco.classes-3.2.3, jeepney-0.8.0, jsonschema-4.17.3, keyring-23.13.1, lockfile-0.12.2, more-itertools-9.1.0, msgpack-1.0.5, pexpect-4.8.0, pkginfo-1.9.6, platformdirs-3.8.0, poetry-1.5.1, poetry_core-1.6.1, poetry_plugin_export-1.4.0, ptyprocess-0.7.0, pyproject_hooks-1.0.0, pyrsistent-0.19.3, rapidfuzz-2.15.1, requests-2.31.0, requests-toolbelt-1.0.0, SecretStorage-3.3.3, shellingham-1.5.0, six-1.16.0, tomlkit-0.11.8, urllib3-1.26.16, webencodings-0.5.1, zipp-3.15.0</p>"},{"location":"available_software/detail/pre-commit/","title":"pre-commit","text":"<p>A framework for managing and maintaining multi-language pre-commit hooks.Git hook scripts are useful for identifying simple issues before submission to code review. We run our hooks on every commit to automatically point out issues in code such as missing semicolons, trailing whitespace, and debug statements. By pointing these issues out before code review, this allows a code reviewer to focus on the architecture of a change while not wasting time with trivial style nitpicks.</p> <p>https://pre-commit.com/</p>"},{"location":"available_software/detail/pre-commit/#available-modules","title":"Available modules","text":"<p>The overview below shows which pre-commit installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using pre-commit, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load pre-commit/3.7.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 pre-commit/3.7.0-GCCcore-13.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/pre-commit/#pre-commit370-gcccore-1320","title":"pre-commit/3.7.0-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>cfgv-3.4.0, identify-2.5.35, nodeenv-1.8.0, pre-commit-3.7.0</p>"},{"location":"available_software/detail/protobuf-python/","title":"protobuf-python","text":"<p>Python Protocol Buffers runtime library.</p> <p>https://github.com/google/protobuf/</p>"},{"location":"available_software/detail/protobuf-python/#available-modules","title":"Available modules","text":"<p>The overview below shows which protobuf-python installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using protobuf-python, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load protobuf-python/4.24.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 protobuf-python/4.24.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/protobuf/","title":"protobuf","text":"<p>Protocol Buffers (a.k.a., protobuf) are Google's language-neutral, platform-neutral, extensible mechanism for serializing structured data.</p> <p>https://github.com/protocolbuffers/protobuf</p>"},{"location":"available_software/detail/protobuf/#available-modules","title":"Available modules","text":"<p>The overview below shows which protobuf installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using protobuf, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load protobuf/24.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 protobuf/24.0-GCCcore-12.3.0 x x x x x x x x x x x protobuf/23.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/psycopg2/","title":"psycopg2","text":"<p>Psycopg is the most popular PostgreSQL adapter for the Python programming language.</p> <p>https://psycopg.org/</p>"},{"location":"available_software/detail/psycopg2/#available-modules","title":"Available modules","text":"<p>The overview below shows which psycopg2 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using psycopg2, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load psycopg2/2.9.9-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 psycopg2/2.9.9-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/psycopg2/#psycopg2299-gcccore-1230","title":"psycopg2/2.9.9-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>psycopg2-2.9.9</p>"},{"location":"available_software/detail/pyMBE/","title":"pyMBE","text":"<p>pyMBE: the Python-based Molecule Builder for ESPResSopyMBE provides tools to facilitate building up molecules with complex architecturesin the Molecular Dynamics software ESPResSo.</p>"},{"location":"available_software/detail/pyMBE/#available-modules","title":"Available modules","text":"<p>The overview below shows which pyMBE installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using pyMBE, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load pyMBE/0.8.0-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 pyMBE/0.8.0-foss-2023b x x x x x x x x x x x"},{"location":"available_software/detail/pyMBE/#pymbe080-foss-2023b","title":"pyMBE/0.8.0-foss-2023b","text":"<p>This is a list of extensions included in the module:</p> <p>biopandas-0.5.1.dev0, looseversion-1.1.2, mmtf-python-1.1.3, Pint-Pandas-0.5, pyMBE-0.8.0</p>"},{"location":"available_software/detail/pybind11/","title":"pybind11","text":"<p>pybind11 is a lightweight header-only library that exposes C++ types in Python and vice versa, mainly to create Python bindings of existing C++ code.</p> <p>https://pybind11.readthedocs.io</p>"},{"location":"available_software/detail/pybind11/#available-modules","title":"Available modules","text":"<p>The overview below shows which pybind11 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using pybind11, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load pybind11/2.11.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 pybind11/2.11.1-GCCcore-13.2.0 x x x x x x x x x x x pybind11/2.11.1-GCCcore-12.3.0 x x x x x x x x x x x pybind11/2.10.3-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/pydantic/","title":"pydantic","text":"<p>Data validation and settings management using Python type hinting.</p> <p>https://github.com/samuelcolvin/pydantic</p>"},{"location":"available_software/detail/pydantic/#available-modules","title":"Available modules","text":"<p>The overview below shows which pydantic installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using pydantic, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load pydantic/2.7.4-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 pydantic/2.7.4-GCCcore-13.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/pydantic/#pydantic274-gcccore-1320","title":"pydantic/2.7.4-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>annotated_types-0.6.0, pydantic-2.7.4, pydantic_core-2.18.4</p>"},{"location":"available_software/detail/pyfaidx/","title":"pyfaidx","text":"<p>pyfaidx: efficient pythonic random access to fasta subsequences</p> <p>https://pypi.python.org/pypi/pyfaidx</p>"},{"location":"available_software/detail/pyfaidx/#available-modules","title":"Available modules","text":"<p>The overview below shows which pyfaidx installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using pyfaidx, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load pyfaidx/0.8.1.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 pyfaidx/0.8.1.1-GCCcore-13.2.0 x x x x x x x x x x x pyfaidx/0.8.1.1-GCCcore-12.3.0 x x x x x x x x x x x pyfaidx/0.7.2.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/pyfaidx/#pyfaidx0811-gcccore-1230","title":"pyfaidx/0.8.1.1-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>importlib_metadata-7.0.1, pyfaidx-0.8.1.1, zipp-3.17.0</p>"},{"location":"available_software/detail/pyproj/","title":"pyproj","text":"<p>Python interface to PROJ4 library for cartographic transformations</p> <p>https://pyproj4.github.io/pyproj</p>"},{"location":"available_software/detail/pyproj/#available-modules","title":"Available modules","text":"<p>The overview below shows which pyproj installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using pyproj, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load pyproj/3.6.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 pyproj/3.6.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/pystencils/","title":"pystencils","text":"<p>pystencils uses sympy to define stencil operations, that can be executed on numpy arrays</p> <p>https://pycodegen.pages.i10git.cs.fau.de/pystencils</p>"},{"location":"available_software/detail/pystencils/#available-modules","title":"Available modules","text":"<p>The overview below shows which pystencils installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using pystencils, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load pystencils/1.3.4-gfbf-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 pystencils/1.3.4-gfbf-2023b x x x x x x x x x x x"},{"location":"available_software/detail/pystencils/#pystencils134-gfbf-2023b","title":"pystencils/1.3.4-gfbf-2023b","text":"<p>This is a list of extensions included in the module:</p> <p>pystencils-1.3.4</p>"},{"location":"available_software/detail/pytest-flakefinder/","title":"pytest-flakefinder","text":"<p>Runs tests multiple times to expose flakiness.</p> <p>https://github.com/dropbox/pytest-flakefinder</p>"},{"location":"available_software/detail/pytest-flakefinder/#available-modules","title":"Available modules","text":"<p>The overview below shows which pytest-flakefinder installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using pytest-flakefinder, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load pytest-flakefinder/1.1.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 pytest-flakefinder/1.1.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/pytest-rerunfailures/","title":"pytest-rerunfailures","text":"<p>pytest plugin to re-run tests to eliminate flaky failures.</p> <p>https://github.com/pytest-dev/pytest-rerunfailures</p>"},{"location":"available_software/detail/pytest-rerunfailures/#available-modules","title":"Available modules","text":"<p>The overview below shows which pytest-rerunfailures installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using pytest-rerunfailures, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load pytest-rerunfailures/12.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 pytest-rerunfailures/12.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/pytest-shard/","title":"pytest-shard","text":"<p>pytest plugin to support parallelism across multiple machines.Shards tests based on a hash of their test name enabling easy parallelism across machines,suitable for a wide variety of continuous integration services.Tests are split at the finest level of granularity, individual test cases,enabling parallelism even if all of your tests are in a single file(or even single parameterized test method).</p> <p>https://github.com/AdamGleave/pytest-shard</p>"},{"location":"available_software/detail/pytest-shard/#available-modules","title":"Available modules","text":"<p>The overview below shows which pytest-shard installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using pytest-shard, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load pytest-shard/0.1.2-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 pytest-shard/0.1.2-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/python-casacore/","title":"python-casacore","text":"<p>Python-casacore is a set of Python bindings for casacore,a c++ library used in radio astronomy. Python-casacore replaces the old pyrap.</p> <p>https://casacore.github.io/python-casacore/#</p>"},{"location":"available_software/detail/python-casacore/#available-modules","title":"Available modules","text":"<p>The overview below shows which python-casacore installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using python-casacore, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load python-casacore/3.5.2-foss-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 python-casacore/3.5.2-foss-2023b x x x x x x x x x x x"},{"location":"available_software/detail/python-casacore/#python-casacore352-foss-2023b","title":"python-casacore/3.5.2-foss-2023b","text":"<p>This is a list of extensions included in the module:</p> <p>python-casacore-3.5.2, setuptools-69.1.0</p>"},{"location":"available_software/detail/python-isal/","title":"python-isal","text":"<p>Faster zlib and gzip compatible compression and decompression by providing python bindings for the isa-l library.</p> <p>https://github.com/pycompression/python-isal</p>"},{"location":"available_software/detail/python-isal/#available-modules","title":"Available modules","text":"<p>The overview below shows which python-isal installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using python-isal, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load python-isal/1.1.0-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 python-isal/1.1.0-GCCcore-12.3.0 x x x x x x x x x x x python-isal/1.1.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/python-xxhash/","title":"python-xxhash","text":"<p>xxhash is a Python binding for the xxHash library by Yann Collet.</p> <p>https://github.com/ifduyue/python-xxhash</p>"},{"location":"available_software/detail/python-xxhash/#available-modules","title":"Available modules","text":"<p>The overview below shows which python-xxhash installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using python-xxhash, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load python-xxhash/3.4.1-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 python-xxhash/3.4.1-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/python-xxhash/#python-xxhash341-gcccore-1230","title":"python-xxhash/3.4.1-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>xxhash-3.4.1</p>"},{"location":"available_software/detail/re2c/","title":"re2c","text":"<p>re2c is a free and open-source lexer generator for C and C++. Its main goal is generatingfast lexers: at least as fast as their reasonably optimized hand-coded counterparts. Instead of usingtraditional table-driven approach, re2c encodes the generated finite state automata directly in the formof conditional jumps and comparisons.</p> <p>https://re2c.org</p>"},{"location":"available_software/detail/re2c/#available-modules","title":"Available modules","text":"<p>The overview below shows which re2c installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using re2c, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load re2c/3.1-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 re2c/3.1-GCCcore-13.2.0 x x x x x x x x x x x re2c/3.1-GCCcore-12.3.0 x x x x x x x x x x x re2c/3.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/rpy2/","title":"rpy2","text":"<p>rpy2 is an interface to R running embedded in a Python process.</p> <p>https://rpy2.github.io</p>"},{"location":"available_software/detail/rpy2/#available-modules","title":"Available modules","text":"<p>The overview below shows which rpy2 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using rpy2, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load rpy2/3.5.15-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 rpy2/3.5.15-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/rpy2/#rpy23515-foss-2023a","title":"rpy2/3.5.15-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>coverage-7.4.3, pytest-cov-4.1.0, rpy2-3.5.15, tzlocal-5.2</p>"},{"location":"available_software/detail/ruamel.yaml/","title":"ruamel.yaml","text":"<p>ruamel.yaml is a YAML 1.2 loader/dumper package for Python.</p> <p>https://sourceforge.net/projects/ruamel-yaml</p>"},{"location":"available_software/detail/ruamel.yaml/#available-modules","title":"Available modules","text":"<p>The overview below shows which ruamel.yaml installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using ruamel.yaml, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load ruamel.yaml/0.17.32-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 ruamel.yaml/0.17.32-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/ruamel.yaml/#ruamelyaml01732-gcccore-1230","title":"ruamel.yaml/0.17.32-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>configobj-5.0.8, lz4-4.3.2, ruamel.yaml-0.17.32, ruamel.yaml.base-0.3.2, ruamel.yaml.clib-0.2.7, ruamel.yaml.cmd-0.6.5, ruamel.yaml.convert-0.3.2</p>"},{"location":"available_software/detail/scikit-build-core/","title":"scikit-build-core","text":"<p>Scikit-build-core is a complete ground-up rewrite of scikit-build on top ofmodern packaging APIs. It provides a bridge between CMake and the Python buildsystem, allowing you to make Python modules with CMake.</p> <p>https://scikit-build.readthedocs.io/en/latest/</p>"},{"location":"available_software/detail/scikit-build-core/#available-modules","title":"Available modules","text":"<p>The overview below shows which scikit-build-core installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using scikit-build-core, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load scikit-build-core/0.9.3-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 scikit-build-core/0.9.3-GCCcore-13.2.0 x x x x x x x x x x x scikit-build-core/0.9.3-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/scikit-build-core/#scikit-build-core093-gcccore-1320","title":"scikit-build-core/0.9.3-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>pyproject-metadata-0.8.0, scikit_build_core-0.9.3</p>"},{"location":"available_software/detail/scikit-build-core/#scikit-build-core093-gcccore-1230","title":"scikit-build-core/0.9.3-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>pyproject-metadata-0.8.0, scikit_build_core-0.9.3</p>"},{"location":"available_software/detail/scikit-build/","title":"scikit-build","text":"<p>Scikit-Build, or skbuild, is an improved build system generatorfor CPython C/C++/Fortran/Cython extensions.</p> <p>https://scikit-build.readthedocs.io/en/latest</p>"},{"location":"available_software/detail/scikit-build/#available-modules","title":"Available modules","text":"<p>The overview below shows which scikit-build installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using scikit-build, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load scikit-build/0.17.6-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 scikit-build/0.17.6-GCCcore-13.2.0 x x x x x x x x x x x scikit-build/0.17.6-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/scikit-build/#scikit-build0176-gcccore-1320","title":"scikit-build/0.17.6-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>distro-1.8.0, packaging-23.1, scikit_build-0.17.6</p>"},{"location":"available_software/detail/scikit-build/#scikit-build0176-gcccore-1230","title":"scikit-build/0.17.6-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>distro-1.8.0, packaging-23.1, scikit_build-0.17.6</p>"},{"location":"available_software/detail/scikit-learn/","title":"scikit-learn","text":"<p>Scikit-learn integrates machine learning algorithms in the tightly-knit scientific Python world,building upon numpy, scipy, and matplotlib. As a machine-learning module,it provides versatile tools for data mining and analysis in any field of science and engineering.It strives to be simple and efficient, accessible to everybody, and reusable in various contexts.</p> <p>https://scikit-learn.org/stable/index.html</p>"},{"location":"available_software/detail/scikit-learn/#available-modules","title":"Available modules","text":"<p>The overview below shows which scikit-learn installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using scikit-learn, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load scikit-learn/1.4.0-gfbf-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 scikit-learn/1.4.0-gfbf-2023b x x x x x x x x x x x scikit-learn/1.3.1-gfbf-2023a x x x x x x x x x x x"},{"location":"available_software/detail/scikit-learn/#scikit-learn140-gfbf-2023b","title":"scikit-learn/1.4.0-gfbf-2023b","text":"<p>This is a list of extensions included in the module:</p> <p>scikit-learn-1.4.0, sklearn-0.0</p>"},{"location":"available_software/detail/scikit-learn/#scikit-learn131-gfbf-2023a","title":"scikit-learn/1.3.1-gfbf-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>scikit-learn-1.3.1, sklearn-0.0</p>"},{"location":"available_software/detail/setuptools-rust/","title":"setuptools-rust","text":"<p>setuptools-rust is a plugin for setuptools to build Rust Python extensionsimplemented with PyO3 or rust-cpython.</p> <p>https://github.com/PyO3/setuptools-rust</p>"},{"location":"available_software/detail/setuptools-rust/#available-modules","title":"Available modules","text":"<p>The overview below shows which setuptools-rust installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using setuptools-rust, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load setuptools-rust/1.8.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 setuptools-rust/1.8.0-GCCcore-13.2.0 x x x x x x x x x x x setuptools-rust/1.6.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/setuptools-rust/#setuptools-rust180-gcccore-1320","title":"setuptools-rust/1.8.0-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>semantic_version-2.10.0, setuptools-rust-1.8.0, typing_extensions-4.8.0</p>"},{"location":"available_software/detail/setuptools-rust/#setuptools-rust160-gcccore-1230","title":"setuptools-rust/1.6.0-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>semantic_version-2.10.0, setuptools-rust-1.6.0, typing_extensions-4.6.3</p>"},{"location":"available_software/detail/setuptools/","title":"setuptools","text":"<p>Easily download, build, install, upgrade, and uninstall Python packages</p> <p>https://pypi.org/project/setuptools</p>"},{"location":"available_software/detail/setuptools/#available-modules","title":"Available modules","text":"<p>The overview below shows which setuptools installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using setuptools, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load setuptools/64.0.3-GCCcore-12.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 setuptools/64.0.3-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/siscone/","title":"siscone","text":"<p>Hadron Seedless Infrared-Safe Cone jet algorithm</p> <p>https://siscone.hepforge.org/</p>"},{"location":"available_software/detail/siscone/#available-modules","title":"Available modules","text":"<p>The overview below shows which siscone installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using siscone, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load siscone/3.0.6-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 siscone/3.0.6-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/snakemake/","title":"snakemake","text":"<p>The Snakemake workflow management system is a tool to create reproducible and scalable data analyses.</p> <p>https://snakemake.readthedocs.io</p>"},{"location":"available_software/detail/snakemake/#available-modules","title":"Available modules","text":"<p>The overview below shows which snakemake installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using snakemake, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load snakemake/8.4.2-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 snakemake/8.4.2-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/snakemake/#snakemake842-foss-2023a","title":"snakemake/8.4.2-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>argparse-dataclass-2.0.0, conda-inject-1.3.1, ConfigArgParse-1.7, connection-pool-0.0.3, datrie-0.8.2, dpath-2.1.6, fastjsonschema-2.19.1, humanfriendly-10.0, immutables-0.20, jupyter-core-5.7.1, nbformat-5.9.2, plac-1.4.2, reretry-0.11.8, smart-open-6.4.0, snakemake-8.4.2, snakemake-executor-plugin-cluster-generic-1.0.7, snakemake-executor-plugin-cluster-sync-0.1.3, snakemake-executor-plugin-flux-0.1.0, snakemake-executor-plugin-slurm-0.2.1, snakemake-executor-plugin-slurm-jobstep-0.1.10, snakemake-interface-common-1.15.2, snakemake-interface-executor-plugins-8.2.0, snakemake-interface-storage-plugins-3.0.0, stopit-1.1.2, throttler-1.2.2, toposort-1.10, yte-1.5.4</p>"},{"location":"available_software/detail/snappy/","title":"snappy","text":"<p>Snappy is a compression/decompression library. It does not aimfor maximum compression, or compatibility with any other compression library;instead, it aims for very high speeds and reasonable compression.</p> <p>https://github.com/google/snappy</p>"},{"location":"available_software/detail/snappy/#available-modules","title":"Available modules","text":"<p>The overview below shows which snappy installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using snappy, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load snappy/1.1.10-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 snappy/1.1.10-GCCcore-13.2.0 x x x x x x x x x x x snappy/1.1.10-GCCcore-12.3.0 x x x x x x x x x x x snappy/1.1.9-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/spglib-python/","title":"spglib-python","text":"<p>Spglib for Python. Spglib is a library for finding and handling crystal symmetries written in C.</p> <p>https://pypi.python.org/pypi/spglib</p>"},{"location":"available_software/detail/spglib-python/#available-modules","title":"Available modules","text":"<p>The overview below shows which spglib-python installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using spglib-python, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load spglib-python/2.0.2-gfbf-2022b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 spglib-python/2.0.2-gfbf-2022b x x x x x x x x x x x"},{"location":"available_software/detail/statsmodels/","title":"statsmodels","text":"<p>Statsmodels is a Python module that allows users to explore data, estimate statistical models,and perform statistical tests.</p> <p>https://www.statsmodels.org/</p>"},{"location":"available_software/detail/statsmodels/#available-modules","title":"Available modules","text":"<p>The overview below shows which statsmodels installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using statsmodels, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load statsmodels/0.14.1-gfbf-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 statsmodels/0.14.1-gfbf-2023b x x x x x x x x x x x statsmodels/0.14.1-gfbf-2023a x x x x x x x x x x x"},{"location":"available_software/detail/statsmodels/#statsmodels0141-gfbf-2023b","title":"statsmodels/0.14.1-gfbf-2023b","text":"<p>This is a list of extensions included in the module:</p> <p>patsy-0.5.6, statsmodels-0.14.1</p>"},{"location":"available_software/detail/statsmodels/#statsmodels0141-gfbf-2023a","title":"statsmodels/0.14.1-gfbf-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>patsy-0.5.6, statsmodels-0.14.1</p>"},{"location":"available_software/detail/sympy/","title":"sympy","text":"<p>SymPy is a Python library for symbolic mathematics. It aims to become a full-featured computer algebra system (CAS) while keeping the code as simple as possible in order to be comprehensible and easily extensible. SymPy is written entirely in Python and does not require any external libraries.</p> <p>https://sympy.org/</p>"},{"location":"available_software/detail/sympy/#available-modules","title":"Available modules","text":"<p>The overview below shows which sympy installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using sympy, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load sympy/1.12-gfbf-2023b\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 sympy/1.12-gfbf-2023b x x x x x x x x x x x sympy/1.12-gfbf-2023a x x x x x x x x x x x"},{"location":"available_software/detail/tbb/","title":"tbb","text":"<p>Intel(R) Threading Building Blocks (Intel(R) TBB) lets you easily write parallel C++ programs that take full advantage of multicore performance, that are portable, composable and have future-proof scalability.</p> <p>https://github.com/oneapi-src/oneTBB</p>"},{"location":"available_software/detail/tbb/#available-modules","title":"Available modules","text":"<p>The overview below shows which tbb installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using tbb, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load tbb/2021.13.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 tbb/2021.13.0-GCCcore-13.2.0 - - - - x x x x x x x tbb/2021.11.0-GCCcore-12.3.0 x x x x x x x x x x x tbb/2021.10.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/tcsh/","title":"tcsh","text":"<p>Tcsh is an enhanced, but completely compatible version of the Berkeley UNIX C shell (csh). It is a command language interpreter usable both as an interactive login shell and a shell script command processor. It includes a command-line editor, programmable word completion, spelling correction, a history mechanism, job control and a C-like syntax.</p> <p>https://www.tcsh.org</p>"},{"location":"available_software/detail/tcsh/#available-modules","title":"Available modules","text":"<p>The overview below shows which tcsh installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using tcsh, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load tcsh/6.24.07-GCCcore-12.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 tcsh/6.24.07-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/test-drive/","title":"test-drive","text":"<p>This project offers a lightweight, procedural unit testing framework based on nothing but standard Fortran.</p> <p>https://github.com/fortran-lang/test-drive</p>"},{"location":"available_software/detail/test-drive/#available-modules","title":"Available modules","text":"<p>The overview below shows which test-drive installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using test-drive, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load test-drive/0.5.0-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 test-drive/0.5.0-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/time/","title":"time","text":"<p>The `time' command runs another program, then displays information about the resources used by that program, collected by the system while the program was running.</p> <p>https://www.gnu.org/software/time/</p>"},{"location":"available_software/detail/time/#available-modules","title":"Available modules","text":"<p>The overview below shows which time installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using time, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load time/1.9-GCCcore-12.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 time/1.9-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/tmux/","title":"tmux","text":"<p>tmux is a terminal multiplexer: it enables a number ofterminals to be created, accessed, and controlled from a single screen. tmuxmay be detached from a screen and continue running in the background, thenlater reattached.</p> <p>https://github.com/tmux/tmux/</p>"},{"location":"available_software/detail/tmux/#available-modules","title":"Available modules","text":"<p>The overview below shows which tmux installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using tmux, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load tmux/3.3a-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 tmux/3.3a-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/tornado/","title":"tornado","text":"<p>Tornado is a Python web framework and asynchronous networking library.</p> <p>https://github.com/tornadoweb/tornado</p>"},{"location":"available_software/detail/tornado/#available-modules","title":"Available modules","text":"<p>The overview below shows which tornado installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using tornado, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load tornado/6.3.2-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 tornado/6.3.2-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/tqdm/","title":"tqdm","text":"<p>A fast, extensible progress bar for Python and CLI</p> <p>https://github.com/tqdm/tqdm</p>"},{"location":"available_software/detail/tqdm/#available-modules","title":"Available modules","text":"<p>The overview below shows which tqdm installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using tqdm, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load tqdm/4.66.2-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 tqdm/4.66.2-GCCcore-13.2.0 x x x x x x x x x x x tqdm/4.66.1-GCCcore-12.3.0 x x x x x x x x x x x tqdm/4.64.1-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/typing-extensions/","title":"typing-extensions","text":"<p>Typing Extensions - Backported and Experimental Type Hints for Python</p> <p>https://github.com/python/typing_extensions</p>"},{"location":"available_software/detail/typing-extensions/#available-modules","title":"Available modules","text":"<p>The overview below shows which typing-extensions installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using typing-extensions, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load typing-extensions/4.10.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 typing-extensions/4.10.0-GCCcore-13.2.0 x x x x x x x x x x x typing-extensions/4.9.0-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/unixODBC/","title":"unixODBC","text":"<p>unixODBC provides a uniform interface betweenapplication and database driver</p> <p>https://www.unixodbc.org</p>"},{"location":"available_software/detail/unixODBC/#available-modules","title":"Available modules","text":"<p>The overview below shows which unixODBC installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using unixODBC, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load unixODBC/2.3.12-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 unixODBC/2.3.12-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/utf8proc/","title":"utf8proc","text":"<p>utf8proc is a small, clean C library that provides Unicode normalization, case-folding, and other operations for data in the UTF-8 encoding.</p> <p>https://github.com/JuliaStrings/utf8proc</p>"},{"location":"available_software/detail/utf8proc/#available-modules","title":"Available modules","text":"<p>The overview below shows which utf8proc installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using utf8proc, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load utf8proc/2.9.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 utf8proc/2.9.0-GCCcore-13.2.0 x x x x x x x x x x x utf8proc/2.8.0-GCCcore-12.3.0 x x x x x x x x x x x utf8proc/2.8.0-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/virtualenv/","title":"virtualenv","text":"<p>A tool for creating isolated virtual python environments.</p> <p>https://github.com/pypa/virtualenv</p>"},{"location":"available_software/detail/virtualenv/#available-modules","title":"Available modules","text":"<p>The overview below shows which virtualenv installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using virtualenv, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load virtualenv/20.24.6-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 virtualenv/20.24.6-GCCcore-13.2.0 x x x x x x x x x x x virtualenv/20.23.1-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/virtualenv/#virtualenv20246-gcccore-1320","title":"virtualenv/20.24.6-GCCcore-13.2.0","text":"<p>This is a list of extensions included in the module:</p> <p>distlib-0.3.7, filelock-3.13.0, platformdirs-3.11.0, virtualenv-20.24.6</p>"},{"location":"available_software/detail/virtualenv/#virtualenv20231-gcccore-1230","title":"virtualenv/20.23.1-GCCcore-12.3.0","text":"<p>This is a list of extensions included in the module:</p> <p>distlib-0.3.6, filelock-3.12.2, platformdirs-3.8.0, virtualenv-20.23.1</p>"},{"location":"available_software/detail/waLBerla/","title":"waLBerla","text":"<p>Widely applicable Lattics-Boltzmann from Erlangen is a block-structured high-performance framework for multiphysics simulations</p> <p>https://walberla.net/index.html</p>"},{"location":"available_software/detail/waLBerla/#available-modules","title":"Available modules","text":"<p>The overview below shows which waLBerla installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using waLBerla, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load waLBerla/6.1-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 waLBerla/6.1-foss-2023a x x x x x x x x x x x waLBerla/6.1-foss-2022b x x x x x x x x x x x"},{"location":"available_software/detail/wget/","title":"wget","text":"<p>GNU Wget is a free software package for retrieving files using HTTP, HTTPS and FTP, the most widely-used Internet protocols. It is a non-interactive commandline tool, so it may easily be called from scripts, cron jobs, terminals without X-Windows support, etc.</p> <p>https://www.gnu.org/software/wget</p>"},{"location":"available_software/detail/wget/#available-modules","title":"Available modules","text":"<p>The overview below shows which wget installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using wget, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load wget/1.24.5-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 wget/1.24.5-GCCcore-12.3.0 x x x x x x x x x x x wget/1.21.4-GCCcore-13.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/wradlib/","title":"wradlib","text":"<p>The wradlib project has been initiated in order to facilitate the use of weatherradar data as well as to provide a common platform for research on newalgorithms.</p> <p>https://docs.wradlib.org/</p>"},{"location":"available_software/detail/wradlib/#available-modules","title":"Available modules","text":"<p>The overview below shows which wradlib installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using wradlib, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load wradlib/2.0.3-foss-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 wradlib/2.0.3-foss-2023a x x x x x x x x x x x"},{"location":"available_software/detail/wradlib/#wradlib203-foss-2023a","title":"wradlib/2.0.3-foss-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>cmweather-0.3.2, deprecation-2.1.0, lat_lon_parser-1.3.0, wradlib-2.0.3, xarray-datatree-0.0.13, xmltodict-0.13.0, xradar-0.5.1</p>"},{"location":"available_software/detail/wrapt/","title":"wrapt","text":"<p>The aim of the wrapt module is to provide a transparent objectproxy for Python, which can be used as the basis for the construction offunction wrappers and decorator functions.</p> <p>https://pypi.org/project/wrapt/</p>"},{"location":"available_software/detail/wrapt/#available-modules","title":"Available modules","text":"<p>The overview below shows which wrapt installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using wrapt, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load wrapt/1.15.0-gfbf-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 wrapt/1.15.0-gfbf-2023a x x x x x x x x x x x"},{"location":"available_software/detail/wrapt/#wrapt1150-gfbf-2023a","title":"wrapt/1.15.0-gfbf-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>wrapt-1.15.0</p>"},{"location":"available_software/detail/wxWidgets/","title":"wxWidgets","text":"<p>wxWidgets is a C++ library that lets developers createapplications for Windows, Mac OS X, Linux and other platforms with asingle code base. It has popular language bindings for Python, Perl,Ruby and many other languages, and unlike other cross-platform toolkits,wxWidgets gives applications a truly native look and feel because ituses the platform's native API rather than emulating the GUI.</p> <p>https://www.wxwidgets.org</p>"},{"location":"available_software/detail/wxWidgets/#available-modules","title":"Available modules","text":"<p>The overview below shows which wxWidgets installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using wxWidgets, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load wxWidgets/3.2.6-GCC-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 wxWidgets/3.2.6-GCC-13.2.0 x x x x x x x x x x x wxWidgets/3.2.2.1-GCC-12.3.0 x x x x x x x x x x x wxWidgets/3.2.2.1-GCC-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/x264/","title":"x264","text":"<p>x264 is a free software library and application for encoding video streams into the H.264/MPEG-4 AVC compression format, and is released under the terms of the GNU GPL.</p> <p>https://www.videolan.org/developers/x264.html</p>"},{"location":"available_software/detail/x264/#available-modules","title":"Available modules","text":"<p>The overview below shows which x264 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using x264, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load x264/20231019-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 x264/20231019-GCCcore-13.2.0 x x x x x x x x x x x x264/20230226-GCCcore-12.3.0 x x x x x x x x x x x x264/20230226-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/x265/","title":"x265","text":"<p>x265 is a free software library and application for encoding video streams into the H.265 AVC compression format, and is released under the terms of the GNU GPL.</p> <p>https://x265.org/</p>"},{"location":"available_software/detail/x265/#available-modules","title":"Available modules","text":"<p>The overview below shows which x265 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using x265, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load x265/3.5-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 x265/3.5-GCCcore-13.2.0 x x x x x x x x x x x x265/3.5-GCCcore-12.3.0 x x x x x x x x x x x x265/3.5-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/xarray/","title":"xarray","text":"<p>xarray (formerly xray) is an open source project and Python package that aims to bring the labeled data power of pandas to the physical sciences, by providing N-dimensional variants of the core pandas data structures.</p> <p>https://github.com/pydata/xarray</p>"},{"location":"available_software/detail/xarray/#available-modules","title":"Available modules","text":"<p>The overview below shows which xarray installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using xarray, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load xarray/2023.9.0-gfbf-2023a\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 xarray/2023.9.0-gfbf-2023a x x x x x x x x x x x"},{"location":"available_software/detail/xarray/#xarray202390-gfbf-2023a","title":"xarray/2023.9.0-gfbf-2023a","text":"<p>This is a list of extensions included in the module:</p> <p>xarray-2023.9.0</p>"},{"location":"available_software/detail/xmlf90/","title":"xmlf90","text":"<p>A fast XML parser and generator in Fortran</p> <p>https://gitlab.com/siesta-project/libraries/xmlf90</p>"},{"location":"available_software/detail/xmlf90/#available-modules","title":"Available modules","text":"<p>The overview below shows which xmlf90 installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using xmlf90, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load xmlf90/1.6.3-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 xmlf90/1.6.3-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/xorg-macros/","title":"xorg-macros","text":"<p>X.org macros utilities.</p> <p>https://gitlab.freedesktop.org/xorg/util/macros</p>"},{"location":"available_software/detail/xorg-macros/#available-modules","title":"Available modules","text":"<p>The overview below shows which xorg-macros installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using xorg-macros, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load xorg-macros/1.20.0-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 xorg-macros/1.20.0-GCCcore-13.2.0 x x x x x x x x x x x xorg-macros/1.20.0-GCCcore-12.3.0 x x x x x x x x x x x xorg-macros/1.19.3-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"available_software/detail/xprop/","title":"xprop","text":"<p>The xprop utility is for displaying window and font properties in an X server. One window or font is selected using the command line arguments or possibly in the case of a window, by clicking on the desired window. A list of properties is then given, possibly with formatting information.</p> <p>https://www.x.org/wiki/</p>"},{"location":"available_software/detail/xprop/#available-modules","title":"Available modules","text":"<p>The overview below shows which xprop installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using xprop, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load xprop/1.2.6-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 xprop/1.2.6-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/xxHash/","title":"xxHash","text":"<p>xxHash is an extremely fast non-cryptographic hash algorithm, working at RAM speed limit.</p> <p>https://cyan4973.github.io/xxHash</p>"},{"location":"available_software/detail/xxHash/#available-modules","title":"Available modules","text":"<p>The overview below shows which xxHash installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using xxHash, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load xxHash/0.8.2-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 xxHash/0.8.2-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/xxd/","title":"xxd","text":"<p>xxd is part of the VIM package and this will only install xxd, not vim!xxd converts to/from hexdumps of binary files.</p> <p>https://www.vim.org</p>"},{"location":"available_software/detail/xxd/#available-modules","title":"Available modules","text":"<p>The overview below shows which xxd installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using xxd, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load xxd/9.1.0307-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 xxd/9.1.0307-GCCcore-13.2.0 x x x x x x x x x x x xxd/9.0.2112-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/yell/","title":"yell","text":"<p>Yell - Your Extensible Logging Library is a comprehensive logging replacement for Ruby.</p> <p>https://github.com/rudionrails/yell</p>"},{"location":"available_software/detail/yell/#available-modules","title":"Available modules","text":"<p>The overview below shows which yell installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using yell, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load yell/2.2.2-GCC-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 yell/2.2.2-GCC-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/yelp-tools/","title":"yelp-tools","text":"<p>yelp-tools is a collection of scripts and build utilities to help create,manage, and publish documentation for Yelp and the web. Most of the heavylifting is done by packages like yelp-xsl and itstool. This package justwraps things up in a developer-friendly way.</p> <p>https://gitlab.gnome.org/GNOME/yelp-tools</p>"},{"location":"available_software/detail/yelp-tools/#available-modules","title":"Available modules","text":"<p>The overview below shows which yelp-tools installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using yelp-tools, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load yelp-tools/42.1-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 yelp-tools/42.1-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/yelp-xsl/","title":"yelp-xsl","text":"<p>yelp-xsl is a collection of programs and data files to help you build, maintain, and distribute documentation. It provides XSLT stylesheets that can be built upon for help viewers and publishing systems. These stylesheets output JavaScript and CSS content, and reference images provided by yelp-xsl. This package also redistributes copies of the jQuery and jQuery.Syntax JavaScript libraries.</p> <p>https://gitlab.gnome.org/GNOME/yelp-xslg</p>"},{"location":"available_software/detail/yelp-xsl/#available-modules","title":"Available modules","text":"<p>The overview below shows which yelp-xsl installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using yelp-xsl, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load yelp-xsl/42.1-GCCcore-12.3.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 yelp-xsl/42.1-GCCcore-12.3.0 x x x x x x x x x x x"},{"location":"available_software/detail/zstd/","title":"zstd","text":"<p>Zstandard is a real-time compression algorithm, providing high compression ratios. It offers a very wide range of compression/speed trade-off, while being backed by a very fast decoder. It also offers a special mode for small data, called dictionary compression, and can create dictionaries from any sample set.</p> <p>https://facebook.github.io/zstd</p>"},{"location":"available_software/detail/zstd/#available-modules","title":"Available modules","text":"<p>The overview below shows which zstd installations are available per target architecture in EESSI, ordered based on software version (new to old).</p> <p>To start using zstd, load one of these modules using a <code>module load</code> command like:</p> <pre><code>module load zstd/1.5.5-GCCcore-13.2.0\n</code></pre> <p>(This data was automatically generated on Wed, 14 May 2025 at 12:49:32 UTC) </p> aarch64/generic aarch64/neoverse_n1 aarch64/neoverse_v1 aarch64/nvidia/grace x86_64/generic x86_64/amd/zen2 x86_64/amd/zen3 x86_64/amd/zen4 x86_64/intel/haswell x86_64/intel/sapphirerapids x86_64/intel/skylake_avx512 zstd/1.5.5-GCCcore-13.2.0 x x x x x x x x x x x zstd/1.5.5-GCCcore-12.3.0 x x x x x x x x x x x zstd/1.5.2-GCCcore-12.2.0 x x x x x x x x x x x"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2024/05/17/isc24/","title":"EESSI promo tour @ ISC'24 (May 2024, Hamburg)","text":"<p>This week, we had the privilege of attending the ISC'24 conference in the beautiful city of Hamburg, Germany. This was an excellent opportunity for us to showcase EESSI, and gain valuable insights and feedback from the HPC community.</p>"},{"location":"blog/2024/05/17/isc24/#bof-session-on-eessi","title":"BoF session on EESSI","text":"<p>The EESSI Birds-of-a-Feather (BoF) session on Tuesday morning, part of the official ISC'24 program, was the highlight of our activities in Hamburg.</p> <p>It was well attended, with well over 100 people joining us at 9am.</p> <p>During this session, we introduced the EESSI project with a short presentation, followed by a well-received live hands-on demo of installing and using EESSI by spinning up an \"empty\" Linux virtual machine instance in Amazon EC2 and getting optimized installations of popular scientific applications like GROMACS and TensorFlow running in a matter of minutes.</p> <p>During the second part of the BoF session, we engaged with the audience through an interactive poll and by letting attendees ask questions.</p> <p>The presentation slides, including the results of the interactive poll and questions that were raised by attendees, are available here.</p>"},{"location":"blog/2024/05/17/isc24/#workshops","title":"Workshops","text":"<p>During the last day of ISC'24, EESSI was present in no less than three different workshops.</p>"},{"location":"blog/2024/05/17/isc24/#risc-v-workshop","title":"RISC-V workshop","text":"<p>At the Fourth International workshop on RISC-V for HPC, Juli\u00e1n Morillo (BSC) presented our paper \"Preparing to Hit the Ground Running: Adding RISC-V support to EESSI\" (slides available here).</p> <p>Juli\u00e1n covered the initial work that was done in the scope of the MultiXscale EuroHPC Centre-of-Excellence to add support for RISC-V to EESSI, outlined the challenges we encountered, and shared the lessons we have learned along the way.</p>"},{"location":"blog/2024/05/17/isc24/#ahug-workshop","title":"AHUG workshop","text":"<p>During the Arm HPC User Group (AHUG) workshop, Kenneth Hoste (HPC-UGent) gave a talk entitled \"Extending Arm\u2019s Reach by Going EESSI\" (slides available here).</p> <p>Next to a high-level introduction to EESSI, we briefly covered some of the challenges we encountered when testing the optimized software installations that we had built for the Arm Neoverse V1 microarchitecture, including bugs in OpenMPI and GROMACS.</p> <p>Kenneth gave a live demonstration of how to get access to EESSI and start running the optimized software installations we provide through our CernVM-FS repository on a fresh AWS Graviton 3 instance in a matter of minutes.</p>"},{"location":"blog/2024/05/17/isc24/#pop-workshop","title":"POP workshop","text":"<p>In the afternoon on Thursday, Lara Peeters (HPC-UGent) presented MultiXscale during the Readiness of HPC Extreme-scale Applications workshop, which was organised by the POP EuroHPC Centre-of-Excellence (slides available here).</p> <p>Lara outlined the pilot use cases on which MultiXscale focuses, and explained how EESSI helps to achieve the goals of MultiXscale in terms of Productivity, Performance, and Portability.</p> <p>At the end of the workshop, a group picture was taken with both organisers and speakers, which was a great way to wrap up a busy week in Hamburg!</p>"},{"location":"blog/2024/05/17/isc24/#talks-and-demos-on-eessi-at-exhibit","title":"Talks and demos on EESSI at exhibit","text":"<p>Not only was EESSI part of the official ISC'24 program via a dedicated BoF session and various workshops: we were also prominently present on the exhibit floor.</p>"},{"location":"blog/2024/05/17/isc24/#microsoft-azure-booth","title":"Microsoft Azure booth","text":"<p>Microsoft Azure invited us to give a 1-hour introductory presentation on EESSI on both Monday and Wednesday at their booth during the ISC'24 exhibit, as well as to provide live demonstrations at the demo corner of their booth on Tuesday afternoon on how to get access to EESSI and the user experience it provides.</p> <p>Exhibit attendees were welcome to pass by and ask questions, and did so throughout the full 4 hours we were present there.</p> <p>Both Microsoft Azure and AWS have been graciously providing resources in their cloud infrastructure free-of-cost for developing, testing, and demonstrating EESSI for several years now.</p>"},{"location":"blog/2024/05/17/isc24/#eurohpc-booth","title":"EuroHPC booth","text":"<p>The MultiXscale EuroHPC Centre-of-Excellence we are actively involved in, and through which the development of EESSI is being co-funded since Jan'23, was invited by the EuroHPC JU to present the goals and preliminary achievements at their booth.</p> <p>Elisabeth Ortega (HPCNow!) did the honours to give the last talk at the EuroHPC JU booth of the ISC'24 exhibit.</p>"},{"location":"blog/2024/05/17/isc24/#stickers","title":"Stickers!","text":"<p>Last but not least: we handed out a boatload free stickers with the logo of both MultiXscale and EESSI itself, as well as of various of the open source software projects we leverage, including EasyBuild, Lmod, and CernVM-FS.</p> <p>We have mostly exhausted our sticker collection during ISC'24, but don't worry: we will make sure we have more available at upcoming events...</p>"},{"location":"blog/2024/06/28/espresso-portable-test-run-eurohpc/","title":"Portable test run of ESPResSo on EuroHPC systems via EESSI","text":"<p>Since 14 June 2024, ESPResSo v4.2.2 is available in the EESSI production repository <code>software.eessi.io</code>, optimized for the 8 CPU targets that are fully supported by version 2023.06 of EESSI. This allows running ESPResSo effortlessly on the EuroHPC systems where EESSI is already available, like Vega and Karolina.</p> <p>On 27 June 2024, an additional installation of ESPResSo v4.2.2 that is optimized for Arm A64FX processors was added, which enables also running ESPResSo efficiently on Deucalion, even though EESSI is not available yet system-wide on Deucalion (see below for more details).</p> <p>With the portable test for ESPResSo that is available in the EESSI test suite we can easily evaluate the scalability of ESPResSo across EuroHPC systems, even if those systems have different system architectures.</p>"},{"location":"blog/2024/06/28/espresso-portable-test-run-eurohpc/#simulating-lennard-jones-fluids-using-espresso","title":"Simulating Lennard-Jones fluids using ESPResSo","text":"<p>Lennard-Jones fluids model interacting soft spheres with a potential that is weakly attractive at medium range and strongly repulsive at short range. Originally designed to model noble gases, this simple setup now underpins most particle-based simulations, such as ionic liquids, polymers, proteins and colloids, where strongly repulsive pairwise potentials are desirable to prevent particles from overlapping with one another. In addition, solvated systems with atomistic resolution typically have a large excess of solvent atoms compared to solute atoms, thus Lennard-Jones interactions tend to account for a large portion of the simulation time. Compared to other potentials, the Lennard-Jones interaction is inexpensive to calculate, and its limited range allows us to partition the simulation domain into arbitrarily small regions that can be distributed among many processors.</p>"},{"location":"blog/2024/06/28/espresso-portable-test-run-eurohpc/#portable-test-to-evaluate-performance-of-espresso","title":"Portable test to evaluate performance of ESPResSo","text":"<p>To evaluate the performance of ESPResSo, we have implemented a portable test for ESPResSo in the EESSI test suite; the results shown here were collected using version 0.3.2.</p> <p>After installing and configuring the EESSI test suite on Vega, Karolina, and Deucalion, running the Lennard-Jones (LJ) test case with ESPResSo 4.2.2 available in EESSI can be done with:</p> <pre><code>reframe --name \"ESPRESSO_LJ.*%module_name=ESPResSo/4.2.2\"\n</code></pre> <p>This will automatically run the LJ test case with ESPResSo across all known scales in the EESSI test suite, which range from single core up to 8 full nodes.</p>"},{"location":"blog/2024/06/28/espresso-portable-test-run-eurohpc/#performance-scalability-results-on-vega-karolina-deucalion","title":"Performance + scalability results on Vega, Karolina, Deucalion","text":"<p>The performance results of the tests are collected by ReFrame in a detailed JSON report.</p> <p>The parallel performance of ESPResSo, expressed in particles integrated per second, scales linearly with the number of cores. On Vega using 8 nodes (1024 MPI ranks, one per physical core), ESPResSo 4.2.2 can integrate the equations of motion of roughly 615 million particles every second. On Deucalion using 8 nodes (384 cores), we observe a performance of roughly 62 million particles integrated per second.</p> <p>Plotting the parallel efficiency of ESPResSo 4.2.2 (weak scaling, 2000 particles per MPI rank) on the three EuroHPC systems we used shows that it decreases approximately linearly with the logarithm of the number of cores.</p>"},{"location":"blog/2024/06/28/espresso-portable-test-run-eurohpc/#running-espresso-on-deucalion-via-eessi-cvmfsexec","title":"Running ESPResSo on Deucalion via EESSI + <code>cvmfsexec</code>","text":"<p>While EESSI is already available system-wide on both Vega and Karolina for some time (see here and here for more information, respectively), it was not available yet on Deucalion when these performance experiments were run.</p> <p>Nevertheless, we were able to leverage the optimized installation of ESPResSo for A64FX that is available in EESSI since 27 June 2024, by leveraging the <code>cvmfsexec</code> tool, and by creatively implementing two simple shell wrapper scripts.</p>"},{"location":"blog/2024/06/28/espresso-portable-test-run-eurohpc/#cvmfsexec-wrapper-script","title":"<code>cvmfsexec</code> wrapper script","text":"<p>The first wrapper script <code>cvmfsexec_eessi.sh</code> can be used to run a command in a subshell in which the EESSI CernVM-FS repository (<code>software.eessi.io</code>) is mounted via <code>cvmfsexec</code>. This script can be used by regular users on Deucalion, it does not require any special privileges beyond the Linux kernel features that <code>cvmfsexec</code> leverages, like user namespaces.</p> <p>Contents of <code>~/bin/cvmfsexec_eessi.sh</code>: <pre><code>#!/bin/bash\nif [ -d /cvmfs/software.eessi.io ]; then\n    # run command directly, EESSI CernVM-FS repository is already mounted\n    \"$@\"\nelse\n    # run command via in subshell where EESSI CernVM-FS repository is mounted,\n    # via cvmfsexec which is set up in a unique temporary directory\n    orig_workdir=$(pwd)\n    mkdir -p /tmp/$USER\n    tmpdir=$(mktemp -p /tmp/$USER -d)\n    cd $tmpdir\n    git clone https://github.com/cvmfs/cvmfsexec.git &gt; $tmpdir/git_clone.out 2&gt;&amp;1\n    cd cvmfsexec\n    ./makedist default &gt; $tmpdir/cvmfsexec_makedist.out 2&gt;&amp;1\n    cd $orig_workdir\n    $tmpdir/cvmfsexec/cvmfsexec software.eessi.io -- \"$@\"\n    # cleanup\n    rm -rf $tmpdir\nfi\n</code></pre></p> <p>Do make sure that this script is executable: <pre><code>chmod u+x ~/bin/cvmfsexec_eessi.sh\n</code></pre></p> <p>A simple way to test this script is to use it to inspect the contents of the EESSI repository:</p> <pre><code>~/bin/cvmfsexec_eessi.sh ls /cvmfs/software.eessi.io\n</code></pre> <p>or to start an interactive shell in which the EESSI repository is mounted:</p> <pre><code>~/bin/cvmfsexec_eessi.sh /bin/bash -l\n</code></pre> <p>The job scripts that were submitted by ReFrame on Deucalion leverage <code>cvmfsexec_eessi.sh</code> to set up the environment and get access to the ESPResSo v4.2.2 installation that is available in EESSI (see below).</p>"},{"location":"blog/2024/06/28/espresso-portable-test-run-eurohpc/#orted-wrapper-script","title":"<code>orted</code> wrapper script","text":"<p>In order to get multi-node runs of ESPResSo working without having EESSI available system-wide, we also had to create a small wrapper script for the <code>orted</code> command that is used by Open MPI to start processes on remote nodes. This is necessary because <code>mpirun</code> launches <code>orted</code>, which must be run in an environment in which the EESSI repository is mounted. If not, MPI startup will fail with an error like \"<code>error: execve(): orted: No such file or directory</code>\".</p> <p>This wrapper script must be named <code>orted</code>, and must be located in a path that is listed in <code>$PATH</code>.</p> <p>We placed it in <code>~/bin/orted</code>, and add <code>export PATH=$HOME/bin:$PATH</code> to our <code>~/.bashrc</code> login script.</p> <p>Contents of <code>~/bin/orted</code>:</p> <pre><code>#!/bin/bash\n\n# first remove path to this orted wrapper from $PATH, to avoid infinite loop\norted_wrapper_dir=$(dirname $0)\nexport PATH=$(echo $PATH | tr ':' '\\n' | grep -v $orted_wrapper_dir | tr '\\n' ':')\n\n~/bin/cvmfsexec_eessi.sh orted \"$@\"\n</code></pre> <p>Do make sure that also this <code>orted</code> wrapper script is executable: <pre><code>chmod u+x ~/bin/orted\n</code></pre></p> <p>If not, you will likely run into an error that starts with: <pre><code>An ORTE daemon has unexpectedly failed after launch ...\n</code></pre></p>"},{"location":"blog/2024/06/28/espresso-portable-test-run-eurohpc/#slurm-job-script","title":"Slurm job script","text":"<p>We can use the <code>cvmfsexec_eessi.sh</code> script in a Slurm job script on Deucalion to initialize the EESSI environment in a subshell in which the EESSI CernVM-FS repository is mounted, and subsequently load the module for ESPResSo v4.2.2 and launch the Lennard-Jones fluid simulation via <code>mpirun</code>:</p> <p>Job script (example using 2 full 48-core nodes on A64FX partition of Deucalion): <pre><code>#!/bin/bash\n#SBATCH --ntasks=96\n#SBATCH --ntasks-per-node=48\n#SBATCH --cpus-per-task=1\n#SBATCH --time=5:0:0\n#SBATCH --partition normal-arm\n#SBATCH --export=None\n#SBATCH --mem=30000M\n~/bin/cvmfsexec_eessi.sh &lt;&lt; EOF\nexport EESSI_SOFTWARE_SUBDIR_OVERRIDE=aarch64/a64fx\nsource /cvmfs/software.eessi.io/versions/2023.06/init/bash\nmodule load ESPResSo/4.2.2-foss-2023a\nexport SLURM_EXPORT_ENV=HOME,PATH,LD_LIBRARY_PATH,PYTHONPATH\nmpirun -np 96 python3 lj.py\nEOF\n</code></pre></p> <p>(the <code>lj.py</code> Python script is available in the EESSI test suite, see here)</p>"},{"location":"blog/2024/07/26/extrae-now-available-in-EESSI/","title":"Extrae available in EESSI","text":"<p>Thanks to the work developed under MultiXscale CoE we are proud to announce that as of 22 July 2024, Extrae v4.2.0 is available in the EESSI production repository <code>software.eessi.io</code>,  optimized for the 8 CPU targets that are fully supported by version 2023.06 of EESSI. This allows using Extrae effortlessly on the EuroHPC systems where EESSI is already available, like Vega and Karolina.</p> <p>It is worth noting that from that date Extrae is also available in the EESSI RISC-V repository <code>risv.eessi.io</code>.</p> <p>Extrae is a package developed at BSC devoted to generate Paraver trace-files for a post-mortem analysis of applications performance. Extrae is a tool that uses different interposition mechanisms to inject probes into the target application so as to gather information regarding the application performance. It is one of the tools used in the POP3 CoE.</p> <p>The work to incorporate Extrae into EESSI started early in May. It took quite some time and effort but has resulted in a number of updates, improvements and bug fixes for Extrae. The following sections explain the work done describing the issues encountered and the solutions adopted.</p>"},{"location":"blog/2024/07/26/extrae-now-available-in-EESSI/#adapting-eessi-software-layer","title":"Adapting EESSI software layer","text":"<p>During the first attempt to build Extrae (in this case <code>v4.0.6</code>) in the EESSI context, we found out two issues:</p> <ol> <li>the <code>configure</code> script of Extrae was not able to find <code>binutils</code> in the location it is provided by the compat layer of EESSI, and</li> <li>the <code>configure</code>/<code>make</code> files of Extrae make use of <code>which</code> command that does not work in our build container. </li> </ol> <p>Both problems were solved by adding a <code>pre_configure_hook</code> in the <code>eb_hooks.py</code> file of the EESSI software layer that:</p> <ul> <li>avoids the use of <code>which</code> during configuration and building processes by replacing it with <code>command -v</code> in the necessary files, and</li> <li>specifies the correct path to <code>binutils</code> in EESSI compat layer by passing <code>--with-binutils</code> option to the Extrae <code>configure</code> script.</li> </ul>"},{"location":"blog/2024/07/26/extrae-now-available-in-EESSI/#moving-to-version-416","title":"Moving to version 4.1.6","text":"<p>By the time we completed this work, <code>v4.1.6</code> of Extrae was available so we decided to switch to that version as v4.0.6 was throwing errors in the test suite provided by Extrae through the <code>make check</code>command. </p> <p>When first trying to build this new version, we noticed that there were still problems with <code>binutils</code> detection because the configure scripts of Extrae assume that the <code>binutils</code> libraries are under a <code>lib</code> directory in the provided <code>binutils</code> path while in the EESSI compat layer they are directly in the provided directory (i.e. without the <code>/lib</code>). This was solved with a patch file committed to the EasyBuild easyconfigs repository, that modifies both <code>configure</code> and <code>config/macros.m4</code> to make <code>binutils</code> detection more robust. This patch was also provided to Extrae developers to incorporate into future releases.</p> <p>The next step was to submit a Pull Request to the EasyBuild easyblocks repository with some modifications to the <code>extrae.py</code> easyblock that:</p> <ul> <li>Removed configure options <code>--enable-xml</code> and <code>--with-dwarf</code> that were no longer available in Extrae starting from v4.1.0.</li> <li>Added <code>--with-xml</code> option to specify <code>libxml2</code> root dir.</li> <li>Added <code>--enable-posix-clock</code> configure option for RISCV64 (needed to build Extrae as no lower level clock seems to be available yet in RISC-V architectures).</li> </ul> <p>With all of this in place, we managed to correctly build Extrae but found out that many tests failed to pass, including all 21 under the MPI directory. We reported this fact to Extrae developers who answered that there was a critical bug fix related to MPI tracing in version 4.1.7 so we switched to that version before continuing our work.</p>"},{"location":"blog/2024/07/26/extrae-now-available-in-EESSI/#work-with-version-417","title":"Work with version 4.1.7","text":"<p>We tested the build of that version (of course including all the work done before for previous versions) and we still saw some errors in the <code>make check</code>phase. We focused first in the following 3:</p> <ul> <li><code>FAIL: mpi_commranksize_f_1proc.sh</code></li> <li><code>FAIL: pthread.sh</code></li> <li><code>FAIL: check_Extrae_xml_envvar_counters.sh</code></li> </ul> <p>Regarding the first one, we found a bug in the Extrae test itself: the <code>mpi_comm_ranksize_f_1proc.sh</code> was invoking <code>trace-ldpreload.sh</code> instead of the Fortran version <code>trace-ldpreloadf.sh</code> and this caused the test to fail. We submitted a Pull Request to the Extrae repository with the bugfix that has been already merged and incorporated into new releases.</p> <p>Regarding the second one, it was reported to Extrae developers as an issue. They suggested commenting out a call at <code>src/tracer/wrappers/pthread/pthread_wrapper.c</code> at line 240: <code>//Backend_Flush_pThread (pthread_self());</code>. We reported that this fixed the issue so this change has also been incorporated into the Extrae main branch for future releases.</p> <p>The last failing test was an issue related with the access to HW counters on the building/testing system. The problem was that the test assumed that Extrae (through PAPI) can access HW counters (in this case, <code>PAPI_TOT_INS</code>). This might not be the case because this is very system-dependent (since it involves permissions, etc). As a solution, we committed a patch to the Extrae repository which ensured that the test will not fail if <code>PAPI_TOT_CYC</code> is unavailable in the testing system. As this has not been incorporated yet into the Extrae repository, we also committed a patch file to the EasyBuild easyconfigs repository that solves the problem with this specific test but also with others that suffered from this same issue.</p>"},{"location":"blog/2024/07/26/extrae-now-available-in-EESSI/#finally-version-420","title":"Finally, version 4.2.0","text":"<p>Due to the bugfixes mentioned in previous section that were incorporated into the Extrae repository, we switched again to an updated version of Extrae (in this case v4.2.0). With that updated version and the easyconfig (and patches) and easyblock modifications tests started to pass successfully in most of the testing platforms. </p> <p>We noticed, however, that Extrae produced segmentation faults when using libunwind in ARM architectures. Our approach to that was to report the issue to Extrae developers and to make this dependency architecture specific (i.e. forcing <code>--without-unwind</code> when building for ARM while keeping the dependency for the rest of architectures). We did this in a Pull Request to the EasyBuild easyconfigs repository that is already merged. In this same Pull Request we added <code>zlib</code> as an explicit dependency in the easyconfig file for all architectures.</p> <p>The last issue we encountered was similar to the previous one but in this case was seen on some RISC-V platforms and related to dynamic memory instrumentation. We adopted the same approach and reported the issue to Extrae developers and added <code>--disable-instrument-dynamic-memory</code> to the configure options in a Pull Request already merged into the EasyBuild-Easyconfigs repository.</p> <p>With that, all tests passed in all platforms and we were able to incorporate Extrae to the list of software available in both the <code>software.eessi.io</code> and <code>riscv.eessi.io</code> repositories of EESSI.</p>"},{"location":"blog/2024/09/20/hpcwire-readers-choice-awards-2024/","title":"EESSI nominated for HPCwire Readers\u2019 Choice Awards 2024","text":"<p>EESSI has been nominated for the HPCwire Readers\u2019 Choice Awards 2024, in the \"Best HPC Programming Tool or Technology\" category.</p> <p>You can help us win the award by joining the vote.</p> <p>To vote, you should:</p> <ol> <li>Fill out and submit the form    to register yourself as an HPCWire reader and access your ballot;</li> <li>Access your ballot here;</li> <li>Select your favorite in one or more categories;</li> <li>Submit your vote by filling in your name, organisation, and email address (to avoid ballot stuffing),    and hitting the <code>Done</code> button.</li> </ol> <p>Note that you are not required to vote for all categories, you can opt for only voting for one particular nominee in only one of the categories.</p> <p>For example, you could vote for European Environment for Scientific Software Installations (EESSI) in category 13: Best HPC Programming Tool or Technology.</p>"},{"location":"blog/2024/10/11/ci-workflow-for-EESSI/","title":"An example CI workflow that leverages EESSI CI tools","text":"<p>EESSI's CI workflows are available on GitHub Actions and as a GitLab CI/CD component. Enabling this is as simple as adding EESSI's CI to your workflow of choice, giving you access to the entire EESSI software stack optimized for the relevant CPU architecture(s) in your runner's environment. If you are developing an application on top of the EESSI software stack, for example, this means you don't need to invest heavily in configuring and maintaining a CI setup: EESSI does that for you so you can focus on your code. With the EESSI CI workflows you don't have to worry about figuring out how to optimize build and runtime dependencies as these will be streamed seamlessly to your runner's environment.</p>"},{"location":"blog/2024/10/11/ci-workflow-for-EESSI/#using-the-ci-component-in-gitlab","title":"Using the CI component in GitLab","text":"<p>To showcase this, let's create a simple <code>R</code> package that just outputs a map of the European Union and Norway, and colours the participating countries in the MultiXscale CoE.</p> <p>We'll make a package <code>eessirmaps</code> that relies on popular R packages <code>ggplot2</code>, <code>sf</code>, and <code>rnaturalearth</code> to render and save this map. Installing GIS tools for R can be somewhat cumbersome, which could become trickier if it has to be done in a CI environment. This is because <code>sf</code> requires system packages <code>libgdal-dev</code> and <code>libproj-dev</code>, which would add yet another step, complicating our CI workflow. Thankfully, EESSI makes a lot of the packages dependencies available to us from the start, as well as a fully functioning version of R, and the necessary package dependencies to boot! As far as setup goes, this results in a simple CI workflow:</p> <pre><code>include:\n  - component: $CI_SERVER_FQDN/eessi/gitlab-eessi/eessi@1.0.5\n\nbuild:\n  stage: build\n  artifacts:\n    paths:\n      - msx_map.png\n  script:\n    # Create directory for personal R library\n    - mkdir $CI_BUILDS_DIR/R\n    - export R_LIBS_USER=$CI_BUILDS_DIR/R\n    # Load the R module from EESSI\n    - module load R-bundle-CRAN/2023.12-foss-2023a\n    # Install eessirmaps, the rnaturalearth dep and create the plot\n    - R -e \"install.packages('rnaturalearthdata', repos = 'https://cran.rstudio.com/');\n      remotes::install_gitlab('neves-p/eessirmaps', upgrade = FALSE);\n      eessirmaps::multixscale_map(); ggplot2::ggsave('msx_map.png', bg = 'white')\"\n</code></pre> <p>Note how we simply include the EESSI GitLab CI component and set up a blank directory for our user R libraries. Remember, because of EESSI, the environment that you develop in will be exactly the same as the one the CI is run in. Apart from the <code>rnaturalearthdata</code> R package, all the other dependencies are taken care of by the <code>R-bundle-CRAN/2023.12-foss-2023a</code> EESSI module. This is true for the system and R package dependencies.</p> <p>Then we simply have to install our package to the CI environment and call the <code>multixscale_map()</code> function to produce the plot, which is uploaded as an artifact from the CI environment. We can then retrieve the artifact archive, unpack it and obtain the map.</p>"},{"location":"blog/2024/10/25/eurohpc_user_day_2024/","title":"EuroHPC User Day (22-23 Oct 2024, Amsterdam)","text":"<p>We had a great time at the EuroHPC User Day 2024 in Amsterdam earlier this week.</p> <p>Both MultiXscale and EESSI were strongly represented, and the work we have been doing was clearly being appreciated.</p>"},{"location":"blog/2024/10/25/eurohpc_user_day_2024/#visit-to-surf-snellius-at-amsterdam-science-park","title":"Visit to SURF &amp; Snellius at Amsterdam Science Park","text":"<p>Most of us arrived in the afternoon the day before the event, which gave us the chance to visit SURF on-site.</p> <p>We had a short meeting there with the local team about how we could leverage Snellius, the Dutch national supercomputer, for building and testing software installations for EESSI.</p> <p>We also got to visit the commercial datacenter at the Amsterdam Science Park (which will soon also host a European quantum computer!) and see Snellius up close, where we took a nice selfie.</p>"},{"location":"blog/2024/10/25/eurohpc_user_day_2024/#presentation-on-multixscale-and-eessi","title":"Presentation on MultiXscale and EESSI","text":"<p>After the very interesting first EuroHPC User Day in Brussels in December 2023, where MultiXscale and EESSI were mentioned as \"being well-aligned with the vision of EuroHPC JU\", we wanted to have a stronger presence at the second EuroHPC User Day in Amsterdam.</p> <p>We submitted a paper entitled \"Portable test run of ESPResSo on EuroHPC systems via EESSI\" which was based on an earlier blog post we did in June 2024. Our submission was accepted, and hence the paper will be included in the upcoming proceedings of the 2nd EuroHPC User Day.</p> <p>As a result, we were invited to present MultiXscale and more specifically the EESSI side of the project during one of the parallel sessions: HPC ecosystem tools. The slides of this presentation are available here.</p> <p>During the Q&amp;A after our talk various attendees asked interesting questions about specific aspects of EESSI, including:</p> <ul> <li>Where are both the central and mirror servers of EESSI hosted? (answer: currently at the University of Groningen, and in AWS &amp; Azure, respectively, but they can be easily relocated if there is a reason to);</li> <li>Are customized builds of software possible on top of EESSI? (answer: yes, see also here);</li> <li>What are the challenges with supporting NVIDIA GPUs? (answer: see here).</li> </ul> <p>Some attendees also provided some nice feedback on their initial experience with EESSI:</p> <p>Quote by one of the attendees of the MultiXscale talk</p> <p>It's very easy to install and configure CernVM-FS to provide access to EESSI based on the available documentation.</p> <p>Any sysadmin can do it: it took me half a day, and that was mostly due to my own stupidity.</p>"},{"location":"blog/2024/10/25/eurohpc_user_day_2024/#mentioning-of-multixscale-and-eessi-by-other-speakers","title":"Mentioning of MultiXscale and EESSI by other speakers","text":"<p>It was remarkable and satisfying to see that MultiXscale and EESSI were being mentioned several times through the event, often by people and organisations who are not actively involved with either project. Clearly the word is starting to spread on the work we are doing!</p> <p>Valeriu Codreanu (head of High-Performance Computing and Visualization at SURF) had some nice comments to share during his opening statement of the event about their involvement in MultiXscale and EESSI, and why a well-designed shared stack of optimized software installations is really necessary.</p> <p>When an attendee of one of the plenary sessions raised a question on a lack of a uniform software stack across EuroHPC systems, Lilit Axner (Programme Manager Infrastructure at EuroHPC JU) answered that a federated platform for EuroHPC systems is currently in the works, and that more news will be shared soon on this.</p> <p>In the short presentation on the EuroHPC JU system Vega we got explicitly mentioned again, alongside CernVM-FS and EasyBuild which are both used in the EESSI project.</p>"},{"location":"blog/2024/10/25/eurohpc_user_day_2024/#live-demo-of-eessi-at-walk-in-networking-session","title":"Live demo of EESSI at walk-in networking session","text":"<p>On Wednesday, the MultiXscale project was part of the walk-in networking session Application Support, Training and Skills.</p> <p>During this session we were running a live demonstration of a small Plane Poiseuille flow simulation with ESPResSo.</p> <p>The software was being provided via EESSI, and we were running the simulation on various hardware platforms, including:</p> <ul> <li>An on-site cluster consisting of 4 Arm-based Raspberry Pi 3B+ boards;</li> <li>A RISC-V StarFive VisionFive 2 SBC;</li> <li>An Arm A64FX node of the EuroHPC system Deucalion;</li> <li>An A100 GPU in the EuroHPC system Vega;</li> </ul> <p>Attendees could participate in a contest to win a Raspberry Pi 5 starter kit by filling out a form and answering a couple of questions related to MultiXscale.</p> <p>At the end of the session we did a random draw among the participants who answered the questions correctly, and Giorgos Kosta (CaSToRC - The Cyprus Institute) came out as the lucky winner!</p>"},{"location":"blog/2024/10/25/eurohpc_user_day_2024/#eurohpc-user-forum","title":"EuroHPC User Forum","text":"<p>Last but not least, the EuroHPC User Forum was being presented during a plenary session.</p> <p>Attendees were invited to connect with the EuroHPC User Forum representatives and each other via the dedicated Slack that has been created for it.</p> <p> </p> <p>Lara Peeters, who is also active in MultiXscale EuroHPC Centre-of-Excellence, is part of the EuroHPC User Forum, representing Digital Humanities.</p>"},{"location":"blog/2024/10/25/eurohpc_user_day_2024/#eurohpc-user-day-2025-in-denmark","title":"EuroHPC User Day 2025 in Denmark","text":"<p>We are already looking forward to engaging with the EuroHPC user community next year in Denmark!</p>"},{"location":"blog/2024/11/18/hpcwire-readers-choice-awards-2024-for-eessi/","title":"EESSI won an HPCWire Reader's Choice Award!","text":"<p>We are thrilled to announce that EESSI has won an HPCWire Reader's Choice Award!</p> <p>EESSI received the most votes from the HPC community in the \"Best HPC Programming Tool or Technology\" category, despite the fierce competition of others projects that got nominated in this category.</p> <p>This news was revealed at the Supercomputing 2024 (SC'24) conference in Atlanta (US).</p> <p>Thank you very much if you voted for us!</p>"},{"location":"blog/2024/11/18/hpcwire-readers-choice-awards-2024-for-eessi/#award-ceremony","title":"Award ceremony","text":"<p>A modest award ceremony was held at the Do IT Now booth on the SC'24 exhibit floor, since HPCNow! (part of the Do IT Now Group) is a partner in the MultiXscale EuroHPC Centre-of-Excellence.</p> <p>The handover of the award plaque was done by Tom Tabor, CEO of Tabor Communications, Inc., the publisher of HPCWire.</p>"},{"location":"blog/2024/11/18/hpcwire-readers-choice-awards-2024-for-eessi/#picture-at-eurohpc-ju-booth","title":"Picture at EuroHPC JU booth","text":"<p>It is important to highlight that the funding provided by the EuroHPC JU to the MultiXscale Centre-of-Excellence has been a huge catalyst in the last couple of years for EESSI, which forms the technical pillar of MultiXscale.</p> <p>Anders Dam Jensen, CEO of EuroHPC JU, and Daniel Opalka, head of Research &amp; Innovation at EuroHPC JU, were more than happy to take a commemorative picture at the EuroHPC JU booth, together with representatives of some of the MultiXscale partners (Ghent University, HPCNow!, and SURF).</p>"},{"location":"blog/2024/11/18/hpcwire-readers-choice-awards-2024-for-eessi/#more-info","title":"More info","text":"<p>For more information about EESSI, check out our website: https://eessi.io.</p>"},{"location":"blog/2025/02/10/integration-efp/","title":"Integration in the EuroHPC Federation Platform","text":"<p>A couple of weeks ago the EuroHPC Joint Undertaking (EuroHPC JU) announced the consortium that will develop the EuroHPC Federation Platform (EFP).</p> <p>This ambitious effort will deliver a 'one-stop shop' for researchers using the EuroHPC supercomputers, as well as the upcoming EuroHPC AI Factories and quantum computers, built with open source software.</p> <p>Ghent University is part of this consortium to integrate EESSI into the EuroHPC Federation Platform as common software stack.</p> <p>Henrik Nortamo (CSC), the technical lead of the EFP consortium, gave an excellent 20-minute talk on EFP last weekend in the 10th HPC, Big Data, and Data Science devroom at FOSDEM'25 in Brussels. Slides and recording of the talk are available here.</p>"},{"location":"blog/2025/02/10/integration-efp/#the-efp-consortium","title":"The EFP consortium","text":"<p>The consortium that will develop the EuroHPC Federation Platform consists of:</p> <ul> <li>CSC in Finland, the Hosting Entity for LUMI, as lead partner;</li> <li>IT4Innovations in Czech Republic, the Hosting Entitory for Karolina;</li> <li>Ghent University in Belgium;</li> <li>University of Tartu in Estonia;</li> <li>G\u00c9ANT, the pan-European data network for the research and education community;</li> <li>NORDUnet, a Nordic collaboration connecting national research and education network;</li> </ul> <p>A productive kickoff meeting was held on 16+17 January 2025 in Helsinki, Finland.</p> <p>Each of the components of the federated platform were presented by and to the consortium partners, and practical aspects of executing the planned work in the coming months and years were discussed.</p>"},{"location":"blog/2025/02/10/integration-efp/#scope-and-timeline-of-efp","title":"Scope and timeline of EFP","text":"<p>The federated platform aims to facilitate access to and usage of the EuroHPC infrastructure.</p> <p>It will provide:</p> <ul> <li>Federated Single-Sign-On, based on MyAccessID;</li> <li>Direct access using (short-lived) SSH certificates;</li> <li>Web interface for interactive use, based on Open OnDemand;</li> <li>Common software stack, based on EESSI;</li> <li>Resource allocation and management across systems, based on Waldur;</li> <li>Advanced workflows and data transfer, based on LEXIS and HEAppE;</li> </ul> <p>The development of the federated platform started just a couple of weeks ago (January 2025). An initial production version of the platform with currently online EuroHPC JU systems integrated is planned to be operational by March 2026.</p> <p>The work is funded by the EuroHPC Joint Undertaking, who is providing a total budget of ~20 million Euro to the EFP consortium for 2025-2029.</p>"},{"location":"blog/2025/02/10/integration-efp/#powered-by-open-source-software","title":"Powered by open source software","text":"<p>Quote by Henrik Nortamo (CSC.fi), technical lead of EFP @ HPC devroom at FOSDEM'25</p> <p>This would not be possible without open source.</p> <p>If you consider the scope of the functionality, and the implicit understanding the implemented technologies have of user requirements, starting from scratch and compiling that into something sensible would be an extremely large job.</p> <p>Federation requires of course a degree of trust that our stuff works. With open source, somebody else is running it, you can have a look at it, you can go and check it out. It's much easier than going \"here's my binary blob, please install it so that stuff works\".</p> <p>Also on the promised features: I've shown you a bunch of stuff, I'm promising you many things which can be done. If this was a closed-source solution, which wasn't used anywhere and you couldn't look into it, you would probably think that \"he's trying to bullshit us, there's no way\". But now you know: yes, that is an open source component, it works there, I understand why it works, this could also work.</p> <p>(see also slides + recording of Henrik's talk on EuroHPC Federation Platform)</p>"},{"location":"blog/2025/02/10/integration-efp/#eessi-as-common-software-stack","title":"EESSI as common software stack","text":"<p>EESSI will be integrated in the EuroHPC Federation Platform as a part of the Federated Software Catalogue component, a common software stack that will be available on the EuroHPC systems.</p> <p>Researchers will be able to consult which software is available on the various EuroHPC systems through the Federated Software Listing component of the federated platform.</p>"},{"location":"blog/2025/02/10/integration-efp/#current-status-of-eessi-on-eurohpc-ju-systems","title":"Current status of EESSI on EuroHPC JU systems","text":"<p>This work will foster a quick(er) and broad adoption of EESSI on EuroHPC infrastructure.</p> <p>We expect that there will also be a \"trickle-down\" effect to national and local supercomputers throughout Europe (and beyond) to also make EESSI available there in the short term.</p> <p>Today, EESSI is already available on various EuroHPC JU supercomputers, including Vega in Slovenia, Karolina in Czech Republic, and (the A64FX partition of) Deucalion in Portugal.</p> <p>Discussions with various other EuroHPC JU systems to also make EESSI available there are ongoing, including MeluXina in Luxembourg, MareNostrum 5 in Spain, LUMI in Finland, and JUPITER in Germany.</p> <p>An up-to-date overview of systems where EESSI is known to be available is available in the EESSI documentation: https://eessi.io/docs/systems.</p>"},{"location":"blog/2025/03/24/gpu-support-in-eessi/","title":"GPU Support in EESSI: From Zero to Science in Seconds","text":"<p>\"How long until I can run my simulation?\" </p> <p>It's the question every computational scientist asks when setting up a new environment. With GPU-accelerated EESSI, the answer might surprise you: as little as 15 seconds from login to launching your first computation.</p> <p>In the high-stakes world of scientific computing, every minute spent configuring software is a minute not spent on discovery. That's why we've developed a metric we call Mean-Time-To-Science \u2013 the total time from system access to running your first scientific computation. By optimizing this crucial metric, EESSI's GPU support transforms the traditional hours-long setup process into a seamless experience that keeps researchers focused on their science.</p> <p>Although EESSI aims to provide pre-built software for all common HPC architectures, GPU support introduces multiplicative requirements for software builds. Each GPU compute capability (e.g., CC7.5, CC8.0, CC8.6) needs to be combined with each CPU architecture (zen2, zen3, generic x86_64), creating a large matrix of possible configurations. While it's possible to pre-build all software for all CPU/GPU combinations, testing all the configurations is not - the combination of CPU/GPU might not even exist in the real-world.</p> <p>To address this challenge, we're developing additional documentation highlighting which CPU/GPU combinations are already built into EESSI. Additionally, we provide the tools and process for users to build any EasyBuild-enabled software on EESSI, allowing them to create architecture-specific builds for their particular needs when a specific combination isn't available in the standard distribution.</p>"},{"location":"blog/2025/03/24/gpu-support-in-eessi/#scenarios","title":"Running GPU software - scenarios","text":"<p>There are 3 possible scenarios when you want to run GPU-enabled software via EESSI, as pictured in the image above. Each scenario requires different amounts of time to execute.  This leads us to establish a new metric: Mean-Time-To-Science - the time it takes from setting up your environment to running your first scientific computation.</p> <p>Those following scenarios are simplified version and should serve as high overview and general example to follow. Exact install script used in our tests is stated at the end of this blogpost.</p>"},{"location":"blog/2025/03/24/gpu-support-in-eessi/#scenario_1","title":"Scenario No.1","text":"<p>Both CUDA and the required MODULE are already built for your CPU and GPU architecture. In our example, we'll use GROMACS as the module.</p> <p>You can load all the dependencies just by loading the GROMACS module. We just need to ensure we load the correct module built with CUDA support. We'll use <code>GROMACS/2023.3-foss-2023a-CUDA-12.1.1-PLUMED-2.9.0</code> as our example:</p> <p><pre><code># Scenario 1\n# Install EESSI\n# https://github.com/EESSI/eessi-demo/blob/main/scripts/install_cvmfs_eessi.sh\n./install_cvmfs_eessi.sh\n\n# Load EESSI\nsource /cvmfs/software.eessi.io/versions/2023.06/init/lmod/bash\n\n# Link the NVIDIA host libraries to host_injections\n./scripts/gpu_support/nvidia/link_nvidia_host_libraries.sh\n\n# Load GROMACS module\nmodule load GROMACS/2023.3-foss-2023a-CUDA-12.1.1-PLUMED-2.9.0\n\n# Run GROMACS\ngmx mdrun -s ion_channel.tpr -maxh 0.50 -resethway -noconfout -nsteps 10000 -g logfile\n</code></pre> Mean-Time-To-Science ~= 20s</p>"},{"location":"blog/2025/03/24/gpu-support-in-eessi/#scenario_2","title":"Scenario No.2","text":"<p>CUDA module is provided by EESSI,  but you need to build and run software which is not in EESSI CVMFS.</p> <p>In this case, you'll need to install CUDA libraries locally (NVIDIA's licensing requirements) into the <code>host_injections</code> directory where the current CUDA module lib stubs point to.</p> <p>Check the provided script in the docs: full CUDA installation</p> <p>We'll use <code>GROMACS/2023.3-foss-2023a-CUDA-12.1.1-PLUMED-2.9.0</code> again as our example.</p> <p>install_cuda_* WORK IN PROGRESS !</p> <p>At the time of writing, there are currently 2 scripts used to install CUDA libraries to <code>host_injections</code>:</p> <ul> <li> <p>Older: <code>install_cuda_host_injections.sh</code> which installs only one selected CUDA version (CUDA-12.1.1 in our examples)</p> </li> <li> <p>Newer: <code>install_cuda_and_libraries.sh</code> which uses Easystacks and will be the preferred method for installing CUDA to <code>host_injections</code></p> </li> </ul> <p>This blogpost example:</p> <p>Since it is currently faster to run: <code>install_cuda_host_injections.sh</code>, we are currently using it in our examples.</p> <pre><code># Scenario 2\n# Install EESSI\n# https://github.com/EESSI/eessi-demo/blob/main/scripts/install_cvmfs_eessi.sh\n./install_cvmfs_eessi.sh\n\n# Load EESSI and EESSI-extend\nsource /cvmfs/software.eessi.io/versions/2023.06/init/lmod/bash\nmodule load EESSI-extend\n\n# Link the NVIDIA host libraries to host_injections\n./scripts/gpu_support/nvidia/link_nvidia_host_libraries.sh\n\n# Install CUDA to host_injections\n/cvmfs/software.eessi.io/versions/${EESSI_VERSION}/scripts/gpu_support/nvidia/install_cuda_host_injections.sh --cuda-version 12.1.1 --temp-dir /tmp/$USER/EESSI --accept-cuda-eula\n\n# Build GROMACS module from EasyBuild\ncc=$(nvidia-smi --query-gpu=compute_cap --format=csv,noheader | head -1)\neb --force --robot GROMACS-2023.3-foss-2023a-CUDA-12.1.1-PLUMED-2.9.0.eb --cuda-compute-capabilities=\"$cc\"\n\n# Load GROMACS module\nmodule load GROMACS/2023.3-foss-2023a-CUDA-12.1.1-PLUMED-2.9.0\n\n# Run GROMACS\ngmx mdrun -s ion_channel.tpr -maxh 0.50 -resethway -noconfout -nsteps 10000 -g logfile\n</code></pre> <p>Mean-Time-To-Science ~= 10 minutes (CUDA Download + Installation)</p> <p>Mean-Time-To-Science (GROMACS) ~= 25 minutes (GROMACS Build without Tests)</p>"},{"location":"blog/2025/03/24/gpu-support-in-eessi/#scenario_3","title":"Scenario No.3","text":"<p>CUDA module is missing - This is an unlikely scenario, but we're including it for completeness.</p> <p>In this scenario, we need to install CUDA libraries and build the module ourselves.  Then we need to build our scientific module.</p> <p>This scenario is mostly similar to the second one, but we need to build the CUDA lmod module as an additional step. This is also the most universal way to run EESSI modules. You can run anything which can be built by EasyBuild!</p> <p>In this case, you'll need to install CUDA libraries and the lmod module locally (with a tweaked script).</p> <p>We'll use <code>GROMACS/2023.3-foss-2023a-CUDA-12.1.1-PLUMED-2.9.0</code> again as our example.</p> <p>This blogpost example:</p> <p>We're using a slightly modified version of <code>install_cuda_host_injections.sh</code>  in our examples for faster execution.</p> <p>This version doesn't discard the lmod .lua module but includes it to correct PATH which EESSI recognize.  (remove <code>--installpath-modules=${tmpdir}</code> in the script.)</p> <pre><code># Scenario 3\n# Install EESSI\n# https://github.com/EESSI/eessi-demo/blob/main/scripts/install_cvmfs_eessi.sh\n./install_cvmfs_eessi.sh\n\n# Load EESSI and EESSI-extend\nsource /cvmfs/software.eessi.io/versions/2023.06/init/lmod/bash\nmodule load EESSI-extend\n\n# Link the NVIDIA host libraries to host_injections\n./scripts/gpu_support/nvidia/link_nvidia_host_libraries.sh\n\n# Install CUDA to host_injections\n# /cvmfs/software.eessi.io/versions/${EESSI_VERSION}/scripts/gpu_support/nvidia/install_cuda_host_injections.sh\n# We are using modified version of this script, which doesn't use `--installpath-modules=${tmpdir}`\n./scripts/gpu_support/nvidia/install_cuda_host_injections.sh --cuda-version 12.1.1 --temp-dir /tmp/$USER/EESSI --accept-cuda-eula\n\n# Build GROMACS module from EasyBuild\ncc=$(nvidia-smi --query-gpu=compute_cap --format=csv,noheader | head -1)\neb --force --robot GROMACS-2023.3-foss-2023a-CUDA-12.1.1-PLUMED-2.9.0.eb --cuda-compute-capabilities=\"$cc\"\n\n# Load GROMACS module\nmodule load GROMACS/2023.3-foss-2023a-CUDA-12.1.1-PLUMED-2.9.0\n\n# Run GROMACS\ngmx mdrun -s ion_channel.tpr -maxh 0.50 -resethway -noconfout -nsteps 10000 -g logfile\n</code></pre> <p>Mean-Time-To-Science ~= 10 minutes (CUDA Download + Installation)</p> <p>Mean-Time-To-Science (GROMACS) ~= 25 minutes (GROMACS Build without Tests) </p>"},{"location":"blog/2025/03/24/gpu-support-in-eessi/#desktop_","title":"Bringing HPC to the Scientist's Desktop","text":"<p>To demonstrate EESSI's flexibility, we developed and tested the installation process on consumer-grade gaming PCs  equipped with NVIDIA RTX 2060 and NVIDIA RTX 3060 GPUs, running several operating systems. </p>"},{"location":"blog/2025/03/24/gpu-support-in-eessi/#testing-eessi-with-nvidia-rtx-2060-on-linux-mint","title":"Testing EESSI with NVIDIA RTX 2060 on Linux Mint","text":"<p>Our first test system was equipped with an NVIDIA RTX 2060 GPU running Linux Mint (Ubuntu-based). </p> <p>The NVIDIA RTX 2060  features 1,920 CUDA cores, 6GB of GDDR6 memory and CUDA Compute Capability 7.5. Despite being marketed for gaming, this GPU is capable of running many scientific workloads. </p> <p>For optimal performance with the NVIDIA RTX 2060, we installed NVIDIA driver version 550, which provides support for CUDA 12.x. This driver is available through Ubuntu's standard package repositories:</p> <pre><code>sudo apt install nvidia-driver-550\n</code></pre> <p>The installation process followed the native installation method outlined in the EESSI documentation. After installing the NVIDIA drivers, we used the EESSI-provided scripts to link the driver libraries properly.</p> <p>As part of this initiative, we updated the NVIDIA library linking script - link_nvidia_host_libraries.sh  to better handle edge-cases and improve maintainability. The changes are available in this Pull Request.</p> <p>One interesting edge-case we encountered was on Desktop Ubuntu-based systems where NVIDIA also installs i386 libraries for compatibility with certain games and frameworks. These i386 libraries caused errors in the linking script, so we implemented filtering to exclude them as they aren't needed for scientific computing. The updated script now properly identifies and links only the required x86_64 libraries. </p> <p>After that, we should be able to load and run GPU enabled software from EESSI.</p> <p>When we load the EESSI environment and show available modules, we found:</p> <pre><code>$ source /cvmfs/software.eessi.io/versions/2023.06/init/lmod/bash\n\nEESSI/2023.06 loaded successfully\n\n$ ml avail CUDA\n\nNo module(s) or extension(s) found!\n</code></pre> <p>Unfortunately, there are no CUDA modules for our CPU architecture (generic x86_64 CPU - Intel(R) Core(TM) i5-3550 CPU @ 3.30GHz)  at the time of writing this blogpost.</p> <p>For demonstration purposes, we've chosen GROMACS and ESPResSo to showcase GPU-enabled module speedup with properly compiled packages, but they are only available for CPU.</p> <pre><code>$ ml avail GROMACS\n\n--- /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/generic/modules/all ---\n   GROMACS/2024.1-foss-2023b\n   GROMACS/2024.3-foss-2023b    \n   GROMACS/2024.4-foss-2023b (D)\n\n  Where:\n   D:  Default Module\n\n$ ml avail ESPResSo\n\n--- /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/generic/modules/all ---\n   ESPResSo/4.2.1-foss-2023a\n   ESPResSo/4.2.2-foss-2023a\n   ESPResSo/4.2.2-foss-2023b (D)\n   QuantumESPRESSO/7.2-foss-2022b\n   QuantumESPRESSO/7.3.1-foss-2023a (D)\n\n  Where:\n   D:  Default Module\n</code></pre> <p>This means we have to opt for Scenario 3 and build from source with GPU enabled, which is straightforward with the provided scripts and EESSI-extend. To build GPU-enabled software, we first need a full CUDA installation.</p> <pre><code>$ ml load EESSI-extend\n\n-- Using /tmp/$USER as a temporary working directory for installations, you can override this by setting the environment variable WORKING_DIR and reloading the module (e.g., /dev/shm is a common option)\nConfiguring for use of EESSI_USER_INSTALL under /home/darkless/eessi\n-- To create installations for EESSI, you _must_ have write permissions to /home/darkless/eessi/versions/2023.06/software/linux/x86_64/generic\n-- You may wish to configure a sources directory for EasyBuild (for example, via setting the environment variable EASYBUILD_SOURCEPATH) to allow you to reuse existing sources for packages.\n\n$ ml\n\nCurrently Loaded Modules:\n  1) EESSI/2023.06   2) EasyBuild/4.9.4   3) EESSI-extend/2023.06-easybuild\n\n$ export EESSI_SKIP_REMOVED_MODULES_CHECK=1\n\n$ ./scripts/gpu_support/nvidia/install_cuda_host_injections.sh --cuda-version 12.1.1 --temp-dir /tmp/$USER/EESSI --accept-cuda-eula\n== Temporary log file in case of crash /tmp/eb-orctkvdy/easybuild-oui6mf4a.log\n== found valid index for /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/generic/software/EasyBuild/4.9.4/easybuild/easyconfigs, so using it...\n== processing EasyBuild easyconfig /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/generic/software/EasyBuild/4.9.4/easybuild/easyconfigs/c/CUDA/CUDA-12.1.1.eb\n== building and installing CUDA/12.1.1...\n  &gt;&gt; installation prefix: /cvmfs/software.eessi.io/host_injections/2023.06/software/linux/x86_64/generic/software/CUDA/12.1.1\n== fetching files...\nDownloading cuda_12.1.1_530.30.02_linux.run \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2578\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 3.3/4.3 GB 10.5 MB/s 0:01:35\n\u2219\u25cf\u2219 Installing CUDA/12.1.1: fetching files (0 out of 17 steps done) \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 0:05:14\n... \n --- rest of the output ---\n...\n\nCUDA installation at /cvmfs/software.eessi.io/host_injections/2023.06/software/linux/x86_64/generic/software/CUDA/12.1.1 succeeded!\n</code></pre> <p>The most straightforward way to check GPU-enabled module is <code>deviceQuery</code> from <code>CUDA-Samples</code>, which identifies present GPU hardware.</p> <pre><code>$ ml avail CUDA-Samples\nNo module(s) or extension(s) found!\n\n$ cc=$(nvidia-smi --query-gpu=compute_cap --format=csv,noheader | head -1)\n$ eb --force --robot CUDA-Samples-12.1-GCC-12.3.0-CUDA-12.1.1.eb --cuda-compute-capabilities=\"$cc\"\n== Temporary log file in case of crash ...\n... \n --- rest of the output ---\n...\nCUDA-Samples installation at /cvmfs/software.eessi.io/host_injections/2023.06/software/linux/x86_64/generic/software/CUDA-Samples/12.1-GCC-12.3.0-CUDA-12.1.1 succeeded!\n\n$ ml load CUDA-Samples\n\n$ deviceQuery\n\ndeviceQuery Starting...\n\n CUDA Device Query (Runtime API) version (CUDART static linking)\n\nDetected 1 CUDA Capable device(s)\n\nDevice 0: \"NVIDIA GeForce RTX 2060\"\n  CUDA Driver Version / Runtime Version          12.4 / 12.1\n  CUDA Capability Major/Minor version number:    7.5\n  Total amount of global memory:                 5917 MBytes (6204162048 bytes)\n  (030) Multiprocessors, (064) CUDA Cores/MP:    1920 CUDA Cores\n  GPU Max Clock rate:                            1710 MHz (1.71 GHz)\n  Memory Clock rate:                             7001 Mhz\n  Memory Bus Width:                              192-bit\n  L2 Cache Size:                                 3145728 bytes\n  Maximum Texture Dimension Size (x,y,z)         1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384)\n  Maximum Layered 1D Texture Size, (num) layers  1D=(32768), 2048 layers\n  Maximum Layered 2D Texture Size, (num) layers  2D=(32768, 32768), 2048 layers\n  Total amount of constant memory:               65536 bytes\n  Total amount of shared memory per block:       49152 bytes\n  Total shared memory per multiprocessor:        65536 bytes\n  Total number of registers available per block: 65536\n  Warp size:                                     32\n  Maximum number of threads per multiprocessor:  1024\n  Maximum number of threads per block:           1024\n  Max dimension size of a thread block (x,y,z): (1024, 1024, 64)\n  Max dimension size of a grid size    (x,y,z): (2147483647, 65535, 65535)\n  Maximum memory pitch:                          2147483647 bytes\n  Texture alignment:                             512 bytes\n  Concurrent copy and kernel execution:          Yes with 3 copy engine(s)\n  Run time limit on kernels:                     Yes\n  Integrated GPU sharing Host Memory:            No\n  Support host page-locked memory mapping:       Yes\n  Alignment requirement for Surfaces:            Yes\n  Device has ECC support:                        Disabled\n  Device supports Unified Addressing (UVA):      Yes\n  Device supports Managed Memory:                Yes\n  Device supports Compute Preemption:            Yes\n  Supports Cooperative Kernel Launch:            Yes\n  Supports MultiDevice Co-op Kernel Launch:      Yes\n  Device PCI Domain ID / Bus ID / location ID:   0 / 1 / 0\n  Compute Mode:\n     &lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) &gt;\n\ndeviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 12.4, CUDA Runtime Version = 12.1, NumDevs = 1\nResult = PASS\n</code></pre> <p>We're also going to build <code>GROMACS</code> and <code>ESPResSo</code> with GPU support. All of this can be done in a similar way as building CUDA above, with just EESSI-extend and EasyBuild.</p> <pre><code>cc=$(nvidia-smi --query-gpu=compute_cap --format=csv,noheader | head -1)\n\neb --force --robot GROMACS-2023.3-foss-2023a-CUDA-12.1.1-PLUMED-2.9.0.eb --cuda-compute-capabilities=\"$cc\"\n\neb --force --robot ESPResSo-4.2.2-foss-2023a-CUDA-12.1.1.eb --cuda-compute-capabilities=\"$cc\"\n</code></pre> <p>After this, we can run GROMACS and ESPResSo with GPU support enabled.</p> <p>For testing and reproducibility, we created an installation script to provide a common approach for testing various systems. This script is described in detail below.</p>"},{"location":"blog/2025/03/24/gpu-support-in-eessi/#testing-eessi-with-nvidia-rtx-3060-on-fedora-and-ubuntu","title":"Testing EESSI with Nvidia RTX 3060 on Fedora and Ubuntu","text":"<p>We conducted additional testing with the NVIDIA RTX 3060 GPU (3,584 CUDA cores, 12GB GDDR6 memory, CUDA Compute Capability 8.6) on multiple operating systems: Ubuntu 24.04 and Fedora 41. This allowed us to identify and address additional distribution-specific installation challenges.</p> <p>The basic native installation procedure was identical to the RTX 2060 setup, requiring NVIDIA driver 550 and the same EESSI configuration steps. However, we encountered several distribution-specific issues during testing.</p> <p>On Ubuntu, we discovered that the nvidia-cuda-toolkit package created redundant CUDA libraries. For example, running <code>ldconfig -p | tr -s ' ' | cut -d ' ' -f4 | grep libOpenCL</code> showed multiple instances of the same library:</p> <pre><code>/usr/local/cuda/targets/x86_64-linux/lib/libOpenCL.so.1\n/lib/x86_64-linux-gnu/libOpenCL.so.1\n/usr/local/cuda/targets/x86_64-linux/lib/libOpenCL.so\n</code></pre> <p>This redundancy caused conflicts when the EESSI library linking script attempted to create symlinks. The script would fail because it couldn't determine which library version to use when multiple were present. We'll be updating the linking script in the future to handle this edge case.</p> <p>We encountered different issues on Fedora 41. When attempting a native EESSI installation, cvmfs failed to install with the error \"nothing provides redhat-release &gt;= 5 needed by cvmfs-release-4-1.noarch\", which has been fixed by PR #3774.</p> <p>Container environments presented another set of challenges. On Fedora, /tmp is mounted as a tmpfs with a limited size, which keeps everything in RAM. During the installation of CUDA, EasyBuild requires significant space in /tmp, which exceeded the default size limit of 8GB on the tested system. Increasing this size limit caused the machine to freeze due to RAM flooding with data from /tmp. After removing the tmpfs mount, EasyBuild could perform its build, but then the CUDA installer failed with a segfault. There was no output from the installer, and the log file at /var/log/cuda-installer.log provided no error messages. The only clue we had was a crash report from Fedora indicating that the CUDA installer failed in a function named getHomeDir.</p> <p>These findings led to several improvements in our installation script and documentation, providing more robust cross-distribution support for EESSI with GPU capabilities.</p> <p>The installation of EESSI and building the GPU-enabled software used the same approach as described in the previous section.</p>"},{"location":"blog/2025/03/24/gpu-support-in-eessi/#fast-deployment-automating-eessi-installation-with-gpu-support-on-azure","title":"Fast Deployment: Automating EESSI Installation with GPU Support on Azure","text":"<p>The image above depicts the complete installation and execution workflow with specific timing points at each stage of the process. Let's walk through these timing points:</p> <p>VM Provisioning and Setup:</p> <ul> <li>bootTime1: VM is provisioned and booted, ready for access (varies from seconds to minutes based on numerous factors like VM size, provider load, and image type)</li> <li>bootTime2: SSH connection established to the VM (typically takes only seconds once the VM is running)</li> <li>bootTime3: NVIDIA drivers installation complete (seconds if drivers are already installed or several minutes if they need to be installed and configured)</li> <li>bootTime4: EESSI installation scripts downloaded and ready to execute (just seconds to download and prepare the install script)</li> </ul> <p>Running install.sh:</p> <ul> <li>installTime1: Best case scenario - CUDA module is already available on EESSI CVMFS, allowing immediate access to GPU-enabled software (this took only 12-30 seconds on Azure NC_A100 with a single GPU with compute capability 8.0 and on ND_A100 with 8 GPUs)</li> <li>installTime2: CUDA modules need local installation - each CUDA download is approximately 4GB (we install both CUDA 12.1.1 and 12.4.0), adding significant time but establishing GPU capability (installing a single CUDA version takes around 5 minutes)</li> </ul> <p>Running run-demo.sh:</p> <ul> <li>runTime1: Best case scenario - The scientific module (GROMACS/ESPResSo) is available on EESSI CVMFS and can be loaded and run immediately (module loading time is minimal, around 2 seconds)</li> <li>runTime2: Module not found, but CUDA is available in host_injections - only module building is required (building GROMACS takes approximately 30 minutes even without running tests!)</li> <li>runTime3: Most time-intensive scenario - Module not found and CUDA not available in host_injections, requiring CUDA installation to fill the stubs from CVMFS CUDA Lmod module (similar to installTime2, about 5 minutes per CUDA version), followed by module building</li> </ul> <p>Although automating the installation process is not a primary objective of the EESSI project itself, it becomes crucial for our specific goal of deploying EESSI on Azure. Cloud services are billed by usage time, so minimizing the setup duration directly reduces costs. Being able to quickly spin up a machine and immediately begin processing scientific data represents a significant economic and practical benefit.</p> <p>To streamline this process, we've developed installation and demonstration scripts that provide a common approach for testing on various systems. The scripts handle EESSI installation, GPU library linking, CUDA installation when required, and verification of GPU functionality.</p> <p>For a complete implementation of these scripts, visit the EESSI GPU demo repository. This repository contains everything needed to set up and test GPU-enabled scientific software on EESSI, including detailed instructions for various scenarios.</p> <p>You can set up an Azure VM with full GPU support in just a few commands:</p> <pre><code>git clone https://github.com/EESSI/eessi-demo.git\ncd eessi-demo/gpu\n./install.sh\n\n./run-demo-ESPResSo-4.2.2-foss-2023a-CUDA-12.1.1.sh\n./run-demo-GROMACS-2024.4-foss-2023b-CUDA-12.4.0.sh\n</code></pre>"},{"location":"blog/2025/03/24/gpu-support-in-eessi/#scaling-to-the-cloud-eessi-on-azure-gpu-instances","title":"Scaling to the Cloud: EESSI on Azure GPU Instances","text":"<p>Azure offers a wide range of GPU-accelerated virtual machines, making it an excellent platform for testing EESSI's cloud readiness. The table below highlights some of the common CPU/GPU combinations available:</p> VM Series CPU Type CUDA Compute Capability GPU Type NCv3-series Broadwell cc 7.0 NVIDIA Tesla V100 NCasT4_v3-series Zen2 cc 7.5 NVIDIA Tesla T4 NC A100 v4-series Zen3 cc 8.0 NVIDIA A100 NC H100 v5-series Zen4 cc 9.0 NVIDIA H100 NVL ND A100 v4-series Zen2 cc 8.0 8x NVIDIA A100 ND H100 v5-series Sapphire Rapids cc 9.0 8x NVIDIA H100 NVv3-series Broadwell cc 5.2 NVIDIA Tesla M60 NVv4-series Zen2 N/A AMD Radeon Instinct MI25 NVads A10 v5-series Zen3 cc 8.6 NVIDIA A10 NVads V710 v5-series Zen4 N/A AMD Radeon Pro V710 <p>The CUDA Compute Capability is particularly important as it determines which CUDA features and instructions are available to software. For example:</p> <ul> <li>Capability 7.0-7.5 (V100, T4): Supports Tensor Cores (for AI acceleration), independent thread scheduling</li> <li>Capability 8.0-8.6 (A100, A10): Adds third-generation Tensor Cores, Sparse Matrix operations, and faster FP16 computation</li> <li>Capability 9.0 (H100): Introduces fourth-generation Tensor Cores, Transformer Engine, and significantly improved FP8 performance</li> </ul> <p>Among these combinations, we're focusing our build and optimization efforts on the configurations found in Azure and also in European HPC environments:</p> <ul> <li>AMD zen2 - cc 7.5, cc 8.0 (NCasT4_v3-series, ND A100 v4-series)</li> <li>AMD zen3 - cc 8.0, cc 8.6 (NC A100 v4-series, NVads A10 v5-series)</li> <li>AMD zen4 - cc 9.0 (NC H100 v5-series)</li> <li>Broadwell - cc 5.2, cc 7.0 (NVv3-series, NCv3-series)</li> </ul> <p>These target combinations allow us to cover a significant portion of the hardware landscape with pre-built packages, ensuring that scientists can quickly deploy their workloads on Azure with minimal configuration time. Our goal is to include these combinations in the standard EESSI distribution, making GPU-accelerated scientific computing in the cloud as accessible as possible.</p> <p>In the course of our testing, we encountered an issue where <code>nvidia-smi</code> was not available on certain A10 Graphics cards, which led us to use T4 GPUs instead for some of the testing. This is an important consideration when selecting Azure VM types for GPU computing with EESSI.</p>"},{"location":"blog/2025/03/24/gpu-support-in-eessi/#reflection-on-performance-metrics-mean-time-to-science","title":"Reflection on Performance Metrics - Mean-Time-to-Science","text":"<p>We tracked the time from VM provisioning to running the first GPU-enabled package to establish our \"mean-time-to-science\" metric. This measurement shows how quickly researchers can begin productive work using EESSI on various hardware configurations.</p> <p>Here's a breakdown of our findings across different hardware platforms:</p> Hardware Configuration Scenario Mean-Time-to-Science Azure NC_A100 (single A100, CC 8.0) Scenario 1 ~15 seconds Azure ND_A100 (8x A100, CC 8.0) Scenario 1 ~30 seconds Azure NC_A100 (single A100, CC 8.0) Scenario 2 ~10 minutes Azure NC_A100 (single A100, CC 8.0) Scenario 3 ~35 minutes Desktop PC with RTX 3060 (CC 8.6) Scenario 3 ~35 minutes Desktop PC with RTX 2060 (CC 7.5) Scenario 3 ~40 minutes <p>Key observations from our data:</p> <ol> <li> <p>Optimal Scenario: When the correct combination of CPU/GPU packages is pre-built on EESSI (Scenario 1), the mean-time-to-science can be as fast as 15 seconds from SSH connection to running GPU-enabled software on Azure.</p> </li> <li> <p>Software Installation Overheads: CUDA installation adds approximately 10 minutes, while building a complex scientific application like GROMACS adds about 25 minutes.</p> </li> <li> <p>Performance Gains: The GPU-accelerated versions consistently deliver 5-13x speedups compared to CPU-only versions. Being able to run GPU enabled packages on correct hardware allows huge computational boost.</p> </li> <li> <p>Hardware Differences: Enterprise GPUs like the NVIDIA A100 deliver the best performance, but consumer GPUs like the RTX 3060 and even the RTX 2060 can provide comparable speedups for scientific workloads.</p> </li> </ol> <p>Interesting finding was related to the GPU version of GROMACS, which occasionally crashes with the error: <code>PME tuning was still active</code>. This has been documented in the GROMACS paper section <code>4.5 Performance Counter Handling</code>.</p> <p>These metrics confirm that the time investment for setting up EESSI with GPU support is minimal compared to the performance benefits gained, especially when pre-built packages are available. Even in scenarios requiring custom builds, the setup time (20-40 minutes) is quickly balanced by the significant runtime speedups for scientific applications.</p>"},{"location":"blog/2025/03/24/gpu-support-in-eessi/#conclusion","title":"Conclusion","text":"<p>The integration of GPU support in EESSI significantly enhances scientific computing capabilities while maintaining the project's core principles of compatibility and ease of use. By providing a structured approach to handling GPU dependencies and offering tools for custom builds, EESSI enables researchers to leverage GPU acceleration across a variety of environments\u2014from desktop workstations to cloud infrastructure.</p> <p>Our testing on consumer hardware and Azure VMs demonstrates the flexibility of this approach, while our automation scripts reduce the mean-time-to-science to just minutes. The performance improvements are substantial, with GPU-accelerated software running 5-13 times faster than CPU-only versions in our benchmarks.</p> <p>As the EESSI project continues to evolve, we plan to expand our pre-built offerings for common CPU/GPU combinations and improve the tooling for custom builds. This will further reduce barriers to entry for GPU-accelerated scientific computing and enable researchers to focus on their science rather than software configuration.</p> <p>References:</p> <ul> <li>NVIDIA CUDA-Enabled GPUs</li> <li>Azure VM Sizes Overview</li> <li>EESSI Documentation</li> <li>NVIDIA CUDA EULA</li> </ul>"},{"location":"blog/2025/04/03/eessi-at-good-conf/","title":"Open OnDemand meets EESSI at Global Open OnDemand Conference (Boston)","text":"<p>On 18 March 2025 Christian Bustelo and Arturo Gimeno from Do IT Now showed to the attendees of the GOOD conference what EESSI is about and their preliminary work in integrating it in Open OnDemand.</p>"},{"location":"blog/2025/04/03/eessi-at-good-conf/#their-solution","title":"Their solution","text":"<p>Christian and Arturo presented this implementation highlighting three potential use cases:</p> <ol> <li>Training in using Open OnDemand</li> <li>Deploying EESSI applications</li> <li>Sharing software</li> </ol> <p>For training, the proposed solution using the triad of Magic Castle for setting up the environment in the cloud, Ansible for deploying OOD, and EESSI for software, was well accepted by the attendees.</p> <p>The deployment of new applications can be done in two different manners: by just adding a single application (see image below) or by offering the entire software stack allowing the users to select all the modules they need.</p> <p>Last, they presented how EESSI is fitted to share software among different HPC centers.</p>"},{"location":"blog/2025/04/03/eessi-at-good-conf/#the-takeaways","title":"The takeaways","text":"<p>The audience received EESSI as a valuable tool to have to take into account. Should we think about the replacement of the first \"E\" in its name?</p> <p>The video recording of the presentation should be available soon.</p> <p>You can find the slides already here.</p>"},{"location":"filesystem_layer/stratum1/","title":"Setting up a Stratum 1","text":"<p>The EESSI project provides a number of geographically distributed public Stratum 1 servers that you can use to make EESSI available on your machine(s). It is always recommended to have a local caching layer consisting of a few Squid proxies.  If you want to be even better protected against network outages and increase the bandwidth between your cluster nodes and the Stratum 1 servers, you could also consider setting up a local (private) Stratum 1 server that replicates the EESSI CVMFS repository. This guarantees that you always have a full and up-to-date copy of the entire stack available in your local network. </p>"},{"location":"filesystem_layer/stratum1/#requirements-for-a-stratum-1","title":"Requirements for a Stratum 1","text":"<p>The main requirements for a Stratum 1 server are a good network connection to the clients it is going to serve, and sufficient disk space. As the EESSI repository is constantly growing, make sure that the disk space can easily be extended if necessary.  Currently, we recommend to have at least 1 TB available.</p> <p>In terms of cores and memory, a machine with just a few (~4) cores and 4-8 GB of memory should suffice.</p> <p>Various Linux distributions are supported, but we recommend one based on RHEL 8 or 9.</p> <p>Finally, make sure that ports 80 and 8000 are open to clients.</p>"},{"location":"filesystem_layer/stratum1/#configure-the-stratum-1","title":"Configure the Stratum 1","text":"<p>Stratum 1 servers have to synchronize the contents of their CVMFS repositories regularly, and usually they replicate from a CVMFS Stratum 0 server.  In order to ensure the stability and security of the EESSI Stratum 0 server, it has a strict firewall, and only the EESSI-maintained public Stratum 1 servers are allowed to replicate from it. However, EESSI provides a synchronisation server that can be used for setting up private Stratum 1 replica servers, and this is available at <code>http://aws-eu-west-s1-sync.eessi.science</code>.</p> <p>Warn</p> <p>In the past we have seen a few occurrences of data transfer issues when files were being pulled in by or from a Stratum 1 server. In such cases the <code>cvmfs_server snapshot</code> command, used for synchronizing the Stratum 1, may break with errors like <code>failed to download &lt;URL to file&gt;</code>. Trying to manually download the mentioned file with <code>curl</code> will also not work, and result in errors like: <pre><code>curl: (56) Recv failure: Connection reset by peer\n</code></pre> In all cases this was due to an intrusion prevention system scanning the associated network, and hence scanning all files going in or out of the Stratum 1. Though it was a false-positive in all cases, this breaks the synchronization procedure of your Stratum 1. If this is the case, you can try switching to HTTPS by using <code>https://aws-eu-west-s1-sync.eessi.science</code> for synchronizing your Stratum 1. Even though there is no advantage for CVMFS itself in using HTTPS (it has built-in mechanisms for ensuring the integrity of the data), this will prevent the described issues, as the intrusion prevention system will not be able to inspect the encrypted data. However, not only does HTTPS introduce some overhead due to the encryption/decryption, it also makes caching in forward proxies impossible. Therefore, it is strongly discouraged to use HTTPS as default.</p>"},{"location":"filesystem_layer/stratum1/#manual-configuration","title":"Manual configuration","text":"<p>In order to set up a Stratum 1 manually, you can make use of the instructions in the Private Stratum 1 replica server section of the MultiXscale tutorial \"Best Practices for CernVM-FS in HPC\".</p>"},{"location":"filesystem_layer/stratum1/#configuration-using-ansible","title":"Configuration using Ansible","text":"<p>The recommended way for setting up an EESSI Stratum 1 is by running the Ansible playbook <code>stratum1.yml</code> from the filesystem-layer repository on GitHub. For the commands in this section, we are assuming that you cloned this repository, and your working directory is <code>filesystem-layer</code>.</p> <p>Note</p> <p>Installing a Stratum 1 usually requires a GEO API license key, which will be used to find the (geographically) closest Stratum 1 server for your client and proxies. However, for a private Stratum 1 this can be skipped, and you can disable the use of the GEO API in the configuration of your clients by setting <code>CVMFS_USE_GEOAPI=no</code>. In this case, they will just connect to your local Stratum 1 by default.</p> <p>If you do want to set up the GEO API, you can find more information on how to (freely) obtain this key in the CVMFS documentation: https://cvmfs.readthedocs.io/en/stable/cpt-replica.html#geo-api-setup.</p> <p>You can put your license key in the local configuration file <code>inventory/local_site_specific_vars.yml</code> with the variables <code>cvmfs_geo_license_key</code> and <code>cvmfs_geo_account_id</code>.</p> <p>Start by installing Ansible, e.g.:</p> <pre><code>sudo yum install -y ansible\n</code></pre> <p>Then install Ansible roles for EESSI:</p> <pre><code>ansible-galaxy role install -r ./requirements.yml --force\n</code></pre> <p>Make sure you have enough space in <code>/srv</code> on the Stratum 1, since the snapshots of the repositories will end up there by default. To alter the directory where the snapshots get stored you can manually create a symlink before running the playbook: <pre><code>sudo ln -s /lots/of/space/cvmfs /srv/cvmfs\n</code></pre></p> <p>Also make sure that:   - you are able to log in to the server from the machine that is going to run the playbook (preferably using an SSH key);   - you can use <code>sudo</code> on this machine;   - you add the hostname or IP address of your server to a <code>cvmfsstratum1servers</code> section in the <code>inventory/hosts</code> file, e.g.: <pre><code>[cvmfsstratum1servers]\n12.34.56.789 ansible_ssh_user=yourusername\n</code></pre></p> <p>Finally, install the Stratum 1 using:</p> <p><pre><code># -b to run as root, optionally use -K if a sudo password is required, and optionally include your site-specific variables\nansible-playbook -b [-K] [-e @inventory/local_site_specific_vars.yml] stratum1.yml\n</code></pre> Running the playbook will automatically make replicas of all the EESSI repositories defined in <code>inventory/group_vars/all.yml</code>. If you only want to replicate the main software repository (<code>software.eessi.io</code>), you can remove the other ones from the <code>eessi_cvmfs_repositories</code> list in this file.</p>"},{"location":"filesystem_layer/stratum1/#verification-of-the-stratum-1-using-curl","title":"Verification of the Stratum 1 using <code>curl</code>","text":"<p>When the playbook has finished, your Stratum 1 should be ready. In order to test your Stratum 1, even without a client installed, you can use <code>curl</code>:</p> <p><pre><code>curl --head http://&lt;url-or-ip-to-your-stratum1&gt;/cvmfs/software.eessi.io/.cvmfspublished\n</code></pre> This should return something like:</p> <pre><code>HTTP/1.1 200 OK\n...\nContent-Type: application/x-cvmfs\n</code></pre> <p>Example with the EESSI Stratum 1 running in AWS:</p> <pre><code>curl --head http://aws-eu-central-s1.eessi.science/cvmfs/software.eessi.io/.cvmfspublished\n</code></pre>"},{"location":"filesystem_layer/stratum1/#verification-of-the-stratum-1-using-a-cvmfs-client","title":"Verification of the Stratum 1 using a CVMFS client","text":"<p>You can, of course, also test access to your Stratum 1 from a client. This requires you to install a CernVM-FS client and add the Stratum 1 to the client configuration; this is explained in more detail on the native installation page.</p> <p>Then verify that the client connects to your new Stratum 1 by running:</p> <pre><code>cvmfs_config stat -v software.eessi.io\n</code></pre> <p>Assuming that your new Stratum 1 is working properly, this should return something like:</p> <pre><code>Connection: http://&lt;url-or-ip-to-your-stratum1&gt;/cvmfs/software.eessi.io through proxy DIRECT (online)\n</code></pre>"},{"location":"getting_access/eessi_container/","title":"EESSI container script","text":"<p>The <code>eessi_container.sh</code> script provides a very easy yet versatile means to access EESSI. It is the preferred method to start an EESSI container as it has support for many different scenarios via various options.</p> <p>This page guides you through several example scenarios illustrating the use of the script.</p>"},{"location":"getting_access/eessi_container/#prerequisites","title":"Prerequisites","text":"<ul> <li>Apptainer 1.0.0 (or newer), or Singularity 3.7.x<ul> <li>Check with <code>apptainer --version</code> or <code>singularity --version</code></li> <li>Support for the <code>--fusemount</code> option in the <code>shell</code> and <code>run</code> subcommands is required</li> </ul> </li> <li>Git<ul> <li>Check with <code>git --version</code></li> </ul> </li> </ul>"},{"location":"getting_access/eessi_container/#preparation","title":"Preparation","text":"<p>Clone the <code>EESSI/software-layer</code> repository and change into the <code>software-layer</code> directory by running these commands:</p> <pre><code>git clone https://github.com/EESSI/software-layer.git\ncd software-layer\n</code></pre>"},{"location":"getting_access/eessi_container/#quickstart","title":"Quickstart","text":"<p>Run the <code>eessi_container</code> script (from the <code>software-layer</code> directory) to start a shell session in the EESSI container:</p> <pre><code>./eessi_container.sh\n</code></pre> <p>Note</p> <p>Startup will take a bit longer the first time you run this because the container image is downloaded and converted.</p> <p>You should see output like <pre><code>Using /tmp/eessi.abc123defg as tmp storage (add '--resume /tmp/eessi.abc123defg' to resume where this session ended).\nPulling container image from docker://ghcr.io/eessi/build-node:debian11 to /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nLaunching container with command (next line):\nsingularity -q shell  --fusemount container:cvmfs2 cvmfs-config.cern.ch /cvmfs/cvmfs-config.cern.ch --fusemount container:cvmfs2 software.eessi.io /cvmfs/software.eessi.io /tmp/eessi.ymYGaZwoWC/ghcr.io_eessi_build_node_debian11.sif\nCernVM-FS: pre-mounted on file descriptor 3\nApptainer&gt; CernVM-FS: loading Fuse module... done\nCernVM-FS: loading Fuse module... done\n\nApptainer&gt;\n</code></pre></p> <p>Note</p> <p>You may have to press enter to clearly see the prompt as some messages beginning with <code>CernVM-FS:</code> have been printed after the first prompt <code>Apptainer&gt;</code> was shown.</p> <p>To start using EESSI, see Using EESSI/Setting up your environment.</p>"},{"location":"getting_access/eessi_container/#help-for-eessi_containersh","title":"Help for <code>eessi_container.sh</code>","text":"<p>The example in the Quickstart section facilitates an interactive session with read access to the EESSI software stack. It does not require any command line options, because the script <code>eessi_container.sh</code> uses some carefully chosen defaults. To view all options of the script and its default values, run the command <pre><code>./eessi_container.sh --help\n</code></pre> You should see the following output <pre><code>usage: ./eessi_container.sh [OPTIONS] [[--] SCRIPT or COMMAND]\n OPTIONS:\n  -a | --access {ro,rw}  - ro (read-only), rw (read &amp; write) [default: ro]\n  -c | --container IMG   - image file or URL defining the container to use\n                           [default: docker://ghcr.io/eessi/build-node:debian11]\n  -g | --storage DIR     - directory space on host machine (used for\n                           temporary data) [default: 1. TMPDIR, 2. /tmp]\n  -h | --help            - display this usage information [default: false]\n  -i | --host-injections - directory to link to for host_injections \n                           [default: /..storage../opt-eessi]\n  -l | --list-repos      - list available repository identifiers [default: false]\n  -m | --mode MODE       - with MODE==shell (launch interactive shell) or\n                           MODE==run (run a script or command) [default: shell]\n  -n | --nvidia MODE     - configure the container to work with NVIDIA GPUs,\n                           MODE==install for a CUDA installation, MODE==run to\n                           attach a GPU, MODE==all for both [default: false]\n  -r | --repository CFG  - configuration file or identifier defining the\n                           repository to use [default: EESSI via\n                           container configuration]\n  -u | --resume DIR/TGZ  - resume a previous run from a directory or tarball,\n                           where DIR points to a previously used tmp directory\n                           (check for output 'Using DIR as tmp ...' of a previous\n                           run) and TGZ is the path to a tarball which is\n                           unpacked the tmp dir stored on the local storage space\n                           (see option --storage above) [default: not set]\n  -s | --save DIR/TGZ    - save contents of tmp directory to a tarball in\n                           directory DIR or provided with the fixed full path TGZ\n                           when a directory is provided, the format of the\n                           tarball's name will be {REPO_ID}-{TIMESTAMP}.tgz\n                           [default: not set]\n  -v | --verbose         - display more information [default: false]\n  -x | --http-proxy URL  - provides URL for the env variable http_proxy\n                           [default: not set]; uses env var $http_proxy if set\n  -y | --https-proxy URL - provides URL for the env variable https_proxy\n                           [default: not set]; uses env var $https_proxy if set\n\n If value for --mode is 'run', the SCRIPT/COMMAND provided is executed. If\n arguments to the script/command start with '-' or '--', use the flag terminator\n '--' to let eessi_container.sh stop parsing arguments.\n</code></pre></p> <p>So, the defaults are equal to running the command <pre><code>./eessi_container.sh --access ro --container docker://ghcr.io/eessi/build-node:debian11 --mode shell --repository EESSI\n</code></pre> and it would either create a temporary directory under <code>${TMPDIR}</code> (if defined), or <code>/tmp</code> (if <code>${TMPDIR}</code> is not defined).</p> <p>The remainder of this page will demonstrate different scenarios using some of the command line options used for read-only access.</p> <p>Other options supported by the script will be discussed in a yet-to-be written section covering building software to be added to the EESSI stack.</p>"},{"location":"getting_access/eessi_container/#resuming-a-previous-session","title":"Resuming a previous session","text":"<p>You may have noted the following line in the output of <code>eessi_container.sh</code> <pre><code>Using /tmp/eessi.abc123defg as tmp storage (add '--resume /tmp/eessi.abc123defg' to resume where this session ended).\n</code></pre></p> <p>Note</p> <p>The parameter after <code>--resume</code> (<code>/tmp/eessi.abc123defg</code>) will be different when you run <code>eessi_container.sh</code>.</p> <p>Scroll back in your terminal and copy it so you can pass it to <code>--resume</code>.</p> <p>Try the following command to \"resume\" from the last session. <pre><code>./eessi_container.sh --resume /tmp/eessi.abc123defg\n</code></pre> This should run much faster because the container image has been cached in the temporary directory (<code>/tmp/eessi.abc123defg</code>). You should get to the prompt (<code>Apptainer&gt;</code> or <code>Singularity&gt;</code>) and can use EESSI with the state where you left the previous session.</p> <p>Note</p> <p>The state refers to what was stored on disk, not what was changed in memory. Particularly, any environment (variable) settings are not restored automatically.</p> <p>Because the <code>/tmp/eessi.abc123defg</code> directory contains a <code>home</code> directory which includes the saved history of your last session, you can easily restore the environment (variable) settings. Type <code>history</code> to see which commands you ran. You should be able to access the history as you would do in a normal terminal session.</p>"},{"location":"getting_access/eessi_container/#running-a-simple-command","title":"Running a simple command","text":"<p>Let's \"<code>ls /cvmfs/software.eessi.io</code>\" through the <code>eessi_container.sh</code> script to check if the CernVM-FS EESSI repository is accessible:</p> <pre><code>./eessi_container.sh --mode run ls /cvmfs/software.eessi.io\n</code></pre> <p>You should see an output such as</p> <pre><code>Using /tmp/eessi.abc123defg as tmp storage (add '--resume /tmp/eessi.abc123defg' to resume where this session ended).$\nPulling container image from docker://ghcr.io/eessi/build-node:debian11 to /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nLaunching container with command (next line):\nsingularity -q shell  --fusemount container:cvmfs2 cvmfs-config.cern.ch /cvmfs/cvmfs-config.cern.ch --fusemount container:cvmfs2 software.eessi.io /cvmfs/software.eessi.io /tmp/eessi.ymYGaZwoWC/ghcr.io_eessi_build_node_debian11.sif\nCernVM-FS: pre-mounted on file descriptor 3\nCernVM-FS: loading Fuse module... done\nhost_injections  latest  versions\n</code></pre> <p>Note that this time no interactive shell session is started in the container: only the provided command is run in the container, and when that finishes you are back in the shell session where you ran the <code>eessi_container.sh</code> script.</p> <p>This is because we used the <code>--mode run</code> command line option.</p> <p>Note</p> <p>The last line in the output is the output of the <code>ls</code> command, which shows the contents of the <code>/cvmfs/software.eessi.io</code> directory.</p> <p>Also, note that there is no shell prompt (<code>Apptainer&gt;</code> or <code>Singularity</code>), since no interactive shell session is started in the container.</p> <p>Alternatively to specify the command as we did above, you can also do the following. <pre><code>CMD=\"ls -l /cvmfs/software.eessi.io\"\n./eessi_container.sh --mode shell &lt;&lt;&lt; ${CMD}\n</code></pre></p> <p>Note</p> <p>We changed the mode from <code>run</code> to <code>shell</code> because we use a different method to let the script run our command, by feeding it in via the <code>stdin</code> input channel using <code>&lt;&lt;&lt;</code>.</p> <p>Because <code>shell</code> is the default value for <code>--mode</code> we can also omit this and simply run <pre><code>CMD=\"ls -l /cvmfs/software.eessi.io\"\n./eessi_container.sh &lt;&lt;&lt; ${CMD}\n</code></pre></p>"},{"location":"getting_access/eessi_container/#running-a-script","title":"Running a script","text":"<p>While running simple command can be sufficient in some cases, you often want to run scripts containing multiple commands.</p> <p>Let's run the script shown below.</p> <p>First, copy-paste the contents for the script shown below, and create a file named <code>eessi_architectures.sh</code> in your current directory. Also make the script executable, by running:</p> <pre><code>chmod +x eessi_architectures.sh\n</code></pre> <p>Here are the contents for the <code>eessi_architectures.sh</code> script:</p> <p><pre><code>#!/usr/bin/env bash\n#\n# This script determines which architectures are included in the\n# latest EESSI version. It makes use of the specific directory\n# structure in the EESSI repository.\n#\n\n# determine list of available OS types\nBASE=${EESSI_CVMFS_REPO:-/cvmfs/software.eessi.io}/latest/software\ncd ${BASE}\nfor os_type in $(ls -d *)\ndo\n    # determine architecture families\n    OS_BASE=${BASE}/${os_type}\n    cd ${OS_BASE}\n    for arch_family in $(ls -d *)\n    do\n        # determine CPU microarchitectures\n        OS_ARCH_BASE=${BASE}/${os_type}/${arch_family}\n        cd ${OS_ARCH_BASE}\n        for microarch in $(ls -d *)\n        do\n            case ${microarch} in\n                amd | intel )\n                    for sub in $(ls ${microarch})\n                    do\n                        echo \"${os_type}/${arch_family}/${microarch}/${sub}\"\n                    done\n                    ;;\n                * )\n                    echo \"${os_type}/${arch_family}/${microarch}\"\n                    ;;\n            esac\n        done\n    done\ndone\n</code></pre> Run the script as follows <pre><code>./eessi_container.sh --mode shell &lt; eessi_architectures.sh\n</code></pre> The output should be similar to <pre><code>Using /tmp/eessi.abc123defg as tmp storage (add '--resume /tmp/eessi.abc123defg' to resume where this session ended).$\nPulling container image from docker://ghcr.io/eessi/build-node:debian11 to /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nLaunching container with command (next line):\nsingularity -q shell --fusemount container:cvmfs2 software.eessi.io /cvmfs/software.eessi.io /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nCernVM-FS: pre-mounted on file descriptor 3\nCernVM-FS: loading Fuse module... done\nlinux/aarch64/generic\nlinux/aarch64/graviton2\nlinux/aarch64/graviton3\nlinux/ppc64le/generic\nlinux/ppc64le/power9le\nlinux/x86_64/amd/zen2\nlinux/x86_64/amd/zen3\nlinux/x86_64/generic\nlinux/x86_64/intel/haswell\nlinux/x86_64/intel/skylake_avx512\n</code></pre> Lines 6 to 15 show the output of the script <code>eessi_architectures.sh</code>.</p> <p>If you want to use the mode <code>run</code>, you have to make the script's location available inside the container.</p> <p>This can be done by mapping the current directory (<code>${PWD}</code>), which contains <code>eessi_architectures.sh</code>, to any not-yet existing directory inside the container using the <code>$SINGULARITY_BIND</code> or <code>$APPTAINER_BIND</code> environment variable.</p> <p>For example: <pre><code>SINGULARITY_BIND=${PWD}:/scripts ./eessi_container.sh --mode run /scripts/eessi_architectures.sh\n</code></pre></p>"},{"location":"getting_access/eessi_container/#running-scripts-or-commands-with-parameters-starting-with-or-","title":"Running scripts or commands with parameters starting with <code>-</code> or <code>--</code>","text":"<p>Let's assume we would like to get more information about the entries of <code>/cvmfs/software.eessi.io</code>. If we would just run <pre><code>./eessi_container.sh --mode run ls -lH /cvmfs/software.eessi.io\n</code></pre> we would get an error message such as <pre><code>ERROR: Unknown option: -lH\n</code></pre> We can resolve this in two ways:</p> <ol> <li>Using the <code>stdin</code> channel as described above, for example, by simply running   <pre><code>CMD=\"ls -lH /cvmfs/software.eessi.io\"\n./eessi_container.sh &lt;&lt;&lt; ${CMD}\n</code></pre>   which should result in the output similar to   <pre><code>Using /tmp/eessi.abc123defg as tmp directory (to resume session add '--resume /tmp/eessi.abc123defg').\nPulling container image from docker://ghcr.io/eessi/build-node:debian11 to /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nLaunching container with command (next line):\nsingularity -q shell --fusemount container:cvmfs2 software.eessi.io /cvmfs/software.eessi.io /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nCernVM-FS: pre-mounted on file descriptor 3\nCernVM-FS: loading Fuse module... done\nfuse: failed to clone device fd: Inappropriate ioctl for device\nfuse: trying to continue without -o clone_fd.\ntotal 10\nlrwxrwxrwx 1 user user   10 Jun 30  2021 host_injections -&gt; /opt/eessi\nlrwxrwxrwx 1 user user   16 May  4  2022 latest -&gt; versions/2021.12\ndrwxr-xr-x 3 user user 4096 Dec 10  2021 versions\n</code></pre></li> <li>Using the flag terminator <code>--</code> which tells <code>eessi_container.sh</code> to stop parsing command line arguments. For example,   <pre><code>./eessi_container.sh --mode run -- ls -lH /cvmfs/software.eessi.io\n</code></pre>   which should result in the output similar to   <pre><code>Using /tmp/eessi.abc123defg as tmp directory (to resume session add '--resume /tmp/eessi.abc123defg').\nPulling container image from docker://ghcr.io/eessi/build-node:debian11 to /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nLaunching container with command (next line):\nsingularity -q run --fusemount container:cvmfs2 software.eessi.io /cvmfs/software.eessi.io /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif ls -lH /cvmfs/software.eessi.io\nCernVM-FS: pre-mounted on file descriptor 3\nCernVM-FS: loading Fuse module... done\nfuse: failed to clone device fd: Inappropriate ioctl for device\nfuse: trying to continue without -o clone_fd.\ntotal 10\nlrwxrwxrwx 1 user user   10 Jun 30  2021 host_injections -&gt; /opt/eessi\nlrwxrwxrwx 1 user user   16 May  4  2022 latest -&gt; versions/2021.12\ndrwxr-xr-x 3 user user 4096 Dec 10  2021 versions\n</code></pre></li> </ol>"},{"location":"getting_access/eessi_container/#running-eessi-demos","title":"Running EESSI demos","text":"<p>For examples of scripts that use the software provided by EESSI, see Running EESSI demos.</p>"},{"location":"getting_access/eessi_container/#launching-containers-more-quickly","title":"Launching containers more quickly","text":"<p>Subsequent runs of <code>eessi_container.sh</code> may reuse temporary data of a previous session, which includes the pulled image of the container. However, that is not always what we want, i.e., reusing a previous session (and thereby launching the container more quickly).</p> <p>The <code>eessi_container.sh</code> script may (re)-use a cache directory provided via <code>$SINGULARITY_CACHEDIR</code> (or <code>$APPTAINER_CACHEDIR</code> when using Apptainer). Hence, the container image does not have to be downloaded again even when starting a new session. The example below illustrates this. <pre><code>export SINGULARITY_CACHEDIR=${PWD}/container_cache_dir\ntime ./eessi_container.sh &lt;&lt;&lt; \"ls /cvmfs/software.eessi.io\"\n</code></pre> which should produce output similar to <pre><code>Using /tmp/eessi.abc123defg as tmp directory (to resume session add '--resume /tmp/eessi.abc123defg').\nPulling container image from docker://ghcr.io/eessi/build-node:debian11 to /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nLaunching container with command (next line):\nsingularity -q shell --fusemount container:cvmfs2 software.eessi.io /cvmfs/software.eessi.io /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nCernVM-FS: pre-mounted on file descriptor 3\nCernVM-FS: loading Fuse module... done\nfuse: failed to clone device fd: Inappropriate ioctl for device\nfuse: trying to continue without -o clone_fd.\nhost_injections  latest  versions\n\nreal    m40.445s\nuser    3m2.621s\nsys     0m7.402s\n</code></pre> The next run using the same cache directory, e.g., by simply executing <pre><code>time ./eessi_container.sh &lt;&lt;&lt; \"ls /cvmfs/software.eessi.io\"\n</code></pre> is much faster <pre><code>Using /tmp/eessi.abc123defg as tmp directory (to resume session add '--resume /tmp/eessi.abc123defg').\nPulling container image from docker://ghcr.io/eessi/build-node:debian11 to /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nLaunching container with command (next line):\nsingularity -q shell --fusemount container:cvmfs2 software.eessi.io /cvmfs/software.eessi.io /tmp/eessi.abc123defg/ghcr.io_eessi_build_node_debian11.sif\nCernVM-FS: pre-mounted on file descriptor 3\nCernVM-FS: loading Fuse module... done\nfuse: failed to clone device fd: Inappropriate ioctl for device\nfuse: trying to continue without -o clone_fd.\nhost_injections  latest  versions\n\nreal    0m2.781s\nuser    0m0.172s\nsys     0m0.436s\n</code></pre></p> <p>Note</p> <p>Each run of <code>eessi_container.sh</code> (without specifying <code>--resume</code>) creates a new temporary directory. The temporary directory stores, among other data, the image file of the container. Thus we can ensure that the container is available locally for a subsequent run.</p> <p>However, this may quickly consume scarce resources, for example, a small partition where <code>/tmp</code> is located (default for temporary storage, see <code>--help</code> for specifying a different location).</p> <p>See next section for making sure to clean up no longer needed temporary data.</p>"},{"location":"getting_access/eessi_container/#reducing-disk-usage","title":"Reducing disk usage","text":"<p>By default <code>eessi_container.sh</code> creates a temporary directory under <code>/tmp</code>. The directories are named <code>eessi.RANDOM</code> where <code>RANDOM</code> is a 10-character string. The script does not automatically remove these directories. To determine their total disk usage, simply run <pre><code>du -sch /tmp/eessi.*\n</code></pre> which could result in output similar to <pre><code>333M    /tmp/eessi.session123\n333M    /tmp/eessi.session456\n333M    /tmp/eessi.session789\n997M    total\n</code></pre> Clean up disk usage by simply removing directories you do not need any longer.</p>"},{"location":"getting_access/eessi_container/#eessi-container-image","title":"EESSI container image","text":"<p>If you would like to directly use an EESSI container image, you can do so by configuring <code>apptainer</code> to correctly mount the CVMFS repository:</p> <pre><code># honor $TMPDIR if it is already defined, use /tmp otherwise\nif [ -z $TMPDIR ]; then\n    export WORKDIR=/tmp/$USER\nelse\n    export WORKDIR=$TMPDIR/$USER\nfi\n\nmkdir -p ${WORKDIR}/{var-lib-cvmfs,var-run-cvmfs,home}\nexport SINGULARITY_BIND=\"${WORKDIR}/var-run-cvmfs:/var/run/cvmfs,${WORKDIR}/var-lib-cvmfs:/var/lib/cvmfs\"\nexport SINGULARITY_HOME=\"${WORKDIR}/home:/home/$USER\"\nexport EESSI_REPO=\"container:cvmfs2 software.eessi.io /cvmfs/software.eessi.io\"\nexport EESSI_CONTAINER=\"docker://ghcr.io/eessi/client:centos7\"\nsingularity shell --fusemount \"$EESSI_REPO\" \"$EESSI_CONTAINER\"\n</code></pre>"},{"location":"getting_access/eessi_limactl/","title":"Installing EESSI with Lima on MacOS","text":""},{"location":"getting_access/eessi_limactl/#installation-of-lima","title":"Installation of Lima","text":"<p>See Lima documentation: https://lima-vm.io/docs/installation/</p> <pre><code>brew install lima\n</code></pre>"},{"location":"getting_access/eessi_limactl/#installing-eessi-in-limactl-with-eessi-template","title":"Installing EESSI in <code>limactl</code> with EESSI template","text":""},{"location":"getting_access/eessi_limactl/#example-eessiyaml-file","title":"Example <code>eessi.yaml</code> file","text":"<p>Use the EESSI template to install a virtual machine with eessi installed. Create a <code>eessi.yaml</code> file</p> Install a virtual machine with a Debian imageInstall a virtual machine with an Ubuntu imageInstall a virtual machine with a Rocky 9 image <pre><code># A template to use the EESSI software stack (see https://eessi.io) on macOS\n# $ limactl start ./eessi.yaml\n# $ limactl shell eessi\n\nimages:\n# Try to use release-yyyyMMdd image if available. Note that release-yyyyMMdd will be removed after several months.\n- location: \"https://cloud.debian.org/images/cloud/bookworm/20240429-1732/debian-12-genericcloud-amd64-20240429-1732.qcow2\"\n  arch: \"x86_64\"\n  digest: \"sha512:6cc752d71b390c7fea64b0b598225914a7f4adacd4a33fa366187fac01094648628e0681a109ae9320b9a79aba2832f33395fa13154dad636465b7d9cdbed599\"\n- location: \"https://cloud.debian.org/images/cloud/bookworm/20240429-1732/debian-12-genericcloud-arm64-20240429-1732.qcow2\"\n  arch: \"aarch64\"\n  digest: \"sha512:59afc40ad0062ca100c9280a281256487348c8aa23b3e70c329a6d6f29b5343b628622e63e0b9b4fc3987dd691d5f3c657233186b3271878d5e0aa0b4d264b06\"\n# Fallback to the latest release image.\n# Hint: run `limactl prune` to invalidate the cache\n- location: \"https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-genericcloud-amd64.qcow2\"\n  arch: \"x86_64\"\n- location: \"https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-genericcloud-arm64.qcow2\"\n  arch: \"aarch64\"\n\nmounts:\n- location: \"~\"\n- location: \"/tmp/lima\"\n  writable: true\ncontainerd:\n  system: false\n  user: false\nprovision:\n- mode: system\n  script: |\n    #!/bin/bash\n    wget -P /tmp https://ecsft.cern.ch/dist/cvmfs/cvmfs-release/cvmfs-release-latest_all.deb\n    sudo dpkg -i /tmp/cvmfs-release-latest_all.deb\n    rm -f /tmp/cvmfs-release-latest_all.deb\n    sudo apt-get update\n    sudo apt-get install -y cvmfs\n    if [ ! -f /etc/cvmfs/default.local ]; then\n        sudo echo \"CVMFS_HTTP_PROXY=DIRECT\" &gt;&gt; /etc/cvmfs/default.local\n        sudo echo \"CVMFS_QUOTA_LIMIT=10000\" &gt;&gt; /etc/cvmfs/default.local\n    fi\n    sudo cvmfs_config setup\nprobes:\n- script: |\n    #!/bin/bash\n    set -eux -o pipefail\n    if ! timeout 30s bash -c \"until ls /cvmfs/software.eessi.io &gt;/dev/null 2&gt;&amp;1; do sleep 3; done\"; then\n      echo &gt;&amp;2 \"EESSI repository is not available yet\"\n      exit 1\n    fi\n  hint: See \"/var/log/cloud-init-output.log\" in the guest\n</code></pre> <pre><code># A template to use the EESSI software stack (see https://eessi.io) on macOS\n# $ limactl start ./eessi.yaml\n# $ limactl shell eessi\n\nimages:\n# Try to use release-yyyyMMdd image if available. Note that release-yyyyMMdd will be removed after several months.\n- location: \"https://cloud-images.ubuntu.com/releases/22.04/release-20240514/ubuntu-22.04-server-cloudimg-amd64.img\"\n  arch: \"x86_64\"\n  digest: \"sha256:1718f177dde4c461148ab7dcbdcf2f410c1f5daa694567f6a8bbb239d864b525\"\n- location: \"https://cloud-images.ubuntu.com/releases/22.04/release-20240514/ubuntu-22.04-server-cloudimg-arm64.img\"\n  arch: \"aarch64\"\n  digest: \"sha256:f6bf7305207a2adb9a2e2f701dc71f5747e5ba88f7b67cdb44b3f5fa6eea94a3\"\n# Fallback to the latest release image.\n# Hint: run `limactl prune` to invalidate the cache\n- location: \"https://cloud-images.ubuntu.com/releases/22.04/release/ubuntu-22.04-server-cloudimg-amd64.img\"\n  arch: \"x86_64\"\n- location: \"https://cloud-images.ubuntu.com/releases/22.04/release/ubuntu-22.04-server-cloudimg-arm64.img\"\n  arch: \"aarch64\"\n\nmounts:\n- location: \"~\"\n- location: \"/tmp/lima\"\n  writable: true\ncontainerd:\n  system: false\n  user: false\nprovision:\n- mode: system\n  script: |\n    #!/bin/bash\n    wget -P /tmp https://ecsft.cern.ch/dist/cvmfs/cvmfs-release/cvmfs-release-latest_all.deb\n    sudo dpkg -i /tmp/cvmfs-release-latest_all.deb\n    rm -f /tmp/cvmfs-release-latest_all.deb\n    sudo apt-get update\n    sudo apt-get install -y cvmfs\n    if [ ! -f /etc/cvmfs/default.local ]; then\n        sudo echo \"CVMFS_HTTP_PROXY=DIRECT\" &gt;&gt; /etc/cvmfs/default.local\n        sudo echo \"CVMFS_QUOTA_LIMIT=10000\" &gt;&gt; /etc/cvmfs/default.local\n    fi\n    sudo cvmfs_config setup\nprobes:\n- script: |\n    #!/bin/bash\n    set -eux -o pipefail\n    if ! timeout 30s bash -c \"until ls /cvmfs/software.eessi.io &gt;/dev/null 2&gt;&amp;1; do sleep 3; done\"; then\n      echo &gt;&amp;2 \"EESSI repository is not available yet\"\n      exit 1\n    fi\n   hint: See \"/var/log/cloud-init-output.log\" in the guest\n</code></pre> <pre><code># A template to use the EESSI software stack (see https://eessi.io) on macOS\n# $ limactl start ./eessi.yaml\n# $ limactl shell eessi\n\nimages:\n- location: \"https://dl.rockylinux.org/pub/rocky/9.3/images/x86_64/Rocky-9-GenericCloud-Base-9.3-20231113.0.x86_64.qcow2\"\n  arch: \"x86_64\"\n  digest: \"sha256:7713278c37f29b0341b0a841ca3ec5c3724df86b4d97e7ee4a2a85def9b2e651\"\n- location: \"https://dl.rockylinux.org/pub/rocky/9.3/images/aarch64/Rocky-9-GenericCloud-Base-9.3-20231113.0.aarch64.qcow2\"\n  arch: \"aarch64\"\n  digest: \"sha256:1948a5e00786dbf3230335339cf96491659e17444f5d00dabac0f095a7354cc1\"\n# Fallback to the latest release image.\n# Hint: run `limactl prune` to invalidate the cache\n- location: \"https://dl.rockylinux.org/pub/rocky/9/images/x86_64/Rocky-9-GenericCloud.latest.x86_64.qcow2\"\n  arch: \"x86_64\"\n- location: \"https://dl.rockylinux.org/pub/rocky/9/images/aarch64/Rocky-9-GenericCloud.latest.aarch64.qcow2\"\n  arch: \"aarch64\"\n\nmounts:\n- location: \"~\"\n- location: \"/tmp/lima\"\n  writable: true\ncontainerd:\n  system: false\n  user: false\nprovision:\n- mode: system\n  script: |\n    #!/bin/bash\n    sudo yum install -y https://ecsft.cern.ch/dist/cvmfs/cvmfs-release/cvmfs-release-latest.noarch.rpm\n    sudo yum install -y cvmfs\n    if [ ! -f /etc/cvmfs/default.local ]; then\n        sudo echo \"CVMFS_HTTP_PROXY=DIRECT\" &gt;&gt; /etc/cvmfs/default.local\n        sudo echo \"CVMFS_QUOTA_LIMIT=10000\" &gt;&gt; /etc/cvmfs/default.local\n    fi\n    sudo cvmfs_config setup\nprobes:\n- script: |\n    #!/bin/bash\n    set -eux -o pipefail\n    if ! timeout 30s bash -c \"until ls /cvmfs/software.eessi.io &gt;/dev/null 2&gt;&amp;1; do sleep 3; done\"; then\n      echo &gt;&amp;2 \"EESSI repository is not available yet\"\n      exit 1\n    fi\n  hint: See \"/var/log/cloud-init-output.log\" in the guest\n</code></pre>"},{"location":"getting_access/eessi_limactl/#create-the-virtual-machine-with-the-eessiyaml-file","title":"Create the virtual machine with the <code>eessi.yaml</code> file","text":"<pre><code>limactl create --name eessi ./eessi.yaml\n</code></pre>"},{"location":"getting_access/eessi_limactl/#start-and-enter-the-virtual-machine","title":"Start and enter the virtual machine","text":"<pre><code>limactl start eessi\nlimactl shell eessi\n</code></pre> <p>EESSI should now be available in the virtual machine</p> <pre><code>user@machine:/Users/user$ source /cvmfs/software.eessi.io/versions/2023.06/init/bash\n  Found EESSI repo @ /cvmfs/software.eessi.io/versions/2023.06!\n  archdetect says x86_64/intel/haswell\n  Using x86_64/intel/haswell as software subdirectory.\n  Found Lmod configuration file at /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/intel/haswell/.lmod/lmodrc.lua\n  Found Lmod SitePackage.lua file at /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/intel/haswell/.lmod/SitePackage.lua\n  Using /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/intel/haswell/modules/all as the directory to be added to MODULEPATH.\n  Using /cvmfs/software.eessi.io/host_injections/2023.06/software/linux/x86_64/intel/haswell/modules/all as the site extension directory to be added to MODULEPATH.\n  Initializing Lmod...\n  Prepending /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/intel/haswell/modules/all to $MODULEPATH...\n  Prepending site path /cvmfs/software.eessi.io/host_injections/2023.06/software/linux/x86_64/intel/haswell/modules/all to $MODULEPATH...\n  Environment set up to use EESSI (2023.06), have fun!\n</code></pre>"},{"location":"getting_access/eessi_limactl/#cleanup-virtual-machine","title":"Cleanup virtual machine","text":"<pre><code>limactl stop eessi\nlimactl delete eessi\nlimactl prune\n</code></pre>"},{"location":"getting_access/eessi_limactl/#advanced-set-resources-for-new-virtual-machine","title":"Advanced: Set resources for new virtual machine","text":"<pre><code># Set resources\nRATIO_RAM=0.5\nRAM=$(numfmt --to=none --to-unit=1073741824 --format=%.0f  $(echo $(sysctl hw.memsize_usable | awk '{print $2}' ) \"*$RATIO_RAM\" | bc -l))\nCPUS=$(sysctl hw.physicalcpu | awk '{print $2}')\n# Create VM\nlimactl create --cpus $CPUS --memory $RAM --name eessi ./eessi.yaml\nlimactl list\n</code></pre>"},{"location":"getting_access/eessi_wsl/","title":"Installing EESSI with Windows Subsystem for Linux","text":""},{"location":"getting_access/eessi_wsl/#basic-commands-with-wsl","title":"Basic commands with WSL","text":""},{"location":"getting_access/eessi_wsl/#list-the-available-linux-distributions-for-installation","title":"List the available linux distributions for installation","text":"<pre><code>C:/users/user&gt;wsl --list --online\nThe following is a list of valid distributions that can be installed.\nInstall using 'wsl.exe --install &lt;Distro&gt;'.\n\nNAME                                   FRIENDLY NAME\nUbuntu                                 Ubuntu\nDebian                                 Debian GNU/Linux\nkali-linux                             Kali Linux Rolling\nUbuntu-18.04                           Ubuntu 18.04 LTS\nUbuntu-20.04                           Ubuntu 20.04 LTS\nUbuntu-22.04                           Ubuntu 22.04 LTS\nUbuntu-24.04                           Ubuntu 24.04 LTS\nOracleLinux_7_9                        Oracle Linux 7.9\nOracleLinux_8_7                        Oracle Linux 8.7\nOracleLinux_9_1                        Oracle Linux 9.1\nopenSUSE-Leap-15.5                     openSUSE Leap 15.5\nSUSE-Linux-Enterprise-Server-15-SP4    SUSE Linux Enterprise Server 15 SP4\nSUSE-Linux-Enterprise-15-SP5           SUSE Linux Enterprise 15 SP5\nopenSUSE-Tumbleweed                    openSUSE Tumbleweed\n</code></pre>"},{"location":"getting_access/eessi_wsl/#list-the-installed-machines","title":"List the installed machines","text":"<pre><code>C:/users/user&gt;wsl --list --verbose\n  NAME      STATE           VERSION\n* Debian    Stopped         2\n</code></pre>"},{"location":"getting_access/eessi_wsl/#reconnecting-to-a-virtual-machine-with-wsl","title":"Reconnecting to a Virtual machine with wsl","text":"<pre><code>C:/users/user&gt;wsl --distribution Debian\nuser@id:~$\n</code></pre> <p>For more documentation on using WSL you can check out the following pages:</p> <ul> <li> <p>Install WSL</p> </li> <li> <p>Basic commands for WSL</p> </li> </ul>"},{"location":"getting_access/eessi_wsl/#installing-a-linux-distribution-with-wsl","title":"Installing a linux distribution with WSL","text":"<pre><code>C:/users/user&gt;wsl --install --distribution Debian\nDebian GNU/Linux is already installed.\nLaunching Debian GNU/Linux...\nInstalling, this may take a few minutes...\nPlease create a default UNIX user account. The username does not need to match your Windows username.\nFor more information visit: https://aka.ms/wslusers\nEnter new UNIX username: user\nNew password:\nRetype new password:\npasswd: password updated successfully\nInstallation successful!\n</code></pre>"},{"location":"getting_access/eessi_wsl/#installing-eessi-in-the-virtual-machine","title":"Installing EESSI in the virtual machine","text":"<pre><code># Installation commands for Debian-based distros like Ubuntu, ...\n\n# install CernVM-FS\nsudo apt-get install lsb-release\nsudo apt-get install wget\nwget https://ecsft.cern.ch/dist/cvmfs/cvmfs-release/cvmfs-release-latest_all.deb\nsudo dpkg -i cvmfs-release-latest_all.deb\nrm -f cvmfs-release-latest_all.deb\nsudo apt-get update\nsudo apt-get install -y cvmfs\n\n# install EESSI configuration for CernVM-FS\nwget https://github.com/EESSI/filesystem-layer/releases/download/latest/cvmfs-config-eessi_latest_all.deb\nsudo dpkg -i cvmfs-config-eessi_latest_all.deb\n\n# create client configuration file for CernVM-FS (no squid proxy, 10GB local CernVM-FS client cache)\nsudo bash -c \"echo 'CVMFS_CLIENT_PROFILE=\"single\"' &gt; /etc/cvmfs/default.local\"\nsudo bash -c \"echo 'CVMFS_QUOTA_LIMIT=10000' &gt;&gt; /etc/cvmfs/default.local\"\n\n# make sure that EESSI CernVM-FS repository is accessible\nsudo cvmfs_config setup\n</code></pre>"},{"location":"getting_access/eessi_wsl/#start-cernvm-fs-in-windows-subsystem-for-linux","title":"Start cernVM-FS in Windows Subsystem for Linux","text":"<p>When the virtual machine is restarted CernVM-FS needs to be remounted with following command.</p> <pre><code># start CernVM-FS on WSL\nsudo cvmfs_config wsl2_start\n</code></pre> <p>If you do not wish to do this you can set up the automounter. Examples are available here.</p> <p>EESSI should now be available in the virtual machine</p> <pre><code>user@id:~$ source /cvmfs/software.eessi.io/versions/2023.06/init/bash\n  Found EESSI repo @ /cvmfs/software.eessi.io/versions/2023.06!\n  archdetect says x86_64/intel/haswell\n  Using x86_64/intel/haswell as software subdirectory.\n  Found Lmod configuration file at /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/intel/haswell/.lmod/lmodrc.lua\n  Found Lmod SitePackage.lua file at /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/intel/haswell/.lmod/SitePackage.lua\n  Using /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/intel/haswell/modules/all as the directory to be added to MODULEPATH.\n  Using /cvmfs/software.eessi.io/host_injections/2023.06/software/linux/x86_64/intel/haswell/modules/all as the site extension directory to be added to MODULEPATH.\n  Initializing Lmod...\n  Prepending /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/intel/haswell/modules/all to $MODULEPATH...\n  Prepending site path /cvmfs/software.eessi.io/host_injections/2023.06/software/linux/x86_64/intel/haswell/modules/all to $MODULEPATH...\n  Environment set up to use EESSI (2023.06), have fun!\n</code></pre>"},{"location":"getting_access/eessi_wsl/#cleanup-of-the-virtual-machine","title":"Cleanup of the virtual machine","text":"<pre><code>C:/users/user&gt;wsl --terminate Debian\nC:/users/user&gt;wsl --unregister Debian\n</code></pre>"},{"location":"getting_access/is_eessi_accessible/","title":"Is EESSI accessible?","text":"<p>EESSI can be accessed via a native (CernVM-FS) installation, or via a container that includes CernVM-FS.</p> <p>Before you look into these options, check if EESSI is already accessible on your system.</p> <p>Run the following command: <pre><code>ls /cvmfs/software.eessi.io\n</code></pre></p> <p>Note</p> <p>This <code>ls</code> command may take a couple of seconds to finish, since CernVM-FS may need to download or update the metadata for that directory.</p> <p>If you see output like shown below, you already have access to EESSI on your system.  <pre><code>host_injections  latest  versions\n</code></pre></p> <p>For starting to use EESSI, continue reading about Setting up environment.</p> <p>If you see an error message as shown below, EESSI is not yet accessible on your system. <pre><code>ls: /cvmfs/software.eessi.io: No such file or directory\n</code></pre> No worries, you don't need to be a  to get access to EESSI.</p> <p>Continue reading about the Native installation of EESSI, or access via the EESSI container.</p>"},{"location":"getting_access/native_installation/","title":"Native installation","text":""},{"location":"getting_access/native_installation/#installation-for-single-clients","title":"Installation for single clients","text":"<p>Setting up native access to EESSI, that is a system-wide deployment that does not require workarounds like using a container, requires the installation and configuration of CernVM-FS.</p> <p>This requires admin privileges, since you need to install CernVM-FS as an OS package.</p> <p>The following actions must be taken for a (basic) native installation of EESSI:</p> <ul> <li>Installing CernVM-FS itself, ideally using the OS packages provided by the CernVM-FS project   (although installing from source is also possible);</li> <li>Installing the EESSI configuration for CernVM-FS, which can be done by installing the <code>cvmfs-config-eessi</code>   package that we provide for the most popular Linux distributions   (more information available here);</li> <li>Creating a small client configuration file for CernVM-FS (<code>/etc/cvmfs/default.local</code>);   see also the CernVM-FS documentation.</li> </ul> <p>The good news is that all of this only requires a handful commands  :</p> RHEL-based Linux distributionsDebian-based Linux distributions <pre><code># Installation commands for RHEL-based distros like CentOS, Rocky Linux, Almalinux, Fedora, ...\n\n# install CernVM-FS\nsudo yum install -y https://ecsft.cern.ch/dist/cvmfs/cvmfs-release/cvmfs-release-latest.noarch.rpm\nsudo yum install -y cvmfs\n\n# install EESSI configuration for CernVM-FS\nsudo yum install -y https://github.com/EESSI/filesystem-layer/releases/download/latest/cvmfs-config-eessi-latest.noarch.rpm\n\n# create client configuration file for CernVM-FS (no squid proxy, 10GB local CernVM-FS client cache)\nsudo bash -c \"echo 'CVMFS_CLIENT_PROFILE=\"single\"' &gt; /etc/cvmfs/default.local\"\nsudo bash -c \"echo 'CVMFS_QUOTA_LIMIT=10000' &gt;&gt; /etc/cvmfs/default.local\"\n\n# make sure that EESSI CernVM-FS repository is accessible\nsudo cvmfs_config setup\n</code></pre> <pre><code># Installation commands for Debian-based distros like Ubuntu, ...\n\n# install CernVM-FS\nsudo apt-get install lsb-release\nwget https://ecsft.cern.ch/dist/cvmfs/cvmfs-release/cvmfs-release-latest_all.deb\nsudo dpkg -i cvmfs-release-latest_all.deb\nrm -f cvmfs-release-latest_all.deb\nsudo apt-get update\nsudo apt-get install -y cvmfs\n\n# install EESSI configuration for CernVM-FS\nwget https://github.com/EESSI/filesystem-layer/releases/download/latest/cvmfs-config-eessi_latest_all.deb\nsudo dpkg -i cvmfs-config-eessi_latest_all.deb\n\n# create client configuration file for CernVM-FS (no squid proxy, 10GB local CernVM-FS client cache)\nsudo bash -c \"echo 'CVMFS_CLIENT_PROFILE=\"single\"' &gt; /etc/cvmfs/default.local\"\nsudo bash -c \"echo 'CVMFS_QUOTA_LIMIT=10000' &gt;&gt; /etc/cvmfs/default.local\"\n\n# make sure that EESSI CernVM-FS repository is accessible\nsudo cvmfs_config setup\n</code></pre> <p>Note</p> <p>The default location for the cache directory is <code>/var/lib/cvmfs</code>. Please, check that the partition on which this directory is stored is big enough to store the cache (and other data). You may override this by adding <code>CVMFS_CACHE_BASE=&lt;some other directory for the cache&gt;</code> to your <code>default.local</code>, e.g., running <pre><code>sudo bash -c \"echo 'CVMFS_CACHE_BASE=&lt;some other directory for the cache&gt;' &gt;&gt; /etc/cvmfs/default.local\"\n</code></pre></p>"},{"location":"getting_access/native_installation/#installation-for-larger-systems-eg-clusters","title":"Installation for larger systems (e.g. clusters)","text":"<p>When using CernVM-FS on a larger number of local clients, e.g. on a HPC cluster or set of workstations, it is very strongly recommended to at least set up some Squid proxies close to your clients. These Squid proxies will be used to cache content that was recently accessed by your clients, which reduces the load on the Stratum 1 servers and reduces the latency for your clients. As a rule of thumb, you should use about one proxy per 500 clients, and have a minimum of two. Instructions for setting up a Squid proxy can be found in the CernVM-FS documentation and in the CernVM-FS tutorial.</p> <p>Additionally, setting up a private Stratum 1, which will make a full copy of the repository,  can be beneficial to improve the latency and bandwidth even further, and to be better protected against network outages. Instructions for setting up your own EESSI Stratum 1 can be found in setting up your own CernVM-FS Stratum 1 mirror server.</p>"},{"location":"getting_access/native_installation/#configuring-your-client-to-use-a-squid-proxy","title":"Configuring your client to use a Squid proxy","text":"<p>If you have set up one or more Squid proxies, you will have to add them to your CernVM-FS client configuration. This can be done by removing <code>CVMFS_CLIENT_PROFILE=\"single\"</code> from <code>/etc/cvmfs/default.local</code>, and add the following line:</p> <pre><code>CVMFS_HTTP_PROXY=\"http://ip-of-your-1st-proxy:port|http://ip-of-your-2nd-proxy:port\"\n</code></pre> <p>In this case, both proxies are equally preferable. More advanced use cases can be found in the CernVM-FS documentation.</p>"},{"location":"getting_access/native_installation/#configuring-your-client-to-use-a-private-stratum-1-mirror-server","title":"Configuring your client to use a private Stratum 1 mirror server","text":"<p>If you have set up your own Stratum 1 mirror server that replicates the EESSI CernVM-FS repositories, you can instruct your CernVM-FS client(s) to use it by prepending your newly created Stratum 1 to the existing list of EESSI Stratum 1 servers by creating a local CVMFS configuration file for the EESSI domain:</p> <pre><code>echo 'CVMFS_SERVER_URL=\"http://&lt;url-or-ip-to-your-stratum1&gt;/cvmfs/@fqrn@;$CVMFS_SERVER_URL\"' | sudo tee -a /etc/cvmfs/domain.d/eessi.io.local\n</code></pre> <p>It is also strongly recommended to disable the GEO API when using a private Stratum 1, because you want your private Stratum 1 to be picked first anyway. In order to do this, add the following to <code>/etc/cvmfs/domain.d/eessi.io.local</code>:</p> <pre><code>CVMFS_USE_GEOAPI=no\n</code></pre> <p>Note</p> <p>By prepending your new Stratum 1 to the list of existing Stratum 1 servers and disabling the GEO API, your clients should by default use the private Stratum 1. In case of downtime of your private Stratum 1, they will also still be able to make use of the public EESSI Stratum 1 servers.</p>"},{"location":"getting_access/native_installation/#applying-changes-in-the-cernvm-fs-client-configuration-files","title":"Applying changes in the CernVM-FS client configuration files","text":"<p>After you have made any changes to the CernVM-FS client configuration, you will have to apply them. If this is the first time you set up the client, you can simply run:</p> <pre><code>sudo cvmfs_config setup\n</code></pre> <p>If you already had configured the client before, you can reload the configuration for the EESSI repository (or, similarly, for any other repository) using:</p> <pre><code>sudo cvmfs_config reload -c software.eessi.io\n</code></pre>"},{"location":"known_issues/eessi-2023.06/","title":"Known issues","text":""},{"location":"known_issues/eessi-2023.06/#eessi-production-repository-v202306","title":"EESSI Production Repository (v2023.06)","text":""},{"location":"known_issues/eessi-2023.06/#failed-to-modify-ud-qp-to-init-on-mlx5_0-operation-not-permitted","title":"<code>Failed to modify UD QP to INIT on mlx5_0: Operation not permitted</code>","text":"<p>This is an error that occurs with OpenMPI after updating to OFED 23.10.</p> <p>There is an upstream issue on this problem opened with EasyBuild. See: https://github.com/easybuilders/easybuild-easyconfigs/issues/20233</p> Workarounds <p>You can instruct OpenMPI to not use libfabric and turn off `uct`(see https://openucx.readthedocs.io/en/master/running.html#running-mpi) by passing the following options to `mpirun`:</p> <pre><code>mpirun -mca pml ucx -mca btl '^uct,ofi' -mca mtl '^ofi'\n</code></pre>  Or equivalently, you can set the following environment variables:  <pre><code>export OMPI_MCA_btl='^uct,ofi'\nexport OMPI_MCA_pml='ucx'\nexport OMPI_MCA_mtl='^ofi'\n</code></pre>  You may also set these additional environment variables via site-specific Lmod hooks: <pre><code>require(\"strict\")\nlocal hook=require(\"Hook\")\n\n-- Fix Failed to modify UD QP to INIT on mlx5_0: Operation not permitted\nfunction fix_ud_qp_init_openmpi(t)\n    local simpleName = string.match(t.modFullName, \"(.-)/\")\n    if simpleName == 'OpenMPI' then\n        setenv('OMPI_MCA_btl', '^uct,ofi')\n        setenv('OMPI_MCA_pml', 'ucx')\n        setenv('OMPI_MCA_mtl', '^ofi')\n    end\nend\n\nlocal function combined_load_hook(t)\n    if eessi_load_hook ~= nil then\n        eessi_load_hook(t)\n    end\n    fix_ud_qp_init_openmpi(t)\nend\n\nhook.register(\"load\", combined_load_hook)\n</code></pre>  For more information about how to write and implement site-specific Lmod hooks, please check  [EESSI Site Specific Configuration LMOD Hooks](site_specific_config/lmod_hooks.md)"},{"location":"known_issues/eessi-2023.06/#gcc-1220-and-foss-2022b-based-modules-cannot-be-loaded-on-zen4-architecture","title":"GCC-12.2.0 and foss-2022b based modules cannot be loaded on <code>zen4</code> architecture","text":"<p>The <code>zen4</code> architecture was released late 2022. As a result, the compilers and BLAS libraries that are part of the 2022b toolchain generation did not yet (fully) support this architecture. Concretely, it was found in this pr that unit tests in the OpenBLAS version that is part of the foss-2022b toolchain were failing. As a result, it was decided that we would not support this toolchain-generation at all on the <code>zen4</code> architecture.</p>"},{"location":"meetings/2022-09-amsterdam/","title":"EESSI Community Meeting (Sept'22, Amsterdam)","text":""},{"location":"meetings/2022-09-amsterdam/#practical-info","title":"Practical info","text":"<ul> <li>dates: Wed-Fri 14-16 Sept'22</li> <li>in conjunction with CernVM workshop @ Nikhef (Mon-Tue 12-13 Sept'22)</li> <li>venue: \"Polderzaal\" at Cafe-Restaurant Polder (Google   Maps), sponsored by SURF</li> <li>registration (closed since Fri 9 Sept'22)</li> <li>Slack channel: <code>community-meeting-2022</code> in EESSI Slack</li> <li>YouTube playlist with recorded talks</li> </ul>"},{"location":"meetings/2022-09-amsterdam/#agenda","title":"Agenda","text":"<p>(subject to changes)</p> <p>We envision a mix of presentations, experience reports, demos, and hands-on sessions and/or hackathons related to the EESSI project.</p> <p>If you would like to give a talk or host a session, please let us know via the EESSI Slack!</p>"},{"location":"meetings/2022-09-amsterdam/#wed-14-sept-2022","title":"Wed 14 Sept 2022","text":"<ul> <li>[10:00-13:00] Welcome session<ul> <li>[10:00-10:30] Walk-in, coffee</li> <li>[10:30-12:00] Round table discussion (not live-streamed!)</li> </ul> </li> <li>[12:00-13:00] Lunch</li> <li>[13:00-15:00] Presentations on EESSI<ul> <li>[13:00-13:30] Introduction to EESSI (Caspar) [slides - recording]</li> <li>[13:30-14:00] Hands-on: how to use EESSI (Kenneth) [slides - recording]</li> <li>[14:00-14:30] EESSI use cases (Kenneth) [(slides - recording]</li> <li>[14:30-15:00] EESSI for sysadmins (Thomas) [slides - recording]</li> </ul> </li> <li>[15:00-15:30] Coffee break</li> <li>[15:30-17:00] Presentations on EESSI (continued)<ul> <li>[15:30-16:00] Hands-on: installing EESSI (Thomas/Kenneth)</li> <li>[16:00-16:45] ComputeCanada site talk (Bart Oldeman, remote) [slides - recording]</li> <li>[16:45-17:15] Magic Castle (Felix-Antoine Fortin, remote) [slides - recording]</li> </ul> </li> <li>[19:00-...] Group dinner @ Saravanaa Bhavan (sponsored by Dell Technologies)<ul> <li>address: Stadhouderskade 123-124, Amsterdam</li> </ul> </li> </ul>"},{"location":"meetings/2022-09-amsterdam/#thu-15-sept-2022","title":"Thu 15 Sept 2022","text":"<ul> <li>[09:30-12:00] More focused presentations on aspects of EESSI<ul> <li>[09:30-10:00] EESSI behind the scenes: compat layer (Bob) [slides - recording]</li> <li>[10:00-10:30] EESSI behind the scenes: software layer (Kenneth) [slides - recording]</li> <li>[10:30-11:00] Coffee break</li> <li>[11:00-11:30] EESSI behind the scenes: infrastructure (Terje) [slides - recording]</li> <li>[11:30-12:00] Status on RISC-V support (Kenneth) [slides - recording]</li> </ul> </li> <li>[12:00-13:00] Lunch</li> <li>[13:00-14:00] Discussions/hands-on sessions/hackathon</li> <li>[14:00-14:30] Status on GPU support (Alan) [slides - recording]</li> <li>[14:30-15:00] Status on build-and-deploy bot (Thomas) [slides - recording]</li> <li>[15:00-15:30] Coffee break</li> <li>[15:30-17:00] Discussions/hands-on sessions/hackathon (continued)<ul> <li>Hands-on with GPUs (Alan)</li> <li>Hands-on with bot (Thomas/Kenneth)</li> </ul> </li> <li>[19:00-...] Group dinner @ Italia Oggi (sponsored by HPC-UGent)<ul> <li>address: Binnen Bantammerstraat 11, Amsterdam</li> </ul> </li> </ul>"},{"location":"meetings/2022-09-amsterdam/#fri-16-sept-2022","title":"Fri 16 Sept 2022","text":"<ul> <li>[09:30-12:00] Presentations on future work<ul> <li>[09:30-10:00] Testing in software layer (Caspar) [slides - recording]</li> <li>[10:00-10:30] MultiXscale project (Alan) [slides - recording]</li> <li>[10:30-11:00] Coffee break</li> <li>[11:00-11:30] Short-term future work (Kenneth) [slides - recording]</li> </ul> </li> <li>[11:30-12:00] Discussion: future management structure of EESSI (Alan) [slides - recording]</li> <li>[12:00-13:00] Lunch</li> <li>[13:00-14:00] Site reports [recording]<ul> <li>NESSI (Thomas) [slides]</li> <li>NLPL (Stephan) [slides]</li> <li>HPCNow! (Danilo) [slides]</li> <li>Azure (Hugo) [slides]</li> </ul> </li> <li>[14:00-14:30] Discussion: what would make or break EESSI for your site? (notes - recording)</li> <li>[14:30-15:45] Discussions/hands-on sessions/hackathon<ul> <li>Hands-on with GPU support (Alan)</li> <li>Hands-on with bot (Thomas/Kenneth)</li> <li>Hands-on with software testing (Caspar)</li> </ul> </li> <li>We need to leave the room by 16:00!</li> </ul>"},{"location":"repositories/dev.eessi.io/","title":"Development repository (<code>dev.eessi.io</code>)","text":""},{"location":"repositories/dev.eessi.io/#what-is-deveessiio","title":"What is <code>dev.eessi.io</code>?","text":"<p><code>dev.eessi.io</code> is the development repository of EESSI. With it, developers can deploy pre-release builds of their software to EESSI.  This way, development versions of software can easily be tested on systems where the <code>dev.eessi.io</code> CernVM-FS repository is available.</p> <p>On a system with <code>dev.eessi.io</code> mounted access is possible with <code>module use /cvmfs/dev.eessi.io/versions/2023.06/modules/all</code>. Then, all that is left is try out the development software!</p>"},{"location":"repositories/dev.eessi.io/#question-or-problems","title":"Question or problems","text":"<p>If you have any questions regarding EESSI, or if you experience a problem in accessing or using it, please open a support request. If you experience issues with the development repository, feel free to use the #dev.eessi.io channel  of the EESSI Slack.</p>"},{"location":"repositories/dev.eessi.io/#infrastructure-status","title":"Infrastructure status","text":"<p>The status of the CernVM-FS infrastructure for the production repository is shown at https://status.eessi.io.</p>"},{"location":"repositories/pilot/","title":"Pilot","text":""},{"location":"repositories/pilot/#pilot-software-stack-202112","title":"Pilot software stack (2021.12)","text":""},{"location":"repositories/pilot/#caveats","title":"Caveats","text":"<p>Danger</p> <p>The EESSI pilot repository is no longer actively maintained, and should not be used for production work.</p> <p>Please use the <code>software.eessi.io</code> repository instead.</p> <p>The current EESSI pilot software stack (version 2021.12) is the 7th iteration, and there are some known issues and limitations, please take these into account:</p> <ul> <li>First of all: the EESSI pilot software stack is NOT READY FOR PRODUCTION!</li> </ul> <p>Do not use it for production work, and be careful when testing it on production systems!</p>"},{"location":"repositories/pilot/#reporting-problems","title":"Reporting problems","text":"<p>If you notice any problems, please report them via https://github.com/EESSI/software-layer/issues.</p>"},{"location":"repositories/pilot/#accessing-the-eessi-pilot-repository-through-singularity","title":"Accessing the EESSI pilot repository through Singularity","text":"<p>The easiest way to access the EESSI pilot repository is by using Singularity. If Singularity is installed already, no admin privileges are required. No other software is needed either on the host.</p> <p>A container image is available in the GitHub Container Registry  (see https://github.com/EESSI/filesystem-layer/pkgs/container/client-pilot). It only contains a minimal operating system + the necessary packages to access the EESSI pilot repository through CernVM-FS, and it is suitable for <code>aarch64</code>, <code>ppc64le</code>, and <code>x86_64</code>.</p> <p>The container image can be used directly by Singularity (no prior download required), as follows:</p> <ul> <li> <p>First, create some local directories in <code>/tmp/$USER</code> which will be bind mounted in the container:   <pre><code>mkdir -p /tmp/$USER/{var-lib-cvmfs,var-run-cvmfs,home}\n</code></pre>   These provides space for the CernVM-FS cache, and an empty home directory to use in the container.</p> </li> <li> <p>Set the <code>$SINGULARITY_BIND</code> and <code>$SINGULARITY_HOME</code> environment variables to configure Singularity:   <pre><code>export SINGULARITY_BIND=\"/tmp/$USER/var-run-cvmfs:/var/run/cvmfs,/tmp/$USER/var-lib-cvmfs:/var/lib/cvmfs\"\nexport SINGULARITY_HOME=\"/tmp/$USER/home:/home/$USER\"\n</code></pre></p> </li> <li> <p>Start the container using <code>singularity shell</code>, using <code>--fusemount</code> to mount the EESSI pilot repository   (using the <code>cvmfs2</code> command that is included in the container image):   <pre><code>export EESSI_PILOT=\"container:cvmfs2 pilot.eessi-hpc.org /cvmfs/pilot.eessi-hpc.org\"\nsingularity shell --fusemount \"$EESSI_PILOT\" docker://ghcr.io/eessi/client-pilot:centos7\n</code></pre></p> </li> <li> <p>This should give you a shell in the container, where the EESSI pilot repository is mounted:    <pre><code>$ singularity shell --fusemount \"$EESSI_PILOT\" docker://ghcr.io/eessi/client-pilot:centos7\nINFO:    Using cached SIF image\nCernVM-FS: pre-mounted on file descriptor 3\nCernVM-FS: loading Fuse module... done\nSingularity&gt;\n</code></pre></p> </li> <li>It is possible that you see some scary looking warnings, but those can be ignored for now.</li> </ul> <p>To verify that things are working, check the contents of the <code>/cvmfs/pilot.eessi-hpc.org/versions/2021.12</code> directory:    <pre><code>Singularity&gt; ls /cvmfs/pilot.eessi-hpc.org/versions/2021.12\ncompat  init  software\n</code></pre></p>"},{"location":"repositories/pilot/#standard-installation","title":"Standard installation","text":"<p>For those with privileges on their system, there are a number of example installation scripts for different architectures and operating systems available in the EESSI demo repository.</p> <p>Here we prefer the Singularity approach as we can guarantee that the container image is up to date.</p>"},{"location":"repositories/pilot/#setting-up-the-eessi-environment","title":"Setting up the EESSI environment","text":"<p>Once you have the EESSI pilot repository mounted, you can set up the environment by sourcing the provided init script:</p> <pre><code>source /cvmfs/pilot.eessi-hpc.org/versions/2021.12/init/bash\n</code></pre> <p>If all goes well, you should see output like this:</p> <pre><code>Found EESSI pilot repo @ /cvmfs/pilot.eessi-hpc.org/versions/2021.12!\nUsing x86_64/intel/haswell as software subdirectory.\nUsing /cvmfs/pilot.eessi-hpc.org/versions/2021.12/software/linux/x86_64/intel/haswell/modules/all as the directory to be added to MODULEPATH.\nFound Lmod configuration file at /cvmfs/pilot.eessi-hpc.org/versions/2021.12/software/linux/x86_64/intel/haswell/.lmod/lmodrc.lua\nInitializing Lmod...\nPrepending /cvmfs/pilot.eessi-hpc.org/versions/2021.12/software/linux/x86_64/intel/haswell/modules/all to $MODULEPATH...\nEnvironment set up to use EESSI pilot software stack, have fun!\n[EESSI pilot 2021.12] $ \n</code></pre> <p>Now you're all set up! Go ahead and explore the software stack using \"<code>module avail</code>\", and go wild with testing the available software installations!</p>"},{"location":"repositories/pilot/#testing-the-eessi-pilot-software-stack","title":"Testing the EESSI pilot software stack","text":"<p>Please test the EESSI pilot software stack as you see fit: running simple commands, performing small calculations or running small benchmarks, etc.</p> <p>Test scripts that have been verified to work correctly using the pilot software stack are available at https://github.com/EESSI/software-layer/tree/main/tests .</p>"},{"location":"repositories/pilot/#giving-feedback-or-reporting-problems","title":"Giving feedback or reporting problems","text":"<p>Any feedback is welcome, and questions or problems reports are welcome as well, through one of the EESSI communication channels:</p> <ul> <li>(preferred!) EESSI <code>software-layer</code> GitHub repository: https://github.com/EESSI/software-layer/issues</li> <li>EESSI mailing list (<code>eessi@list.rug.nl</code>)</li> <li>EESSI Slack: https://eessi-hpc.slack.com (get an invite via https://www.eessi-hpc.org/join)</li> <li>monthly EESSI meetings (first Thursday of the month at 2pm CEST)</li> </ul>"},{"location":"repositories/pilot/#available-software","title":"Available software","text":"<p>(last update: Mar 21st 2022)</p> <p>EESSI currently supports the following HPC applications as well as all their dependencies:</p> <ul> <li>GROMACS (2020.1 and 2020.4)</li> <li>OpenFOAM (v2006 and 8)</li> <li>R (4.0.0) + R-bundle-Bioconductor (3.11) + RStudio Server (1.3.1093)</li> <li>TensorFlow (2.3.1) and Horovod (0.21.3)</li> <li>OSU-Micro-Benchmarks (5.6.3)</li> <li>ReFrame (3.9.1)</li> <li>Spark (3.1.1)</li> <li>IPython (7.15.0)</li> <li>QuantumESPRESSO (6.6) (currently not available on <code>ppc64le</code>)</li> <li>WRF (3.9.1.1)</li> </ul> <pre><code>[EESSI pilot 2021.12] $ module --nx avail\n\n--------------------------- /cvmfs/pilot.eessi-hpc.org/versions/2021.12/software/linux/x86_64/intel/haswell/modules/all ----------------------------\n   ant/1.10.8-Java-11                                              LMDB/0.9.24-GCCcore-9.3.0\n   Arrow/0.17.1-foss-2020a-Python-3.8.2                            lz4/1.9.2-GCCcore-9.3.0\n   Bazel/3.6.0-GCCcore-9.3.0                                       Mako/1.1.2-GCCcore-9.3.0\n   Bison/3.5.3-GCCcore-9.3.0                                       MariaDB-connector-c/3.1.7-GCCcore-9.3.0\n   Boost/1.72.0-gompi-2020a                                        matplotlib/3.2.1-foss-2020a-Python-3.8.2\n   cairo/1.16.0-GCCcore-9.3.0                                      Mesa/20.0.2-GCCcore-9.3.0\n   CGAL/4.14.3-gompi-2020a-Python-3.8.2                            Meson/0.55.1-GCCcore-9.3.0-Python-3.8.2\n   CMake/3.16.4-GCCcore-9.3.0                                      METIS/5.1.0-GCCcore-9.3.0\n   CMake/3.20.1-GCCcore-10.3.0                                     MPFR/4.0.2-GCCcore-9.3.0\n   code-server/3.7.3                                               NASM/2.14.02-GCCcore-9.3.0\n   DB/18.1.32-GCCcore-9.3.0                                        ncdf4/1.17-foss-2020a-R-4.0.0\n   DB/18.1.40-GCCcore-10.3.0                                       netCDF-Fortran/4.5.2-gompi-2020a\n   double-conversion/3.1.5-GCCcore-9.3.0                           netCDF/4.7.4-gompi-2020a\n   Doxygen/1.8.17-GCCcore-9.3.0                                    nettle/3.6-GCCcore-9.3.0\n   EasyBuild/4.5.0                                                 networkx/2.4-foss-2020a-Python-3.8.2\n   EasyBuild/4.5.1                                         (D)     Ninja/1.10.0-GCCcore-9.3.0\n   Eigen/3.3.7-GCCcore-9.3.0                                       NLopt/2.6.1-GCCcore-9.3.0\n   Eigen/3.3.9-GCCcore-10.3.0                                      NSPR/4.25-GCCcore-9.3.0\n   ELPA/2019.11.001-foss-2020a                                     NSS/3.51-GCCcore-9.3.0\n   expat/2.2.9-GCCcore-9.3.0                                       nsync/1.24.0-GCCcore-9.3.0\n   expat/2.2.9-GCCcore-10.3.0                                      numactl/2.0.13-GCCcore-9.3.0\n   FFmpeg/4.2.2-GCCcore-9.3.0                                      numactl/2.0.14-GCCcore-10.3.0\n   FFTW/3.3.8-gompi-2020a                                          OpenBLAS/0.3.9-GCC-9.3.0\n   FFTW/3.3.9-gompi-2021a                                          OpenBLAS/0.3.15-GCC-10.3.0\n   flatbuffers/1.12.0-GCCcore-9.3.0                                OpenFOAM/v2006-foss-2020a\n   FlexiBLAS/3.0.4-GCC-10.3.0                                      OpenFOAM/8-foss-2020a                              (D)\n   fontconfig/2.13.92-GCCcore-9.3.0                                OpenMPI/4.0.3-GCC-9.3.0\n   foss/2020a                                                      OpenMPI/4.1.1-GCC-10.3.0\n   foss/2021a                                                      OpenPGM/5.2.122-GCCcore-9.3.0\n   freetype/2.10.1-GCCcore-9.3.0                                   OpenSSL/1.1                                        (D)\n   FriBidi/1.0.9-GCCcore-9.3.0                                     OSU-Micro-Benchmarks/5.6.3-gompi-2020a\n   GCC/9.3.0                                                       Pango/1.44.7-GCCcore-9.3.0\n   GCC/10.3.0                                                      ParaView/5.8.0-foss-2020a-Python-3.8.2-mpi\n   GCCcore/9.3.0                                                   PCRE/8.44-GCCcore-9.3.0\n   GCCcore/10.3.0                                                  PCRE2/10.34-GCCcore-9.3.0\n   Ghostscript/9.52-GCCcore-9.3.0                                  Perl/5.30.2-GCCcore-9.3.0\n   giflib/5.2.1-GCCcore-9.3.0                                      Perl/5.32.1-GCCcore-10.3.0\n   git/2.23.0-GCCcore-9.3.0-nodocs                                 pixman/0.38.4-GCCcore-9.3.0\n   git/2.32.0-GCCcore-10.3.0-nodocs                        (D)     pkg-config/0.29.2-GCCcore-9.3.0\n   GLib/2.64.1-GCCcore-9.3.0                                       pkg-config/0.29.2-GCCcore-10.3.0\n   GLPK/4.65-GCCcore-9.3.0                                         pkg-config/0.29.2                                  (D)\n   GMP/6.2.0-GCCcore-9.3.0                                         pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2\n   GMP/6.2.1-GCCcore-10.3.0                                        PMIx/3.1.5-GCCcore-9.3.0\n   gnuplot/5.2.8-GCCcore-9.3.0                                     PMIx/3.2.3-GCCcore-10.3.0\n   GObject-Introspection/1.64.0-GCCcore-9.3.0-Python-3.8.2         poetry/1.0.9-GCCcore-9.3.0-Python-3.8.2\n   gompi/2020a                                                     protobuf-python/3.13.0-foss-2020a-Python-3.8.2\n   gompi/2021a                                                     protobuf/3.13.0-GCCcore-9.3.0\n   groff/1.22.4-GCCcore-9.3.0                                      pybind11/2.4.3-GCCcore-9.3.0-Python-3.8.2\n   groff/1.22.4-GCCcore-10.3.0                                     pybind11/2.6.2-GCCcore-10.3.0\n   GROMACS/2020.1-foss-2020a-Python-3.8.2                          Python/2.7.18-GCCcore-9.3.0\n   GROMACS/2020.4-foss-2020a-Python-3.8.2                  (D)     Python/3.8.2-GCCcore-9.3.0\n   GSL/2.6-GCC-9.3.0                                               Python/3.9.5-GCCcore-10.3.0-bare\n   gzip/1.10-GCCcore-9.3.0                                         Python/3.9.5-GCCcore-10.3.0\n   h5py/2.10.0-foss-2020a-Python-3.8.2                             PyYAML/5.3-GCCcore-9.3.0\n   HarfBuzz/2.6.4-GCCcore-9.3.0                                    Qt5/5.14.1-GCCcore-9.3.0\n   HDF5/1.10.6-gompi-2020a                                         QuantumESPRESSO/6.6-foss-2020a\n   Horovod/0.21.3-foss-2020a-TensorFlow-2.3.1-Python-3.8.2         R-bundle-Bioconductor/3.11-foss-2020a-R-4.0.0\n   hwloc/2.2.0-GCCcore-9.3.0                                       R/4.0.0-foss-2020a\n   hwloc/2.4.1-GCCcore-10.3.0                                      re2c/1.3-GCCcore-9.3.0\n   hypothesis/6.13.1-GCCcore-10.3.0                                RStudio-Server/1.3.1093-foss-2020a-Java-11-R-4.0.0\n   ICU/66.1-GCCcore-9.3.0                                          Rust/1.52.1-GCCcore-10.3.0\n   ImageMagick/7.0.10-1-GCCcore-9.3.0                              ScaLAPACK/2.1.0-gompi-2020a\n   IPython/7.15.0-foss-2020a-Python-3.8.2                          ScaLAPACK/2.1.0-gompi-2021a-fb\n   JasPer/2.0.14-GCCcore-9.3.0                                     scikit-build/0.10.0-foss-2020a-Python-3.8.2\n   Java/11.0.2                                             (11)    SciPy-bundle/2020.03-foss-2020a-Python-3.8.2\n   jbigkit/2.1-GCCcore-9.3.0                                       SciPy-bundle/2021.05-foss-2021a\n   JsonCpp/1.9.4-GCCcore-9.3.0                                     SCOTCH/6.0.9-gompi-2020a\n   LAME/3.100-GCCcore-9.3.0                                        snappy/1.1.8-GCCcore-9.3.0\n   libarchive/3.5.1-GCCcore-10.3.0                                 Spark/3.1.1-foss-2020a-Python-3.8.2\n   libcerf/1.13-GCCcore-9.3.0                                      SQLite/3.31.1-GCCcore-9.3.0\n   libdrm/2.4.100-GCCcore-9.3.0                                    SQLite/3.35.4-GCCcore-10.3.0\n   libevent/2.1.11-GCCcore-9.3.0                                   SWIG/4.0.1-GCCcore-9.3.0\n   libevent/2.1.12-GCCcore-10.3.0                                  Szip/2.1.1-GCCcore-9.3.0\n   libfabric/1.11.0-GCCcore-9.3.0                                  Tcl/8.6.10-GCCcore-9.3.0\n   libfabric/1.12.1-GCCcore-10.3.0                                 Tcl/8.6.11-GCCcore-10.3.0\n   libffi/3.3-GCCcore-9.3.0                                        tcsh/6.22.02-GCCcore-9.3.0\n   libffi/3.3-GCCcore-10.3.0                                       TensorFlow/2.3.1-foss-2020a-Python-3.8.2\n   libgd/2.3.0-GCCcore-9.3.0                                       time/1.9-GCCcore-9.3.0\n   libGLU/9.0.1-GCCcore-9.3.0                                      Tk/8.6.10-GCCcore-9.3.0\n   libglvnd/1.2.0-GCCcore-9.3.0                                    Tkinter/3.8.2-GCCcore-9.3.0\n   libiconv/1.16-GCCcore-9.3.0                                     UCX/1.8.0-GCCcore-9.3.0\n   libjpeg-turbo/2.0.4-GCCcore-9.3.0                               UCX/1.10.0-GCCcore-10.3.0\n   libpciaccess/0.16-GCCcore-9.3.0                                 UDUNITS/2.2.26-foss-2020a\n   libpciaccess/0.16-GCCcore-10.3.0                                UnZip/6.0-GCCcore-9.3.0\n   libpng/1.6.37-GCCcore-9.3.0                                     UnZip/6.0-GCCcore-10.3.0\n   libsndfile/1.0.28-GCCcore-9.3.0                                 WRF/3.9.1.1-foss-2020a-dmpar\n   libsodium/1.0.18-GCCcore-9.3.0                                  X11/20200222-GCCcore-9.3.0\n   LibTIFF/4.1.0-GCCcore-9.3.0                                     x264/20191217-GCCcore-9.3.0\n   libtirpc/1.2.6-GCCcore-9.3.0                                    x265/3.3-GCCcore-9.3.0\n   libunwind/1.3.1-GCCcore-9.3.0                                   xorg-macros/1.19.2-GCCcore-9.3.0\n   libxc/4.3.4-GCC-9.3.0                                           xorg-macros/1.19.3-GCCcore-10.3.0\n   libxml2/2.9.10-GCCcore-9.3.0                                    Xvfb/1.20.9-GCCcore-9.3.0\n   libxml2/2.9.10-GCCcore-10.3.0                                   Yasm/1.3.0-GCCcore-9.3.0\n   libyaml/0.2.2-GCCcore-9.3.0                                     ZeroMQ/4.3.2-GCCcore-9.3.0\n   LittleCMS/2.9-GCCcore-9.3.0                                     Zip/3.0-GCCcore-9.3.0\n   LLVM/9.0.1-GCCcore-9.3.0                                        zstd/1.4.4-GCCcore-9.3.0\n</code></pre>"},{"location":"repositories/pilot/#architecture-and-micro-architecture-support","title":"Architecture and micro-architecture support","text":""},{"location":"repositories/pilot/#x86_64","title":"x86_64","text":"<ul> <li>generic (currently implies <code>march=x86-64</code> and <code>-mtune=generic</code>)</li> <li>AMD<ul> <li>zen2 (Rome)</li> <li>zen3 (Milan)</li> </ul> </li> <li>Intel<ul> <li>haswell</li> <li>skylake_avx512</li> </ul> </li> </ul>"},{"location":"repositories/pilot/#aarch64arm64","title":"aarch64/arm64","text":"<ul> <li>generic (currently implies <code>-march=armv8-a</code> and <code>-mtune=generic</code>)</li> <li>AWS Graviton2</li> </ul>"},{"location":"repositories/pilot/#ppc64le","title":"ppc64le","text":"<ul> <li>generic</li> <li>power9le</li> </ul>"},{"location":"repositories/pilot/#easybuild-configuration","title":"EasyBuild configuration","text":"<p>EasyBuild v4.5.1 was used to install the software in the <code>2021.12</code> version of the pilot repository. For some installations pull requests with changes that will be included in later EasyBuild versions were leveraged, see the build script that was used.</p> <p>An example configuration of the build environment based on https://github.com/EESSI/software-layer can be seen here: <pre><code>$ eb --show-config\n#\n# Current EasyBuild configuration\n# (C: command line argument, D: default value, E: environment variable, F: configuration file)\n#\nbuildpath         (E) = /tmp/eessi-build/easybuild/build\ncontainerpath     (E) = /tmp/eessi-build/easybuild/containers\ndebug             (E) = True\nfilter-deps       (E) = Autoconf, Automake, Autotools, binutils, bzip2, cURL, DBus, flex, gettext, gperf, help2man, intltool, libreadline, libtool, Lua, M4, makeinfo, ncurses, util-linux, XZ, zlib\nfilter-env-vars   (E) = LD_LIBRARY_PATH\nhooks             (E) = /home/eessi-build/software-layer/eb_hooks.py\nignore-osdeps     (E) = True\ninstallpath       (E) = /cvmfs/pilot.eessi-hpc.org/2021.06/software/linux/x86_64/intel/haswell\nmodule-extensions (E) = True\npackagepath       (E) = /tmp/eessi-build/easybuild/packages\nprefix            (E) = /tmp/eessi-build/easybuild\nrepositorypath    (E) = /tmp/eessi-build/easybuild/ebfiles_repo\nrobot-paths       (D) = /cvmfs/pilot.eessi-hpc.org/versions/2021.12/software/linux/x86_64/intel/haswell/software/EasyBuild/4.5.1/easybuild/easyconfigs\nrpath             (E) = True\nsourcepath        (E) = /tmp/eessi-build/easybuild/sources:\nsysroot           (E) = /cvmfs/pilot.eessi-hpc.org/versions/2021.12/compat/linux/x86_64\ntrace             (E) = True\nzip-logs          (E) = bzip2\n</code></pre></p>"},{"location":"repositories/pilot/#infrastructure-status","title":"Infrastructure status","text":"<p>The status of the CernVM-FS infrastructure for the pilot repository is shown at http://status.eessi.io/pilot/.</p>"},{"location":"repositories/riscv.eessi.io/","title":"EESSI RISC-V development repository (<code>riscv.eessi.io</code>)","text":"<p>This repository contains development versions of an EESSI RISC-V software stack. Note that versions may be added, modified, or deleted at any time.</p>"},{"location":"repositories/riscv.eessi.io/#accessing-the-risc-v-repository","title":"Accessing the RISC-V repository","text":"<p>See Getting access; by making the EESSI CVMFS domain available, you will automatically have access to <code>riscv.eessi.io</code> as well.</p>"},{"location":"repositories/riscv.eessi.io/#using-riscveessiio","title":"Using <code>riscv.eessi.io</code>","text":"<p>This repository currently offers one version (20240402), and this contains both a compatibility layer and a software layer. Furthermore, initialization scripts are in place to set up the repository:</p> <pre><code>$ source /cvmfs/riscv.eessi.io/versions/20240402/init/bash\nFound EESSI repo @ /cvmfs/riscv.eessi.io/versions/20240402!\narchdetect says riscv64/generic\nUsing riscv64/generic as software subdirectory.\nFound Lmod configuration file at /cvmfs/riscv.eessi.io/versions/20240402/software/linux/riscv64/generic/.lmod/lmodrc.lua\nFound Lmod SitePackage.lua file at /cvmfs/riscv.eessi.io/versions/20240402/software/linux/riscv64/generic/.lmod/SitePackage.lua\nUsing /cvmfs/riscv.eessi.io/versions/20240402/software/linux/riscv64/generic/modules/all as the directory to be added to MODULEPATH.\nInitializing Lmod...\nPrepending /cvmfs/riscv.eessi.io/versions/20240402/software/linux/riscv64/generic/modules/all to $MODULEPATH...\nEnvironment set up to use EESSI (20240402), have fun!\n{EESSI 20240402} $\n</code></pre> <p>You can even source the initialization script of the <code>software.eessi.io</code> production repository now, and it will automatically set up the RISC-V repository for you: <pre><code>$ source /cvmfs/software.eessi.io/versions/2023.06/init/bash \nRISC-V architecture detected, but there is no RISC-V support yet in the production repository.\nAutomatically switching to version 20240402 of the RISC-V development repository /cvmfs/riscv.eessi.io.\nFor more details about this repository, see https://www.eessi.io/docs/repositories/riscv.eessi.io/.\n\nFound EESSI repo @ /cvmfs/riscv.eessi.io/versions/20240402!\narchdetect says riscv64/generic\nUsing riscv64/generic as software subdirectory.\nFound Lmod configuration file at /cvmfs/riscv.eessi.io/versions/20240402/software/linux/riscv64/generic/.lmod/lmodrc.lua\nFound Lmod SitePackage.lua file at /cvmfs/riscv.eessi.io/versions/20240402/software/linux/riscv64/generic/.lmod/SitePackage.lua\nUsing /cvmfs/riscv.eessi.io/versions/20240402/software/linux/riscv64/generic/modules/all as the directory to be added to MODULEPATH.\nUsing /cvmfs/riscv.eessi.io/host_injections/20240402/software/linux/riscv64/generic/modules/all as the site extension directory to be added to MODULEPATH.\nInitializing Lmod...\nPrepending /cvmfs/riscv.eessi.io/versions/20240402/software/linux/riscv64/generic/modules/all to $MODULEPATH...\nPrepending site path /cvmfs/riscv.eessi.io/host_injections/20240402/software/linux/riscv64/generic/modules/all to $MODULEPATH...\nEnvironment set up to use EESSI (20240402), have fun!\n{EESSI 20240402} $ \n</code></pre></p> <p>Note that we currently only provide generic builds, hence <code>riscv64/generic</code> is being used for all RISC-V CPUs.</p> <p>The amount of software is constantly increasing. Besides having the <code>foss/2023b</code> toolchain available, applications like dlb, GROMACS, OSU Micro-Benchmarks, and R are already available as well. Use <code>module avail</code> to get a full and up-to-date listing of available software.</p>"},{"location":"repositories/riscv.eessi.io/#infrastructure-status","title":"Infrastructure status","text":"<p>The status of the CernVM-FS infrastructure for this repository is shown at https://status.eessi.io.</p>"},{"location":"repositories/software.eessi.io/","title":"Production EESSI repository (<code>software.eessi.io</code>)","text":""},{"location":"repositories/software.eessi.io/#question-or-problems","title":"Question or problems","text":"<p>If you have any questions regarding EESSI, or if you experience a problem in accessing or using it, please open a support request.</p>"},{"location":"repositories/software.eessi.io/#accessing-the-eessi-repository","title":"Accessing the EESSI repository","text":"<p>See Getting access.</p>"},{"location":"repositories/software.eessi.io/#using-softwareeessiio","title":"Using <code>software.eessi.io</code>","text":"<p>See Using EESSI.</p>"},{"location":"repositories/software.eessi.io/#available-software","title":"Available software","text":"<p>See Available software.</p>"},{"location":"repositories/software.eessi.io/#architecture-and-micro-architecture-support","title":"Architecture and micro-architecture support","text":"<p>See CPU targets.</p>"},{"location":"repositories/software.eessi.io/#infrastructure-status","title":"Infrastructure status","text":"<p>The status of the CernVM-FS infrastructure for the production repository is shown at https://status.eessi.io.</p>"},{"location":"site_specific_config/gpu/","title":"GPU support","text":"<p>More information on the actions that must be performed to ensure that GPU software included in EESSI can use the GPU in your system is available below.</p> <p>Please open a support issue if you need help or have questions regarding GPU support.</p> <p>Make sure the <code>${EESSI_VERSION}</code> version placeholder is defined!</p> <p>In this page, we use <code>${EESSI_VERSION}</code> as a placeholder for the version of the EESSI repository, for example: <pre><code>/cvmfs/software.eessi.io/versions/${EESSI_VERSION}\n</code></pre></p> <p>Before inspecting paths, or executing any of the specified commands, you should define <code>$EESSI_VERSION</code> first, for example with: <pre><code>export EESSI_VERSION=2023.06\n</code></pre></p>"},{"location":"site_specific_config/gpu/#nvidia","title":"Support for using NVIDIA GPUs","text":"<p>EESSI supports running CUDA-enabled software. All CUDA-enabled modules are marked with the <code>(gpu)</code> feature, which is visible in the output produced by <code>module avail</code>.</p>"},{"location":"site_specific_config/gpu/#nvidia_drivers","title":"NVIDIA GPU drivers","text":"<p>For CUDA-enabled software to run, it needs to be able to find the NVIDIA GPU drivers of the host system. The challenge here is that the NVIDIA GPU drivers are not always in a standard system location, and that we can not install the GPU drivers in EESSI (since they are too closely tied to the client OS and GPU hardware).</p>"},{"location":"site_specific_config/gpu/#cuda_sdk","title":"Compiling CUDA software","text":"<p>An additional requirement is necessary if you want to be able to compile CUDA-enabled software using a CUDA installation included in EESSI. This requires a full CUDA SDK, but the CUDA SDK End User License Agreement (EULA) does not allow for full redistribution. In EESSI, we are (currently) only allowed to redistribute the files needed to run CUDA software.</p> <p>Full CUDA SDK only needed to compile CUDA software</p> <p>Without a full CUDA SDK on the host system, you will still be able to run CUDA-enabled software from the EESSI stack, you just won't be able to compile additional CUDA software.</p> <p>Below, we describe how to make sure that the EESSI software stack can find your NVIDIA GPU drivers and (optionally) full installations of the CUDA SDK.</p>"},{"location":"site_specific_config/gpu/#driver_location","title":"Configuring CUDA driver location","text":"<p>All CUDA-enabled software in EESSI expects the CUDA drivers to be available in a specific subdirectory of this <code>host_injections</code> directory. In addition, installations of the CUDA SDK included EESSI are stripped down to the files that we are allowed to redistribute; all other files are replaced by symbolic links that point to another specific subdirectory of <code>host_injections</code>. For example: <pre><code>$ ls -l /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen3/software/CUDA/12.1.1/bin/nvcc\nlrwxrwxrwx 1 cvmfs cvmfs 109 Dec 21 14:49 /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen3/software/CUDA/12.1.1/bin/nvcc -&gt; /cvmfs/software.eessi.io/host_injections/2023.06/software/linux/x86_64/amd/zen3/software/CUDA/12.1.1/bin/nvcc\n</code></pre></p> <p>If the corresponding full installation of the CUDA SDK is available there, the CUDA installation included in EESSI can be used to build CUDA software.</p>"},{"location":"site_specific_config/gpu/#nvidia_eessi_native","title":"Using NVIDIA GPUs via a native EESSI installation","text":"<p>Here, we describe the steps to enable GPU support when you have a native EESSI installation on your system.</p> <p>Required permissions</p> <p>To enable GPU support for EESSI on your system, you will typically need to have system administration rights, since you need write permissions on the folder to the target directory of the <code>host_injections</code> symlink.</p>"},{"location":"site_specific_config/gpu/#exposing-nvidia-gpu-drivers","title":"Exposing NVIDIA GPU drivers","text":"<p>To install the symlinks to your GPU drivers in <code>host_injections</code>, run the <code>link_nvidia_host_libraries.sh</code> script that is included in EESSI:</p> <pre><code>/cvmfs/software.eessi.io/versions/${EESSI_VERSION}/scripts/gpu_support/nvidia/link_nvidia_host_libraries.sh\n</code></pre> <p>This script uses <code>ldconfig</code> on your host system to locate your GPU drivers, and creates symbolic links to them in the correct location under <code>host_injections</code> directory. It also stores the CUDA version supported by the driver that the symlinks were created for.</p> <p>Re-run <code>link_nvidia_host_libraries.sh</code> after NVIDIA GPU driver update</p> <p>You should re-run this script every time you update the NVIDIA GPU drivers on the host system.</p> <p>Note that it is safe to re-run the script even if no driver updates were done: the script should detect that the current version of the drivers were already symlinked.</p>"},{"location":"site_specific_config/gpu/#installing-full-cuda-sdk-optional","title":"Installing full CUDA SDK (optional)","text":"<p>To install a full CUDA SDK under <code>host_injections</code>, use the <code>install_cuda_host_injections.sh</code> script that is included in EESSI:</p> <pre><code>/cvmfs/software.eessi.io/versions/${EESSI_VERSION}/scripts/gpu_support/nvidia/install_cuda_host_injections.sh\n</code></pre> <p>For example, to install CUDA 12.1.1 in the directory that the <code>host_injections</code> variant symlink points to, using <code>/tmp/$USER/EESSI</code> as directory to store temporary files: <pre><code>/cvmfs/software.eessi.io/versions/${EESSI_VERSION}/scripts/gpu_support/nvidia/install_cuda_host_injections.sh --cuda-version 12.1.1 --temp-dir /tmp/$USER/EESSI --accept-cuda-eula\n</code></pre> You should choose the CUDA version you wish to install according to what CUDA versions are included in EESSI; see the output of <code>module avail CUDA/</code> after setting up your environment for using EESSI.</p> <p>You can run <code>/cvmfs/software.eessi.io/versions/${EESSI_VERSION}/scripts/gpu_support/nvidia/install_cuda_host_injections.sh --help</code> to check all of the options.</p> <p>Tip</p> <p>This script uses EasyBuild to install the CUDA SDK. For this to work, two requirements need to be satisfied:</p> <ul> <li><code>module load EasyBuild</code> should work (or the <code>eb</code> command is already available in the environment);</li> <li>The version of EasyBuild being used should provide the requested version of the CUDA easyconfig file   (in the example case above, that's <code>CUDA-12.1.1.eb</code>).</li> </ul> <p>You can rely on the EasyBuild installation that is included in EESSI for this.</p> <p>Alternatively, you may load an EasyBuild module manually before running the <code>install_cuda_host_injections.sh</code> script to make an <code>eb</code> command available.</p>"},{"location":"site_specific_config/gpu/#nvidia_eessi_container","title":"Using NVIDIA GPUs via EESSI in a container","text":"<p>We focus here on the Apptainer/Singularity use case, and have only tested the <code>--nv</code> option to enable access to GPUs from within the container.</p> <p>If you are using the EESSI container to access the EESSI software, the procedure for enabling GPU support is slightly different and will be documented here eventually.</p>"},{"location":"site_specific_config/gpu/#exposing-nvidia-gpu-drivers_1","title":"Exposing NVIDIA GPU drivers","text":"<p>When running a container with <code>apptainer</code> or <code>singularity</code> it is not necessary to run the <code>install_cuda_host_injections.sh</code> script since both these tools use <code>$LD_LIBRARY_PATH</code> internally in order to make the host GPU drivers available in the container.</p> <p>The only scenario where this would be required is if <code>$LD_LIBRARY_PATH</code> is modified or undefined.</p>"},{"location":"site_specific_config/gpu/#gpu_cuda_testing","title":"Testing the GPU support","text":"<p>The quickest way to test if software installations included in  EESSI can access and use your GPU is to run the <code>deviceQuery</code> executable that is part of the <code>CUDA-Samples</code> module: <pre><code>module load CUDA-Samples\ndeviceQuery\n</code></pre> If both are successful, you should see information about your GPU printed to your terminal.</p>"},{"location":"site_specific_config/host_injections/","title":"How to configure EESSI","text":""},{"location":"site_specific_config/host_injections/#why-configuration-is-necessary","title":"Why configuration is necessary","text":"<p>Just installing EESSI is enough to get started with the EESSI software stack on a CPU-based system. However, additional configuration is necessary in many other cases, such as - enabling GPU support on GPU-based systems - site-specific configuration / tuning of the MPI libraries provided by EESSI - overriding EESSI's MPI library with an ABI compatible host MPI</p>"},{"location":"site_specific_config/host_injections/#the-host_injections-variant-symlink","title":"The <code>host_injections</code> variant symlink","text":"<p>To allow such site-specific configuration, the EESSI repository includes a special directory where system administrations can install files that can be picked up by the software installations included in EESSI. This special directory is located in <code>/cvmfs/software.eessi.io/host_injections</code>, and it is a CernVM-FS Variant Symlink: a symbolic link for which the target can be controlled by the CernVM-FS client configuration (for more info, see 'Variant Symlinks' in the official CernVM-FS documentation).</p> <p>Default target for <code>host_injections</code> variant symlink</p> <p>Unless otherwise configured in the CernVM-FS client configuration for the EESSI repository, the <code>host_injections</code> symlink points to <code>/opt/eessi</code> on the client system: <pre><code>$ ls -l /cvmfs/software.eessi.io/host_injections\nlrwxrwxrwx 1 cvmfs cvmfs 10 Oct  3 13:51 /cvmfs/software.eessi.io/host_injections -&gt; /opt/eessi\n</code></pre></p> <p>The target for this symlink can be controlled by setting the <code>EESSI_HOST_INJECTIONS</code> variable in your local CVMFS configuration for EESSI. E.g. <pre><code>sudo bash -c \"echo 'EESSI_HOST_INJECTIONS=/shared_fs/path/to/host/injections/' &gt; /etc/cvmfs/domain.d/eessi.io.local\"\n</code></pre></p> <p>Don't forget to reload the CernVM-FS configuration</p> <p>After making a change to a CernVM-FS configuration file, you also need to reload the configuration: <pre><code>sudo cvmfs_config reload\n</code></pre></p> <p>On a heterogeneous system, you may want to use different targets for the variant symlink for different node types. For example, you might have two types of GPU nodes (<code>gpu1</code> and <code>gpu2</code>) for which the GPU drivers are not in the same location, or not of the same version. Since those are both things we configure under <code>host_injections</code>, you'll need separate <code>host_injections</code> directories for each node type. That can easily be achieved by putting e.g.</p> <pre><code>sudo bash -c \"echo 'EESSI_HOST_INJECTIONS=/shared_fs/path/to/host/injections/gpu1/' &gt; /etc/cvmfs/domain.d/eessi.io.local\"\n</code></pre> <p>in the CVMFS config on the <code>gpu1</code> nodes, and</p> <p><pre><code>sudo bash -c \"echo 'EESSI_HOST_INJECTIONS=/shared_fs/path/to/host/injections/gpu2/' &gt; /etc/cvmfs/domain.d/eessi.io.local\"\n</code></pre> in the CVMFS config on the <code>gpu2</code> nodes.</p>"},{"location":"site_specific_config/lmod_hooks/","title":"Configuring site-specific Lmod hooks","text":"<p>You may want to customize what happens when certain modules are loaded, for example, you may want to set additional environment variables. This is possible with LMOD hooks. A typical example would be when you want to tune the OpenMPI module for your system by setting additional environment variables when an OpenMPI module is loaded.</p>"},{"location":"site_specific_config/lmod_hooks/#location-of-the-hooks","title":"Location of the hooks","text":"<p>The EESSI software stack provides its own set of hooks in <code>$LMOD_PACKAGE_PATH/SitePackage.lua</code>. This <code>SitePackage.lua</code> also searches for site-specific hooks in two additional locations:</p> <ul> <li><code>$EESSI_CVMFS_REPO/host_injections/$EESSI_VERSION/.lmod/SitePackage.lua</code></li> <li><code>$EESSI_CVMFS_REPO/host_injections/$EESSI_VERSION/software/$EESSI_OS_TYPE/$EESSI_SOFTWARE_SUBDIR/.lmod/SitePackage.lua</code></li> </ul> <p>The first allows for hooks that need to be executed for that system, irrespective of the CPU architecture. The second allows for hooks specific to a certain architecture.</p>"},{"location":"site_specific_config/lmod_hooks/#architecture-independent-hooks","title":"Architecture-independent hooks","text":"<p>Hooks are written in Lua and can use any of the standard Lmod functionality as described in the Lmod documentation. While there are many types of hooks, you most likely want to specify a load or unload hook. Note that the EESSI hooks provide a nice example of what you can do with hooks. Here, as an example, we will define a <code>load</code> hook that environment variable <code>MY_ENV_VAR</code> to <code>1</code> whenever an <code>OpenMPI</code> module is loaded.</p> <p>First, you typically want to load the necessary Lua packages: <pre><code>-- $EESSI_CVMFS_REPO/host_injections/$EESSI_VERSION/.lmod/SitePackage.lua\n\n-- The Strict package checks for the use of undeclared variables:\nrequire(\"strict\")\n\n-- Load the Lmod Hook package\nlocal hook=require(\"Hook\")\n</code></pre></p> <p>Next, we define a function that we want to use as a hook. Unfortunately, registering multiple hooks of the same type (e.g. multiple <code>load</code> hooks) is only supported in Lmod 8.7.35+. EESSI version 2023.06 uses Lmod 8.7.30. Thus, we define our function without the local keyword, so that we can still add to it later in an architecture-specific hook (if we wanted to):</p> <pre><code>-- Define a function for the hook\n-- Note that we define this without 'local' keyword\n-- That way we can still add to this function in an architecture-specific hook\nfunction set_my_env_var_openmpi(t)\n    local simpleName = string.match(t.modFullName, \"(.-)/\")\n    if simpleName == 'OpenMPI' then\n        setenv('MY_ENV_VAR', '1')\n    end\nend\n</code></pre> <p>for the same reason that multiple hooks cannot be registered, we need to combine this function for our site-specific (architecture-independent) with the function that specifies the EESSI <code>load</code> hook. Note that all EESSI hooks will be called <code>eessi_&lt;hook_type&gt;_hook</code> by convention.</p> <pre><code>-- Registering multiple hook functions, e.g. multiple load hooks is only supported in Lmod 8.7.35+\n-- EESSI version 2023.06 uses lmod 8.7.30. Thus, we first have to combine all functions into a single one,\n-- before registering it as a hook\nlocal function combined_load_hook(t)\n    -- Call the EESSI load hook (if it exists)\n    -- Note that if you wanted to overwrite the EESSI hooks (not recommended!), you would omit this\n    if eessi_load_hook ~= nil then\n        eessi_load_hook(t)\n    end\n    -- Call the site-specific load hook\n    set_my_env_var_openmpi(t)\nend\n</code></pre> <p>Then, we can finally register this function as an Lmod hook:</p> <pre><code>hook.register(\"load\", combined_load_hook)\n</code></pre> <p>Thus, our complete <code>$EESSI_CVMFS_REPO/host_injections/$EESSI_VERSION/.lmod/SitePackage.lua</code> now looks like this (omitting the comments):</p> <pre><code>require(\"strict\")\nlocal hook=require(\"Hook\")\n\nfunction set_my_env_var_openmpi(t)\n    local simpleName = string.match(t.modFullName, \"(.-)/\")\n    if simpleName == 'OpenMPI' then\n        setenv('MY_ENV_VAR', '1')\n    end\nend\n\nlocal function combined_load_hook(t)\n    if eessi_load_hook ~= nil then\n        eessi_load_hook(t)\n    end\n    set_my_env_var_openmpi(t)\nend\n\nhook.register(\"load\", combined_load_hook)\n</code></pre> <p>Note that for future EESSI versions, if they use Lmod 8.7.35+, this would be simplified to:</p> <pre><code>require(\"strict\")\nlocal hook=require(\"Hook\")\n\nlocal function set_my_env_var_openmpi(t)\n    local simpleName = string.match(t.modFullName, \"(.-)/\")\n    if simpleName == 'OpenMPI' then\n        setenv('MY_ENV_VAR', '1')\n    end\nend\n\nhook.register(\"load\", set_my_env_var_openmpi, \"append\")\n</code></pre>"},{"location":"site_specific_config/lmod_hooks/#architecture-dependent-hooks","title":"Architecture-dependent hooks","text":"<p>Now, assume that in addition we want to set an environment variable <code>MY_SECOND_ENV_VAR</code> to <code>5</code>, but only for nodes that have the <code>zen3</code> architecture. First, again, you typically want to load the necessary Lua packages:</p> <pre><code>-- $EESSI_CVMFS_REPO/host_injections/$EESSI_VERSION/software/linux/x86_64/amd/zen3/.lmod/SitePackage.lua\n\n-- The Strict package checks for the use of undeclared variables:\nrequire(\"strict\")\n\n-- Load the Lmod Hook package\nlocal hook=require(\"Hook\")\n</code></pre> <p>Next, we define the function for the hook itself</p> <pre><code>-- Define a function for the hook\n-- This time, we can define it as a local function, as there are no hooks more specific than this \nlocal function set_my_second_env_var_openmpi(t)\n    local simpleName = string.match(t.modFullName, \"(.-)/\")\n    if simpleName == 'OpenMPI' then\n        setenv('MY_SECOND_ENV_VAR', '5')\n    end\nend\n</code></pre> <p>Then, we combine the functions into one</p> <pre><code>local function combined_load_hook(t)\n    -- Call the EESSI load hook first\n    if eessi_load_hook ~= nil then\n        eessi_load_hook(t)\n    end\n    -- Then call the architecture-independent load hook\n    if set_my_env_var_openmpi(t) ~= nil then\n        set_my_env_var_openmpi(t)\n    end\n    -- And finally the architecture-dependent load hook we just defined\n    set_my_second_env_var_openmpi(t)\nend\n</code></pre> <p>before finally registering it as an Lmod hook</p> <pre><code>hook.register(\"load\", combined_load_hook)\n</code></pre> <p>Thus, our full <code>$EESSI_CVMFS_REPO/host_injections/$EESSI_VERSION/software/linux/x86_64/amd/zen3/.lmod/SitePackage.lua</code> now looks like this (omitting the comments):</p> <pre><code>require(\"strict\")\nlocal hook=require(\"Hook\")\n\nlocal function set_my_second_env_var_openmpi(t)\n    local simpleName = string.match(t.modFullName, \"(.-)/\")\n    if simpleName == 'OpenMPI' then\n        setenv('MY_SECOND_ENV_VAR', '5')\n    end\nend\n\nlocal function combined_load_hook(t)\n    if eessi_load_hook ~= nil then\n        eessi_load_hook(t)\n    end\n    if set_my_env_var_openmpi(t) ~= nil then\n        set_my_env_var_openmpi(t)\n    end\n    set_my_second_env_var_openmpi(t)\nend\n\nhook.register(\"load\", combined_load_hook)\n</code></pre> <p>Again, note that for future EESSI versions, if they use Lmod 8.7.35+, this would simplify to</p> <pre><code>require(\"strict\")\nlocal hook=require(\"Hook\")\n\nlocal function set_my_second_env_var_openmpi(t)\n    local simpleName = string.match(t.modFullName, \"(.-)/\")\n    if simpleName == 'OpenMPI' then\n        setenv('MY_SECOND_ENV_VAR', '5')\n    end\nend\n\nhook.register(\"load\", set_my_second_var_openmpi, \"append\")\n</code></pre>"},{"location":"software_layer/build_nodes/","title":"Build nodes","text":"<p>Any system can be used as a build node to create additional software installations that should be added to the EESSI CernVM-FS repository.</p>"},{"location":"software_layer/build_nodes/#requirements","title":"Requirements","text":"<p>OS and software:</p> <ul> <li>GNU/Linux (any distribution) as operating system;</li> <li>a recent version of Singularity (&gt;= 3.6 is recommended);<ul> <li>check with <code>singularity --version</code></li> </ul> </li> <li><code>screen</code> or <code>tmux</code> is highly recommended;</li> </ul> <p>Admin privileges are not required, as long as Singularity is installed.</p> <p>Resources:</p> <ul> <li>8 or more cores is recommended (though not strictly required);</li> <li>at least 50GB of free space on a local filesystem (like <code>/tmp</code>);</li> <li>at least 16GB of memory (2GB/core or higher recommended);</li> </ul> <p>Instructions to install Singularity and screen (click to show commands):</p> CentOS 8 (<code>x86_64</code> or <code>aarch64</code> or <code>ppc64le</code>) <pre><code>sudo dnf install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm\nsudo dnf update -y\nsudo dnf install -y screen singularity\n</code></pre>"},{"location":"software_layer/build_nodes/#setting-up-the-container","title":"Setting up the container","text":"<p>Warning</p> <p>It is highly recommended to start a <code>screen</code> or <code>tmux</code> session first!</p> <p>A container image is provided that includes everything that is required to set up a writable overlay on top of the EESSI CernVM-FS repository.</p> <p>First, pick a location on a local filesystem for the temporary directory:</p> <p>Requirements:</p> <ul> <li>Do not use a shared filesystem like NFS, Lustre or GPFS.</li> <li>There should be at least 50GB of free disk space in this local filesystem (more is better).</li> <li>There should be no automatic cleanup of old files via a cron job on this local filesystem.</li> <li>Try to make sure the directory is unique (not used by anything else).</li> </ul> <p>NB. If you are going to install on a separate drive (due to lack of space on /), then you need to set some variables to  point to that location. You will also need to bind mount it in the <code>singularity</code> command. Let's say that you drive is  mounted in /srt. Then you change the relevant commands below to this: <pre><code>export EESSI_TMPDIR=/srt/$USER/EESSI\nmkdir -p $EESSI_TMPDIR\nmkdir /srt/tmp\nexport SINGULARITY_BIND=\"$EESSI_TMPDIR/var-run-cvmfs:/var/run/cvmfs,$EESSI_TMPDIR/var-lib-cvmfs:/var/lib/cvmfs,/srt/tmp:/tmp\"\nsingularity shell -B /srt --fusemount \"$EESSI_READONLY\" --fusemount \"$EESSI_WRITABLE_OVERLAY\" docker://ghcr.io/eessi/build-node:debian11\n</code></pre></p> <p>We will assume that <code>/tmp/$USER/EESSI</code> meets these requirements:</p> <pre><code>export EESSI_TMPDIR=/tmp/$USER/EESSI\nmkdir -p $EESSI_TMPDIR\n</code></pre> <p>Create some subdirectories in this temporary directory:</p> <pre><code>mkdir -p $EESSI_TMPDIR/{home,overlay-upper,overlay-work}\nmkdir -p $EESSI_TMPDIR/{var-lib-cvmfs,var-run-cvmfs}\n</code></pre> <p>Configure Singularity cache directory, bind mounts, and (fake) home directory:</p> <pre><code>export SINGULARITY_CACHEDIR=$EESSI_TMPDIR/singularity_cache\nexport SINGULARITY_BIND=\"$EESSI_TMPDIR/var-run-cvmfs:/var/run/cvmfs,$EESSI_TMPDIR/var-lib-cvmfs:/var/lib/cvmfs\"\nexport SINGULARITY_HOME=\"$EESSI_TMPDIR/home:/home/$USER\"\n</code></pre> <p>Define values to pass to <code>--fusemount` in</code>singularity`` command:</p> <pre><code>export EESSI_READONLY=\"container:cvmfs2 software.eessi.io /cvmfs_ro/software.eessi.io\"\nexport EESSI_WRITABLE_OVERLAY=\"container:fuse-overlayfs -o lowerdir=/cvmfs_ro/software.eessi.io -o upperdir=$EESSI_TMPDIR/overlay-upper -o workdir=$EESSI_TMPDIR/overlay-work /cvmfs/software.eessi.io\"\n</code></pre> <p>Start the container (which includes Debian 11, CernVM-FS and fuse-overlayfs):</p> <pre><code>singularity shell --fusemount \"$EESSI_READONLY\" --fusemount \"$EESSI_WRITABLE_OVERLAY\" docker://ghcr.io/eessi/build-node:debian10\n</code></pre> <p>Once the container image has been downloaded and converted to a Singularity image (SIF format), you should get a prompt like this:</p> <pre><code>...\nCernVM-FS: loading Fuse module... done\n\nSingularity&gt;\n</code></pre> <p>and the EESSI CernVM-FS repository should be mounted:</p> <pre><code>Singularity&gt; ls /cvmfs/software.eessi.io\nhost_injections  README.eessi  versions\n</code></pre>"},{"location":"software_layer/build_nodes/#setting-up-the-environment","title":"Setting up the environment","text":"<p>Set up the environment by starting a Gentoo Prefix session using the <code>startprefix</code> command.</p> <p>Make sure you use the correct version of the EESSI repository!</p> <pre><code>export EESSI_VERSION='2023.06' \n/cvmfs/software.eessi.io/versions/${EESSI_VERSION}/compat/linux/$(uname -m)/startprefix\n</code></pre>"},{"location":"software_layer/build_nodes/#installing-software","title":"Installing software","text":"<p>Clone the software-layer repository:</p> <pre><code>git clone https://github.com/EESSI/software-layer.git\n</code></pre> <p>Run the software installation script in <code>software-layer</code>:</p> <pre><code>cd software-layer\n./EESSI-install-software.sh\n</code></pre> <p>This script will figure out the CPU microarchitecture of the host automatically (like <code>x86_64/intel/haswell</code>).</p> <p>To build generic software installations (like <code>x86_64/generic</code>), use the <code>--generic</code> option:</p> <pre><code>./EESSI-install-software.sh --generic\n</code></pre> <p>Once all missing software has been installed, you should see a message like this:</p> <pre><code>No missing modules!\n</code></pre>"},{"location":"software_layer/build_nodes/#creating-tarball-to-ingest","title":"Creating tarball to ingest","text":"<p>Before tearing down the build node, you should create tarball to ingest into the EESSI CernVM-FS repository.</p> <p>To create a tarball of all installations, assuming your build host is <code>x86_64/intel/haswell</code>:</p> <pre><code>export EESSI_VERSION='2023.06'\ncd /cvmfs/software.eessi.io/versions/${EESSI_VERSION}/software/linux\neessi_tar_gz=\"$HOME/eessi-${EESSI_VERSION}-haswell.tar.gz\"\ntar cvfz ${eessi_tar_gz} x86_64/intel/haswell\n</code></pre> <p>To create a tarball for specific installations, make sure you pick up both the software installation directories and the corresponding module files:</p> <pre><code>eessi_tar_gz=\"$HOME/eessi-${EESSI_VERSION}-haswell-OpenFOAM.tar.gz\"\n\ntar cvfz ${eessi_tar_gz} x86_64/intel/haswell/software/OpenFOAM modules/all//OpenFOAM\n</code></pre> <p>This tarball should be uploaded to the Stratum 0 server for ingestion. If needed, you can ask for help in the EESSI <code>#software-layer</code> Slack channel</p>"},{"location":"software_layer/cpu_targets/","title":"CPU targets","text":"<p>In the 2023.06 version of the EESSI repository, the following CPU microarchitectures are supported.</p> <ul> <li><code>aarch64/generic</code>: fallback for Arm 64-bit CPUs (like Raspberri Pi, etc.)</li> <li><code>aarch64/neoverse_n1</code>: AWS Graviton 2, Ampere Altra, ...</li> <li><code>aarch64/neoverse_v1</code>: AWS Graviton 3</li> <li><code>aarch64/nvidia/grace</code>: NVIDIA Grace</li> <li><code>x86_64/generic</code>: fallback for older Intel + AMD CPUs (like Intel Sandy Bridge, ...)</li> <li><code>x86_64/amd/zen2</code>: AMD Rome</li> <li><code>x86_64/amd/zen3</code>: AMD Milan, Milan-X</li> <li><code>x86_64/amd/zen4</code>: AMD Genoa, Genoa-X, Bergamo, Siena</li> <li><code>x86_64/intel/haswell</code>: Intel Haswell, Broadwell</li> <li><code>x86_64/intel/skylake_avx512</code>: Intel Skylake, Cascade Lake, Ice Lake, Cooper Lake</li> <li><code>x86_64/intel/sapphirerapids</code>: Intel Sapphire Rapids, Emerald Rapids</li> </ul> <p>The names of these CPU targets correspond to the names used by archspec.</p>"},{"location":"talks/20230615_aws_tech_short/","title":"Making scientific software EESSI - and fast","text":"<p>AWS HPC Tech Short (~8 min.) - 15 June 2023</p>"},{"location":"talks/2023/20230615_aws_tech_short/","title":"Making scientific software EESSI - and fast","text":"<p>AWS HPC Tech Short (~8 min.) - 15 June 2023</p>"},{"location":"talks/2023/20231027_packagingcon23_eessi/","title":"Streaming optimized scientific software installations on any Linux distro with EESSI","text":"<ul> <li>PackagingCon'2023 (Berlin, Germany) - 27 Oct 2023</li> <li>presented by Kenneth Hoste &amp; Lara Peeters (HPC-UGent)</li> <li>slides (PDF)</li> </ul>"},{"location":"talks/2023/20231204_cvmfs_hpc/","title":"Best Practices for CernVM-FS in HPC","text":"<ul> <li>online tutorial (~3h15min), 4 Dec 2023</li> <li>presented by Kenneth Hoste (HPC-UGent)</li> <li>tutorial website: https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices</li> <li>slides (PDF)</li> </ul>"},{"location":"talks/2023/20231205_castiel2_eessi_intro/","title":"Streaming Optimised Scientific Software: an Introduction to EESSI","text":"<ul> <li>online tutorial (~1h40min) - 5 Dec 2023</li> <li>presented by Alan O'Cais (CECAM)</li> <li>slides (PDF)</li> </ul>"},{"location":"test-suite/","title":"EESSI test suite","text":"<p>The EESSI test suite is a collection of tests that are run using ReFrame. It is used to check whether the software installations included in the EESSI software layer are working and performing as expected.</p> <p>To get started, you should look into the installation and configuration guidelines first.</p> <p>To write the ReFrame configuration file for your system, check ReFrame configuration file.</p> <p>For which software tests are available, see available-tests.md.</p> <p>For more information on using the EESSI test suite, see here.</p> <p>See also release notes for the EESSI test suite.</p>"},{"location":"test-suite/ReFrame-configuration-file/","title":"ReFrame configuration file","text":"<p>In order for ReFrame to run tests on your system, it needs to know some properties about your system. For example, it needs to know what kind of job scheduler you have, which partitions the system has, how to submit to those partitions, etc. All of this has to be described in a ReFrame configuration file (see also the section on <code>$RFM_CONFIG_FILES</code>).</p> <p>This page is organized as follows:</p> <ul> <li>available ReFrame configuration files</li> <li>Verifying your ReFrame configuration</li> <li>How to write a ReFrame configuration file</li> </ul>"},{"location":"test-suite/ReFrame-configuration-file/#available-reframe-configuration-files","title":"Available ReFrame configuration files","text":"<p>There are some available ReFrame configuration files for HPC systems and public cloud in the config directory for more inspiration. Below is a simple ReFrame configuration file with minimal changes required for getting you started on using the test suite for a CPU partition. Please check that <code>stagedir</code> is set to a path on a (shared) scratch filesystem for storing (temporary) files related to the tests, and <code>access</code> is set to a list of arguments that you would normally pass to the scheduler when submitting to this partition (for example '-p cpu' for submitting to a Slurm partition called cpu).</p> <p>To write a ReFrame configuration file for your system, check the section How to write a ReFrame configuration file.</p> <pre><code>\"\"\"\nsimple ReFrame configuration file\n\"\"\"\nimport os\n\nfrom eessi.testsuite.common_config import common_logging_config, common_eessi_init, format_perfvars, perflog_format\nfrom eessi.testsuite.constants import *  \n\nsite_configuration = {\n    'systems': [\n        {\n            'name': 'cpu_partition',\n            'descr': 'CPU partition',\n            'modules_system': 'lmod',\n            'hostnames': ['*'],\n            # Note that the stagedir should be a shared directory available on all nodes running ReFrame tests\n            'stagedir': f'/some/shared/dir/{os.environ.get(\"USER\")}/reframe_output/staging',\n            'partitions': [\n                {\n                    'name': 'cpu_partition',\n                    'descr': 'CPU partition',\n                    'scheduler': 'slurm',\n                    'launcher': 'mpirun',\n                    'access':  ['-p cpu', '--export=None'],\n                    'prepare_cmds': ['source %s' % common_eessi_init()],\n                    'environs': ['default'],\n                    'max_jobs': 4,\n                    'resources': [\n                        {\n                            'name': 'memory',\n                            'options': ['--mem={size}'],\n                        }\n                    ],\n                    'features': [\n                        FEATURES.CPU\n                    ] + list(SCALES.keys()),\n                }\n            ]\n        },\n    ],\n    'environments': [\n        {\n            'name': 'default',\n            'cc': 'cc',\n            'cxx': '',\n            'ftn': '',\n        },\n    ],\n    'logging': common_logging_config(),\n    'general': [\n        {\n            # Enable automatic detection of CPU architecture for each partition\n            # See https://reframe-hpc.readthedocs.io/en/stable/configure.html#auto-detecting-processor-information\n            'remote_detect': True,\n        }\n    ],\n}\n\n# optional logging to syslog\nsite_configuration['logging'][0]['handlers_perflog'].append({\n    'type': 'syslog',\n    'address': '/dev/log',\n    'level': 'info',\n    'format': f'reframe: {perflog_format}',\n    'format_perfvars': format_perfvars,\n    'append': True,\n})\n</code></pre>"},{"location":"test-suite/ReFrame-configuration-file/#verifying-your-reframe-configuration","title":"Verifying your ReFrame configuration","text":"<p>To verify the ReFrame configuration, you can query the configuration using <code>--show-config</code>.</p> <p>To see the full configuration, use:</p> <pre><code>reframe --show-config\n</code></pre> <p>To only show the configuration of a particular system partition, you can use the <code>--system</code> option. To query a specific setting, you can pass an argument to <code>--show-config</code>.</p> <p>For example, to show the configuration of the <code>gpu</code> partition of the <code>example</code> system:</p> <pre><code>reframe --system example:gpu --show-config systems/0/partitions\n</code></pre> <p>You can drill it down further to only show the value of a particular configuration setting.</p> <p>For example, to only show the <code>launcher</code> value for the <code>gpu</code> partition of the <code>example</code> system:</p> <pre><code>reframe --system example:gpu --show-config systems/0/partitions/@gpu/launcher\n</code></pre>"},{"location":"test-suite/ReFrame-configuration-file/#write-reframe-config","title":"How to write a ReFrame configuration file","text":"<p>The official ReFrame documentation provides the full description on configuring ReFrame for your site. However, there are some configuration settings that are specifically required for the EESSI test suite. Also, there are a large amount of configuration settings available in ReFrame, which makes the official documentation potentially a bit overwhelming.</p> <p>Here, we will describe how to create a configuration file that works with the EESSI test suite, starting from an example configuration file <code>settings_example.py</code>, which defines the most common configuration settings.</p>"},{"location":"test-suite/ReFrame-configuration-file/#python-imports","title":"Python imports","text":"<p>The EESSI test suite standardizes a few string-based values as constants, as well as the logging format used by ReFrame. Every ReFrame configuration file used for running the EESSI test suite should therefore start with the following import statements:</p> <pre><code>from eessi.testsuite.common_config import common_logging_config, common_eessi_init\nfrom eessi.testsuite.constants import *\n</code></pre>"},{"location":"test-suite/ReFrame-configuration-file/#high-level-system-info-systems","title":"High-level system info (<code>systems</code>)","text":"<p>First, we describe the system at its highest level through the <code>systems</code> keyword.</p> <p>You can define multiple systems in a single configuration file (<code>systems</code> is a Python list value). We recommend defining just a single system in each configuration file, as it makes the configuration file a bit easier to digest (for humans).</p> <p>An example of the <code>systems</code> section of the configuration file would be:</p> <pre><code>site_configuration = {\n    'systems': [\n    # We could list multiple systems. Here, we just define one\n        {\n            'name': 'example',\n            'descr': 'Example cluster',\n            'modules_system': 'lmod',\n            'hostnames': ['*'],\n            'stagedir': f'/some/shared/dir/{os.environ.get(\"USER\")}/reframe_output/staging',\n            'partitions': [...],\n        }\n    ]\n}\n</code></pre> <p>The most common configuration items defined at this level are:</p> <ul> <li><code>name</code>:   The name of the system. Pick whatever makes sense for you.</li> <li><code>descr</code>:   Description of the system. Again, pick whatever you like.</li> <li><code>modules_system</code>:   The modules system used on your system. EESSI provides modules in <code>lmod</code> format. There is no need to change this,   unless you want to run tests from the EESSI test suite with non-EESSI modules.</li> <li><code>hostnames</code>:   The names of the hosts on which you will run the ReFrame command, as regular expression. Using these names,   ReFrame can automatically determine which of the listed configurations in the <code>systems</code> list to use, which is useful   if you're defining multiple systems in a single configuration file. If you follow our recommendation to limit   yourself to one system per configuration file, simply define <code>'hostnames': ['*']</code>.</li> <li><code>prefix</code>:   Prefix directory for a ReFrame run on this system. Any directories or files produced by ReFrame will use this prefix,   if not specified otherwise.   We recommend setting the <code>$RFM_PREFIX</code> environment variable rather than specifying <code>prefix</code> in   your configuration file, so our common logging configuration can pick up on it   (see also <code>$RFM_PREFIX</code>).</li> <li><code>stagedir</code>: A shared directory that is available on all nodes that will execute ReFrame tests. This is used for storing (temporary) files related to the test. Typically, you want to set this to a path on a (shared) scratch filesystem. Defining this is optional: the default is a '<code>stage</code>' directory inside the <code>prefix</code> directory.</li> <li><code>partitions</code>: Details on system partitions, see below.</li> </ul>"},{"location":"test-suite/ReFrame-configuration-file/#partitions","title":"System partitions (<code>systems.partitions</code>)","text":"<p>The next step is to add the system partitions to the configuration files, which is also specified as a Python list since a system can have multiple partitions.</p> <p>The <code>partitions</code> section of the configuration for a system with two Slurm partitions (one CPU partition, and one GPU partition) could for example look something like this:</p> <pre><code>site_configuration = {\n    'systems': [\n        {\n            ...\n            'partitions': [\n                {\n                    'name': 'cpu_partition',\n                    'descr': 'CPU partition'\n                    'scheduler': 'slurm',\n                    'prepare_cmds': ['source %s' % common_eessi_init()],\n                    'launcher': 'mpirun',\n                    'access':  ['-p cpu'],\n                    'environs': ['default'],\n                    'max_jobs': 4,\n                    'features': [\n                        FEATURES.CPU\n                    ] + list(SCALES.keys()),\n                },\n                {\n                    'name': 'gpu_partition',\n                    'descr': 'GPU partition'\n                    'scheduler': 'slurm',\n                    'prepare_cmds': ['source %s' % common_eessi_init()],\n                    'launcher': 'mpirun',\n                    'access':  ['-p gpu'],\n                    'environs': ['default'],\n                    'max_jobs': 4,\n                    'resources': [\n                        {\n                            'name': '_rfm_gpu',\n                            'options': ['--gpus-per-node={num_gpus_per_node}'],\n                        }\n                    ],\n                    'devices': [\n                        {\n                            'type': DEVICE_TYPES.GPU,\n                            'num_devices': 4,\n                        }\n                    ],\n                    'features': [\n                        FEATURES.CPU,\n                        FEATURES.GPU,\n                    ],\n                    'extras': {\n                        EXTRAS.GPU_VENDOR: GPU_VENDORS.NVIDIA,\n                    },\n                },\n            ]\n        }\n    ]\n}\n</code></pre> <p>The most common configuration items defined at this level are:</p> <ul> <li><code>name</code>:   The name of the partition. Pick anything you like.</li> <li><code>descr</code>:   Description of the partition. Again, pick whatever you like.</li> <li><code>scheduler</code>:   The scheduler used to submit to this partition, for example <code>slurm</code>. All valid options can be found   in the ReFrame documentation.</li> <li><code>launcher</code>:   The parallel launcher used on this partition, for example <code>mpirun</code> or <code>srun</code>. All valid options can be found   in the ReFrame documentation.</li> <li><code>access</code>:   A list of arguments that you would normally pass to the scheduler when submitting to this partition   (for example '<code>-p cpu</code>' for submitting to a Slurm partition called <code>cpu</code>).   If supported by your scheduler, we recommend to not export the submission environment   (for example by using '<code>--export=None</code>' with Slurm). This avoids test failures due to environment variables set   in the submission environment that are passed down to submitted jobs.</li> <li><code>prepare_cmds</code>:   Commands to execute at the start of every job that runs a test. If your batch scheduler does not export   the environment of the submit host, this is typically where you can initialize the EESSI environment.</li> <li><code>environs</code>:   The names of the programming environments (to be defined later in the configuration file via <code>environments</code>)   that may be used on this partition. A programming environment is required for tests that are compiled first,   before they can run. The EESSI test suite however only tests existing software installations, so no compilation   (or specific programming environment) is needed. Simply specify <code>'environs': ['default']</code>,   since ReFrame requires that a default environment is defined. </li> <li><code>max_jobs</code>:   The maximum amount of jobs ReFrame is allowed to submit in parallel. Some batch systems limit how many jobs users   are allowed to have in the queue. You can use this to make sure ReFrame doesn't exceed that limit.</li> <li><code>resources</code>:   This field defines how additional resources can be requested in a batch job. Specifically, on a GPU partition,   you have to define a resource with the name '<code>_rfm_gpu</code>'. The <code>options</code> field should then contain the argument to be   passed to the batch scheduler in order to request a certain number of GPUs per node, which could be different for   different batch schedulers. For example, when using Slurm you would specify:   <pre><code>'resources': [\n  {\n      'name': '_rfm_gpu',\n      'options': ['--gpus-per-node={num_gpus_per_node}'],\n  },\n],\n</code></pre></li> <li><code>processor</code>:   We recommend to NOT define this field, unless CPU autodetection is not working for you.   The EESSI test suite relies on information about your processor topology to run. Using CPU autodetection is the   easiest way to ensure that all processor-related information needed by the EESSI test suite are defined.   Only if CPU autodetection is failing for you do we advice you to set the <code>processor</code> in the partition configuration   as an alternative. Although additional fields might be used by future EESSI tests, at this point you'll have to   specify at least the following fields:   <pre><code>'processor': {\n    'num_cpus': 64,  # Total number of CPU cores in a node\n    'num_sockets': 2,  # Number of sockets in a node\n    'num_cpus_per_socket': 32,  # Number of CPU cores per socket\n    'num_cpus_per_core': 1,  # Number of hardware threads per CPU core\n}                 \n</code></pre></li> <li><code>features</code>:   The <code>features</code> field is used by the EESSI test suite to run tests only on a partition if it supports a certain   feature (for example if GPUs are available). Feature names are standardized in the EESSI test suite in   <code>eessi.testsuite.constants.FEATURES</code>   dictionary.   Typically, you want to define <code>features: [FEATURES.CPU] + list(SCALES.keys())</code> for CPU based partitions, and   <code>features: [FEATURES.GPU] + list(SCALES.keys())</code> for GPU based partitions. The first tells the EESSI test suite   that this partition can only run CPU-based tests, whereas second indicates that this partition can only run GPU-based   tests. You can define a single partition to have both the CPU and GPU features (since <code>features</code> is a Python list).   However, since the CPU-based tests will not ask your batch scheduler for GPU resources, this may fail on batch   systems that force you to ask for at least one GPU on GPU-based nodes. Also, running CPU-only code on a GPU node is   typically considered bad practice, thus testing its functionality is typically not relevant.   The <code>list(SCALES.keys())</code> adds all the scales that may be used by EESSI tests to the <code>features</code> list. These scales are   defined in   <code>eessi.testsuite.constants.SCALES</code>   and define at which scales tests should be run, e.g. single core, half a node, a full node, two nodes, etc. This   can be used to exclude running at certain scales on systems that would not support it. E.g. some systems might not   support requesting multiple partial nodes, which is what the <code>1cpn_2nodes</code> (1 core per node, on two nodes) and   <code>1cpn_4nodes</code> scales do. One could exclude these by setting e.g.   <code>features: [FEATURES.CPU] + [s for s in SCALES if s not in ['1cpn_2nodes', '1cpn_4nodes']]</code>. With this   configuration setting, ReFrame will run all the scales listed in `eessi.testsuite.constants.SCALES except   those two. In a similar way, one could exclude all multinode tests if one just has a single node available.</li> <li><code>devices</code>: This field specifies information on devices (for example) present in the partition. Device types are standardized in the EESSI test suite in the <code>eessi.testsuite.constants.DEVICE_TYPES</code> dictionary. This is used by the EESSI test suite to determine how many of these devices it can/should use per node.   Typically, there is no need to define <code>devices</code> for CPU partitions.   For GPU partitions, you want to define something like:   <pre><code>'devices': {\n    'type': DEVICE_TYPES.GPU,\n    'num_devices': 4,  # or however many GPUs you have per node\n}\n</code></pre></li> <li><code>extras</code>: This field specifies extra information on the partition, such as the GPU vendor. Valid fields for <code>extras</code> are standardized as constants in <code>eessi.testsuite.constants</code> (for example <code>EXTRAS.GPU_VENDOR</code>). This is used by the EESSI test suite to decide if a partition can run a test that specifically requires a certain brand of GPU.   Typically, there is no need to define <code>extras</code> for CPU partitions.   For GPU partitions, you typically want to specify the GPU vendor, for example:   <pre><code>'extras': {\n    EXTRAS.GPU_VENDOR: GPU_VENDORS.NVIDIA\n}\n</code></pre></li> </ul> <p>Note that as more tests are added to the EESSI test suite, the use of <code>features</code>, <code>devices</code> and <code>extras</code> by the EESSI test suite may be extended, which may require an update of your configuration file to define newly recognized fields.</p> <p>Note</p> <p>Keep in mind that ReFrame partitions are virtual entities: they may or may not correspond to a partition as it is configured in your batch system. One might for example have a single partition in the batch system, but configure it as two separate partitions in the ReFrame configuration file based on additional constraints that are passed to the scheduler, see for example the AWS CitC example configuration.</p> <p>The EESSI test suite (and more generally, ReFrame) assumes the hardware within a partition defined in the ReFrame configuration file is homogeneous.</p>"},{"location":"test-suite/ReFrame-configuration-file/#environments","title":"Environments","text":"<p>ReFrame needs a programming environment to be defined in its configuration file for tests that need to be compiled before they are run. While we don't have such tests in the EESSI test suite, ReFrame requires some programming environment to be defined:</p> <pre><code>site_configuration = {\n    ...\n    'environments': [\n        {\n            'name': 'default',  # Note: needs to match whatever we set for 'environs' in the partition\n            'cc': 'cc',\n            'cxx': '',\n            'ftn': '',\n        }\n    ]\n}\n</code></pre> <p>Note</p> <p>The <code>name</code> here needs to match whatever we specified for the <code>environs</code> property of the partitions.</p>"},{"location":"test-suite/ReFrame-configuration-file/#logging","title":"Logging","text":"<p>ReFrame allows a large degree of control over what gets logged, and where. For convenience, we have created a common logging configuration in <code>eessi.testsuite.common_config</code> that provides a reasonable default. It can be used by importing <code>common_logging_config</code> and calling it as a function to define the '<code>logging</code> setting: <pre><code>from eessi.testsuite.common_config import common_logging_config\n\nsite_configuration = {\n    ...\n    'logging':  common_logging_config(),\n}\n</code></pre> When combined by setting the <code>$RFM_PREFIX</code> environment variable, the output, performance log, and regular ReFrame logs will all end up in the directory specified by <code>$RFM_PREFIX</code>, which we recommend doing.</p> <p>Alternatively, a prefix can be passed as an argument like <code>common_logging_config(prefix)</code>, which will control where the regular ReFrame log ends up. Note that the performance logs do not respect this prefix: they will still end up in the standard ReFrame prefix (by default the current directory, unless otherwise set with <code>$RFM_PREFIX</code> or <code>--prefix</code>).</p>"},{"location":"test-suite/ReFrame-configuration-file/#cpu-auto-detection","title":"Auto-detection of processor information","text":"<p>You can let ReFrame auto-detect the processor information for your system.</p>"},{"location":"test-suite/ReFrame-configuration-file/#creation-of-topology-file-by-reframe","title":"Creation of topology file by ReFrame","text":"<p>ReFrame will automatically use auto-detection when two conditions are met:</p> <ol> <li>The <code>partitions</code> section of you configuration file does not specify <code>processor</code> information for a    particular partition (as per our recommendation in the previous section);</li> <li>The <code>remote_detect</code> option is enabled in the <code>general</code> part of the configuration, as follows:    <pre><code>site_configuration = {\n    'systems': ...\n    'logging': ...\n    'general': [\n        {\n            'remote_detect': True,\n        }\n    ]\n}\n</code></pre></li> </ol> <p>To trigger the auto-detection of processor information, it is sufficient to let ReFrame list the available tests:</p> <pre><code>reframe --list\n</code></pre> <p>ReFrame will store the processor information for your system in <code>~/.reframe/topology/&lt;system&gt;-&lt;partition&gt;/processor.json</code>.</p>"},{"location":"test-suite/ReFrame-configuration-file/#create-topology-file","title":"Create topology file","text":"<p>You can also use the reframe option <code>--detect-host-topology</code> to create the topology file yourself.</p> <p>Run the following command on the cluster of which you need the topology.</p> <pre><code>reframe --detect-host-topology[=FILE]\n</code></pre> <p>The output will be put in a file if this is specified or printed in the output. It will look something like this:</p> <pre><code>{\n  \"arch\": \"skylake_avx512\",\n  \"topology\": {\n    \"numa_nodes\": [\n      \"0x111111111\",\n      \"0x222222222\",\n      \"0x444444444\",\n      \"0x888888888\"\n    ],\n    \"sockets\": [\n      \"0x555555555\",\n      \"0xaaaaaaaaa\"\n    ],\n    \"cores\": [\n      \"0x000000001\",\n      \"0x000000002\",\n      \"0x000000004\",\n      \"0x000000008\",\n      \"0x000000010\",\n      \"0x000000020\",\n      \"0x000000040\",\n      \"0x000000080\",\n      \"0x000000100\",\n      \"0x000000200\",\n      \"0x000000400\",\n      \"0x000000800\",\n      \"0x000001000\",\n      \"0x000002000\",\n      \"0x000004000\",\n      \"0x000008000\",\n      \"0x000010000\",\n      \"0x000020000\",\n      \"0x000040000\",\n      \"0x000080000\",\n      \"0x000100000\",\n      \"0x000200000\",\n      \"0x000400000\",\n      \"0x000800000\",\n      \"0x001000000\",\n      \"0x002000000\",\n      \"0x004000000\",\n      \"0x008000000\",\n      \"0x010000000\",\n      \"0x020000000\",\n      \"0x040000000\",\n      \"0x080000000\",\n      \"0x100000000\",\n      \"0x200000000\",\n      \"0x400000000\",\n      \"0x800000000\"\n    ],\n    \"caches\": [\n      {\n        \"type\": \"L2\",\n        \"size\": 1048576,\n        \"linesize\": 64,\n        \"associativity\": 16,\n        \"num_cpus\": 1,\n        \"cpusets\": [\n          \"0x000000001\",\n          \"0x000000002\",\n          \"0x000000004\",\n          \"0x000000008\",\n          \"0x000000010\",\n          \"0x000000020\",\n          \"0x000000040\",\n          \"0x000000080\",\n          \"0x000000100\",\n          \"0x000000200\",\n          \"0x000000400\",\n          \"0x000000800\",\n          \"0x000001000\",\n          \"0x000002000\",\n          \"0x000004000\",\n          \"0x000008000\",\n          \"0x000010000\",\n          \"0x000020000\",\n          \"0x000040000\",\n          \"0x000080000\",\n          \"0x000100000\",\n          \"0x000200000\",\n          \"0x000400000\",\n          \"0x000800000\",\n          \"0x001000000\",\n          \"0x002000000\",\n          \"0x004000000\",\n          \"0x008000000\",\n          \"0x010000000\",\n          \"0x020000000\",\n          \"0x040000000\",\n          \"0x080000000\",\n          \"0x100000000\",\n          \"0x200000000\",\n          \"0x400000000\",\n          \"0x800000000\"\n        ]\n      },\n      {\n        \"type\": \"L1\",\n        \"size\": 32768,\n        \"linesize\": 64,\n        \"associativity\": 8,\n        \"num_cpus\": 1,\n        \"cpusets\": [\n          \"0x000000001\",\n          \"0x000000002\",\n          \"0x000000004\",\n          \"0x000000008\",\n          \"0x000000010\",\n          \"0x000000020\",\n          \"0x000000040\",\n          \"0x000000080\",\n          \"0x000000100\",\n          \"0x000000200\",\n          \"0x000000400\",\n          \"0x000000800\",\n          \"0x000001000\",\n          \"0x000002000\",\n          \"0x000004000\",\n          \"0x000008000\",\n          \"0x000010000\",\n          \"0x000020000\",\n          \"0x000040000\",\n          \"0x000080000\",\n          \"0x000100000\",\n          \"0x000200000\",\n          \"0x000400000\",\n          \"0x000800000\",\n          \"0x001000000\",\n          \"0x002000000\",\n          \"0x004000000\",\n          \"0x008000000\",\n          \"0x010000000\",\n          \"0x020000000\",\n          \"0x040000000\",\n          \"0x080000000\",\n          \"0x100000000\",\n          \"0x200000000\",\n          \"0x400000000\",\n          \"0x800000000\"\n        ]\n      },\n      {\n        \"type\": \"L3\",\n        \"size\": 25952256,\n        \"linesize\": 64,\n        \"associativity\": 11,\n        \"num_cpus\": 18,\n        \"cpusets\": [\n          \"0x555555555\",\n          \"0xaaaaaaaaa\"\n        ]\n      }\n    ]\n  },\n  \"num_cpus\": 36,\n  \"num_cpus_per_core\": 1,\n  \"num_cpus_per_socket\": 18,\n  \"num_sockets\": 2\n}\n</code></pre> <p>Note</p> <p>ReFrame 4.5.1 will generate more parameter than it can parse. To resolve this issue you can remove the following parameters: <code>vendor</code>, <code>model</code> and/or <code>platform</code>.</p> <p>For ReFrame to find the topology file it needs to be in the following path <code>~/.reframe/topology/&lt;system_name&gt;-&lt;partition_name&gt;/processor.json</code></p>"},{"location":"test-suite/available-tests/","title":"Available tests","text":"<p>For a complete overview of all available tests in the EESSI test suite, see the <code>eessi/testsuite/tests/apps</code> subdirectory in the <code>EESSI/test-suite</code> GitHub repository.</p>"},{"location":"test-suite/available-tests/#gromacs","title":"GROMACS","text":"<p>Several tests for GROMACS, a software package to perform molecular dynamics simulations, are included, which use the systems included in the HECBioSim benchmark suite:</p> <ul> <li><code>Crambin</code> (20K atom system)</li> <li><code>Glutamine-Binding-Protein</code> (61K atom system)</li> <li><code>hEGFRDimer</code> (465K atom system)</li> <li><code>hEGFRDimerSmallerPL</code> (465K atom system, only 10k steps)</li> <li><code>hEGFRDimerPair</code> (1.4M atom system)</li> <li><code>hEGFRtetramerPair</code> (3M atom system)</li> </ul> <p>It is implemented in <code>tests/apps/gromacs.py</code>, on top of the GROMACS test that is included in the ReFrame test library <code>hpctestlib</code>.</p> <p>To run this GROMACS test with all HECBioSim systems, use:</p> <pre><code>reframe --run --name GROMACS\n</code></pre> <p>To run this GROMACS test only for a specific HECBioSim system, use for example:</p> <pre><code>reframe --run --name 'GROMACS.*HECBioSim/hEGFRDimerPair'\n</code></pre> <p>To run this GROMACS test with the smallest HECBioSim system (<code>Crambin</code>), you can use the <code>CI</code> tag:</p> <pre><code>reframe --run --name GROMACS --tag CI\n</code></pre>"},{"location":"test-suite/available-tests/#tensorflow","title":"TensorFlow","text":"<p>A test for TensorFlow, a machine learning framework, is included, which is based on the \"Multi-worker training with Keras\" TensorFlow tutorial.</p> <p>It is implemented in <code>tests/apps/tensorflow/</code>.</p> <p>To run this TensorFlow test, use:</p> <pre><code>reframe --run --name TensorFlow\n</code></pre> <p>Warning</p> <p>This test requires TensorFlow v2.11 or newer, using an older TensorFlow version will not work!</p>"},{"location":"test-suite/available-tests/#osumicrobenchmarks","title":"OSU Micro-Benchmarks","text":"<p>A test for OSU Micro-Benchmarks, which provides an MPI benchmark. </p> <p>It is implemented in <code>tests/apps/osu.py</code>.</p> <p>To run this OSU Micro-Benchmark, use:</p> <pre><code>reframe --run --name OSU-Micro-Benchmarks\n</code></pre> <p>Warning</p> <p>This test requires OSU Micro-Benchmarks v5.9 or newer, using an older OSU -Micro-Benchmark version will not work!</p>"},{"location":"test-suite/available-tests/#espresso","title":"ESPResSo","text":"<p>A test for ESPResSo, a software package for performing and analysing scientific molecular dynamics simulations.</p> <p>It is implemented in <code>tests/apps/espresso/</code>.</p> <p>2 test cases are included: * P3M (ionic crystals) * LJ (Lennard Jones particle box)</p> <p>Both tests are weak scaling tests and therefore the number of particles are scaled based on the number of MPI ranks.</p> <p>To run this ESPResSo test, use:</p> <pre><code>reframe --run --name ESPResSo\n</code></pre>"},{"location":"test-suite/available-tests/#quantumespresso","title":"QuantumESPRESSO","text":"<p>A test for QuantumESPRESSO, an integrated suite of computer codes for electronic-structure calculations and materials modeling at the nanoscale. It is based on density-functional theory, plane waves, and pseudopotentials (both norm-conserving and ultrasoft).</p> <p>It is implemented in <code>tests/apps/QuantumESPRESSO.py</code>.</p> <p>To run this QuantumESPRESSO test, use:</p> <pre><code>reframe --run --name QuantumESPRESSO\n</code></pre> <p>Warning</p> <p>This test requires ReFrame v4.6.0 or newer, in older versions the QuantumESPRESSO test is not included in hpctestlib!</p>"},{"location":"test-suite/available-tests/#pytorch","title":"PyTorch","text":"<p>A test for PyTorch, a machine learning library based on the Torch library, used for applications such as computer vision and natural language processing, originally developed by Meta AI and now part of the Linux Foundation umbrella.</p> <p>This particular benchmark runs a selected torchvision model from the list: * VGG16 * Resnet50 * Resnet152 * Densenet121 * Mobilenet_v3_large on synthetic data. The test runs on both CPUs and GPUs (currently only supports CUDA).</p> <p>To run this PyTorch test, use:</p> <pre><code>reframe --run --name PyTorch\n</code></pre>"},{"location":"test-suite/available-tests/#cp2k","title":"CP2K","text":"<p>A test for CP2K, a quantum chemistry and solid state physics software package that can perform atomistic simulations of solid state, liquid, molecular, periodic, material, crystal, and biological systems.</p> <p>This particular benchmark runs a system with a selected number of H2O molecules and compares to a final reference energy once equillibrium is attained. Three systems are possible based on the number of water molecules: * 32 * 128 * 512</p> <p>To run this CP2K test, use:</p> <pre><code>reframe --run --name CP2K\n</code></pre>"},{"location":"test-suite/available-tests/#lammps","title":"LAMMPS","text":"<p>A test for LAMMPS, a classical molecular dynamics code with a focus on materials modeling. It's an acronym for Large-scale Atomic/Molecular Massively Parallel Simulator.</p> <p>This module tests the binary 'lmp' in available modules containing substring 'LAMMPS'. The tests come from the lammps github repository and test the LJ and Rhodo tests described here.</p> <p>To run this LAMMPS test, use:</p> <pre><code>reframe --run --name LAMMPS\n</code></pre>"},{"location":"test-suite/available-tests/#metalwalls","title":"MetalWalls","text":"<p>A test for MetalWalls, a molecular dynamics code dedicated to the modelling of electrochemical systems.</p> <p>The benchmarks consist of a set of different inputs files that vary in the number of atoms and the type of simulation performed. They can be found in the repository linked above, which is also versioned.</p> <p>To run this MetalWalls test, use:</p> <pre><code>reframe --run --name MetalWalls\n</code></pre>"},{"location":"test-suite/installation-configuration/","title":"Installing and configuring the EESSI test suite","text":"<p>This page covers the requirements, installation and configuration of the EESSI test suite.</p>"},{"location":"test-suite/installation-configuration/#requirements","title":"Requirements","text":"<p>The EESSI test suite requires </p> <ul> <li>Python &gt;= 3.7</li> <li>ReFrame v4.3.3 (or newer)</li> <li>ReFrame test library (<code>hpctestlib</code>)</li> </ul> <p>??? note \"(If your system Python version is lower than the minimum required version, click here for some tips)</p> <pre><code>* You can upgrade and manage python versions using `pyenv`. [Link](https://github.com/pyenv/pyenv?tab=readme-ov-file#installation)\n    * For installation follow the documentation in the repository using the link above.\n    * Then follow the steps to install a new Python version and further change local paths to the new Python:\n\n            pyenv install &lt;python version number&gt;\n            pyenv local &lt;python version number&gt;\n\n* You can install a more recent version of Python on top of the GCC/GCCcore compiler.\n* You can install a ReFrame module with EasyBuild and a [ReFrame easyconfig](https://github.com/easybuilders/easybuild-easyconfigs/tree/develop/easybuild/easyconfigs/r/ReFrame) containing a more recent Python version.\n* Set RFM_PURGE_ENVIRONMENT=1 if you use Python from a module. The ReFrame easyconfigs automatically do that for you.\n</code></pre>"},{"location":"test-suite/installation-configuration/#installing-reframe","title":"Installing Reframe","text":"<p>General instructions for installing ReFrame are available in the ReFrame documentation. To check if ReFrame is available, run the <code>reframe</code> command:</p> <pre><code>reframe --version\n</code></pre> (for more details on the ReFrame version requirement, click here) <p>Two important bugs were resolved in ReFrame's CPU autodetect functionality in version 4.3.3.</p> <p>We strongly recommend you use <code>ReFrame &gt;= 4.3.3</code>.</p> <p>If you are using an older version of ReFrame, you may encounter some issues:</p> <ul> <li>ReFrame will try to use the parallel launcher command configured for each partition (e.g. <code>mpirun</code>) when doing   the remote autodetect. If there is no system-version of <code>mpirun</code> available, that will fail   (see ReFrame issue #2926).</li> <li>CPU autodetection only worked when using a clone of the ReFrame repository, not when it was installed   with <code>pip</code> or <code>EasyBuild</code> (as is also the case for the ReFrame shipped with EESSI)   (see ReFrame issue #2914).</li> </ul>"},{"location":"test-suite/installation-configuration/#installing-reframe-test-library-hpctestlib","title":"Installing ReFrame test library (<code>hpctestlib</code>)","text":"<p>The EESSI test suite requires that the ReFrame test library (<code>hpctestlib</code>) is available, which is currently not included in a standard installation of ReFrame.</p> <p>We recommend installing ReFrame using EasyBuild (version 4.8.1, or newer), or using a ReFrame installation that is available in the EESSI repository (version 2023.06, or newer).</p> <p>For example (using EESSI):</p> <pre><code>source /cvmfs/software.eessi.io/versions/2023.06/init/bash\nmodule load ReFrame/4.3.3\n</code></pre> <p>To check whether the ReFrame test library is available, try importing a submodule of the <code>hpctestlib</code> Python package:</p> <pre><code>python3 -c 'import hpctestlib.sciapps.gromacs'\n</code></pre>"},{"location":"test-suite/installation-configuration/#installation","title":"Installation","text":"<p>To install the EESSI test suite, you can either use <code>pip</code> or clone the GitHub repository directly:</p>"},{"location":"test-suite/installation-configuration/#pip-install","title":"Using <code>pip</code>","text":"<pre><code>pip install git+https://github.com/EESSI/test-suite.git\n</code></pre>"},{"location":"test-suite/installation-configuration/#cloning-the-repository","title":"Cloning the repository","text":"<pre><code>git clone https://github.com/EESSI/test-suite $HOME/EESSI-test-suite\ncd EESSI-test-suite\nexport PYTHONPATH=$PWD:$PYTHONPATH\n</code></pre>"},{"location":"test-suite/installation-configuration/#verify-installation","title":"Verify installation","text":"<p>To check whether the EESSI test suite installed correctly, try importing the <code>eessi.testsuite</code> Python package:</p> <pre><code>python3 -c 'import eessi.testsuite'\n</code></pre>"},{"location":"test-suite/installation-configuration/#configuration","title":"Configuration","text":"<p>Before you can run the EESSI test suite, you need to create a configuration file for ReFrame that is specific to the system on which the tests will be run.</p> <p>Example configuration files are available in the <code>config</code> subdirectory of the <code>EESSI/test-suite</code> GitHub repository](https://github.com/EESSI/test-suite/tree/main/config), which you can use as a template to create your own.</p>"},{"location":"test-suite/installation-configuration/#configuring-reframe-environment-variables","title":"Configuring ReFrame environment variables","text":"<p>We recommend setting a couple of <code>$RFM_*</code> environment variables to configure ReFrame, to avoid needing to include particular options to the <code>reframe</code> command over and over again.</p>"},{"location":"test-suite/installation-configuration/#RFM_CONFIG_FILES","title":"ReFrame configuration file (<code>$RFM_CONFIG_FILES</code>)","text":"<p>(see also <code>RFM_CONFIG_FILES</code> in ReFrame docs)</p> <p>Define the <code>$RFM_CONFIG_FILES</code> environment variable to instruct ReFrame which configuration file to use, for example:</p> <pre><code>export RFM_CONFIG_FILES=$HOME/EESSI-test-suite/config/example.py\n</code></pre> <p>Alternatively, you can use the <code>--config-file</code> (or <code>-C</code>) <code>reframe</code> option.</p> <p>See the section on the ReFrame configuration file for more information.</p>"},{"location":"test-suite/installation-configuration/#search-path-for-tests-rfm_check_search_path","title":"Search path for tests (<code>$RFM_CHECK_SEARCH_PATH</code>)","text":"<p>(see also <code>RFM_CHECK_SEARCH_PATH</code> in ReFrame docs)</p> <p>Define the <code>$RFM_CHECK_SEARCH_PATH</code> environment variable to tell ReFrame which directory to search for tests.</p> <p>In addition, define <code>$RFM_CHECK_SEARCH_RECURSIVE</code> to ensure that ReFrame searches <code>$RFM_CHECK_SEARCH_PATH</code> recursively (i.e. so that also tests in subdirectories are found).</p> <p>For example:</p> <pre><code>export RFM_CHECK_SEARCH_PATH=$HOME/EESSI-test-suite/eessi/testsuite/tests\nexport RFM_CHECK_SEARCH_RECURSIVE=1\n</code></pre> <p>Alternatively, you can use the <code>--checkpath</code> (or <code>-c</code>) and <code>--recursive</code> (or <code>-R</code>) <code>reframe</code> options.</p>"},{"location":"test-suite/installation-configuration/#RFM_PREFIX","title":"ReFrame prefix (<code>$RFM_PREFIX</code>)","text":"<p>(see also <code>RFM_PREFIX</code> in ReFrame docs)</p> <p>Define the <code>$RFM_PREFIX</code> environment variable to tell ReFrame where to store the files it produces. E.g.</p> <pre><code>export RFM_PREFIX=$HOME/reframe_runs\n</code></pre> <p>This involves:</p> <ul> <li>test output directories (which contain e.g. the job script, stderr and stdout for each of the test jobs)</li> <li>staging directories (unless otherwise specified by <code>staging</code>, see below);</li> <li>performance logs;</li> </ul> <p>Note that the default is for ReFrame to use the current directory as prefix. We recommend setting a prefix so that logs are not scattered around and nicely appended for each run.</p> <p>If our common logging configuration is used, the regular ReFrame log file will also end up in the location specified by <code>$RFM_PREFIX</code>.</p> <p>Warning</p> <p>Using the <code>--prefix</code> option in your <code>reframe</code> command is not equivalent to setting <code>$RFM_PREFIX</code>, since our common logging configuration only picks up on the <code>$RFM_PREFIX</code> environment variable to determine the location for the ReFrame log file.</p>"},{"location":"test-suite/release-notes/","title":"Release notes for EESSI test suite","text":""},{"location":"test-suite/release-notes/#030-27-june-2024","title":"0.3.0 (27 june 2024)","text":"<p>This is a minor release of the EESSI test-suite</p> <p>It includes:</p> <ul> <li>Update config AWS MC cluster to use <code>software.eessi.io</code> (#126)</li> <li>Add test for QuantumESPRESSO (pw.x) (#128)</li> <li>Fix compact process binding for OpenMPI mpirun (#137)</li> <li>Use compact process binding for GROMACS (#139)</li> <li>Rename scale tags 1_cpn_2_nodes and 1_cpn_4_nodes (#140)</li> <li>Set SRUN_CPUS_PER_TASK for srun launcher (#141)</li> <li>Fix for \"Failed to modify UD QP to INIT on mlx5_0\" on Karolina CI runs (#142)</li> <li>Reduce the iteration count to make the OSU tests run faster, especially on slower interconnects (#143)</li> <li>Add test for ESPResSo (P3M) (#144)</li> <li>Use software.eessi.io repo in CI (#146)</li> <li>Add notes on release management to README (#148)</li> <li>Fix memory_per_node for Hortense (#151)</li> <li>Use MiB units for memory per node (#152)</li> <li>Added / updated memory for various systems in MiB units (#153)</li> <li>Add additional test for ESPRESSO (LJ) (#155)</li> <li>Bump default version used in CI (#157)</li> </ul>"},{"location":"test-suite/release-notes/#020-7-march-2024","title":"0.2.0 (7 march 2024)","text":"<p>This is a minor release of the EESSI test-suite</p> <p>It includes:</p> <ul> <li>Implement the CI for regular runs on a system (#93)</li> <li>Add OSU tests and update the hooks and configs to make the tests portable (#54, #95, #96, #97, #110, #116, #117, #118, #121)</li> <li>Add extra scales to filter tests(#94)</li> <li>add new hook to filter out invalid scales based on features in the config (#111)</li> <li>unify test names (#108)</li> <li>updates to CI workflow ((#102, #103, #104, #105)</li> <li>Update common_config (#114)</li> <li>Add common config item to redirect the report file to the same directory as e.g. the perflog (#122)</li> <li>Fix code formatting + enforce it in CI workflow  (#120)</li> </ul> <p>Bug fixes:</p> <ul> <li>Fix hook _assign_num_tasks_per_node (#98)</li> <li>fix import common-config vsc_hortense (#99)</li> <li>fix typo in partition names in configuration file for vsc_hortense (#106)</li> </ul>"},{"location":"test-suite/release-notes/#010-5-october-2023","title":"0.1.0 (5 October 2023)","text":"<p>Version 0.1.0 is the first release of the EESSI test suite.</p> <p>It includes:</p> <ul> <li>A well-structured <code>eessi.testsuite</code> Python package that provides constants,   utilities,   hooks,   and tests,   which can be installed with \"<code>pip install</code>\".</li> <li>Tests for GROMACS and TensorFlow in <code>eessi.testsuite.tests.apps</code>   that leverage the functionality provided by <code>eessi.testsuite.*</code>.</li> <li>Examples of ReFrame configuration files for various systems in   the <code>config</code> subdirectory.</li> <li>A <code>common_logging_config()</code> function to facilitate the ReFrame logging configuration.</li> <li>A set of standard device types and features that can be used in the <code>partitions</code> section of the ReFrame configuration file.</li> <li>A set of tags (<code>CI</code> + <code>scale</code>) that can be used to filter checks.</li> <li>Scripts that show how to run the test suite.</li> </ul>"},{"location":"test-suite/usage/","title":"Using the EESSI test suite","text":"<p>This page covers the usage of the EESSI test suite.</p> <p>We assume you have already installed and configured the EESSI test suite on your system.</p>"},{"location":"test-suite/usage/#listing-available-tests","title":"Listing available tests","text":"<p>To list the tests that are available in the EESSI test suite, use <code>reframe --list</code> (or <code>reframe -L</code> for short).</p> <p>If you have properly configured ReFrame, you should see a (potentially long) list of checks in the output:</p> <pre><code>$ reframe --list\n...\n[List of matched checks]\n- ...\nFound 123 check(s)\n</code></pre> <p>Note</p> <p>When using <code>--list</code>, checks are only generated based on modules that are available in the system where the <code>reframe</code> command is invoked.</p> <p>The system partitions specified in your ReFrame configuration file are not taken into account when using <code>--list</code>.</p> <p>So, if <code>--list</code> produces an overview of 50 checks, and you have 4 system partitions in your configuration file, actually running the test suite may result in (up to) 200 checks being executed.</p>"},{"location":"test-suite/usage/#dry-run","title":"Performing a dry run","text":"<p>To perform a dry run of the EESSI test suite, use <code>reframe --dry-run</code>:</p> <pre><code>$ reframe --dry-run\n...\n[==========] Running 1234 check(s)\n\n[----------] start processing checks\n[ DRY      ] GROMACS_EESSI ...\n...\n[----------] all spawned checks have finished\n\n[  PASSED  ] Ran 1234/1234 test case(s) from 1234 check(s) (0 failure(s), 0 skipped, 0 aborted)\n</code></pre> <p>Note</p> <p>When using <code>--dry-run</code>, the systems partitions listed in your ReFrame configuration file are also taken into account when generating checks, next to available modules and test parameters, which is not the case when using <code>--list</code>.</p>"},{"location":"test-suite/usage/#running-the-full-test-suite","title":"Running the (full) test suite","text":"<p>To actually run the (full) EESSI test suite and let ReFrame produce a performance report, use <code>reframe --run --performance-report</code>.</p> <p>We strongly recommend filtering the checks that will be run by using additional options like <code>--system</code>, <code>--name</code>, <code>--tag</code> (see the 'Filtering tests' section below), and doing a dry run first to make sure that the generated checks correspond to what you have in mind.</p>"},{"location":"test-suite/usage/#reframe-output-and-log-files","title":"ReFrame output and log files","text":"<p>ReFrame will generate various output and log files:</p> <ul> <li>a general ReFrame log file with debug logging on the ReFrame run (incl. selection of tests, generating checks,   test results, etc.);</li> <li>stage directories for each generated check, in which the checks are run;</li> <li>output directories for each generated check, which include the test output;</li> <li>performance log files for each test, which include performance results for the test runs;</li> </ul> <p>We strongly recommend controlling where these files go by using the common logging configuration that is provided by the EESSI test suite in your ReFrame configuration file and setting <code>$RFM_PREFIX</code> (avoid using the cmd line option <code>--prefix</code>).</p> <p>If you do, and if you use ReFrame v4.3.3 or more newer, you should find the output and log files at:</p> <ul> <li>general ReFrame log file at <code>$RFM_PREFIX/logs/reframe_&lt;datestamp&gt;_&lt;timestamp&gt;.log</code>;</li> <li>stage directories in <code>$RFM_PREFIX/stage/&lt;system&gt;/&lt;partition&gt;/&lt;environment&gt;/</code>;</li> <li>output directories in <code>$RFM_PREFIX/output/&lt;system&gt;/&lt;partition&gt;/&lt;environment&gt;/</code>;</li> <li>performance log files in <code>$RFM_PREFIX/perflogs/&lt;system&gt;/&lt;partition&gt;/&lt;environment&gt;/</code>;</li> </ul> <p>In the stage and output directories, there will be a subdirectory for each check that was run, which are tagged with a unique hash (like <code>d3adb33f</code>) that is determined based on the specific parameters for that check (see the ReFrame documentation for more details on the test naming scheme).</p>"},{"location":"test-suite/usage/#filtering-tests","title":"Filtering tests","text":"<p>By default, ReFrame will automatically generate checks for each system partition, based on the tests available in the EESSI test suite, available software modules, and tags defined in the EESSI test suite.</p> <p>To avoid being overwhelmed by checks, it is recommend to apply filters so ReFrame only generates the checks you are interested in.</p>"},{"location":"test-suite/usage/#filter-name","title":"Filtering by test name","text":"<p>You can filter checks based on the full test name using the <code>--name</code> option (or <code>-n</code>), which includes the value for all test parameters.</p> <p>Here's an example of a full test name:</p> <pre><code>GROMACS_EESSI %benchmark_info=HECBioSim/Crambin %nb_impl=cpu %scale=1_node %module_name=GROMACS/2023.1-foss-2022a /d3adb33f @example:gpu+default\n</code></pre> <p>To let ReFrame only generate checks for GROMACS, you can use:</p> <pre><code>reframe --name GROMACS\n</code></pre> <p>To only run GROMACS checks with a particular version of GROMACS, you can use <code>--name</code> to only retain specific <code>GROMACS</code> modules:</p> <pre><code>reframe --name %module_name=GROMACS/2023.1\n</code></pre> <p>Likewise, you can filter on any part of the test name.</p> <p>You can also select one specific check using the corresponding test hash, which is also part of the full test name (see <code>/d3adb33f</code> in the example above): for example:</p> <pre><code>reframe --name /d3adb33f\n</code></pre> <p>The argument passed to <code>--name</code> is interpreted as a Python regular expression, so you can use wildcards like <code>.*</code>, character ranges like <code>[0-9]</code>, use <code>^</code> to specify that the pattern should match from the start of the test name, etc.</p> <p>Use <code>--list</code> or <code>--dry-run</code> to check the impact of using the <code>--name</code> option.</p>"},{"location":"test-suite/usage/#filter-system-partition","title":"Filtering by system (partition)","text":"<p>By default, ReFrame will generate checks for each system partition that is listed in your configuration file.</p> <p>To only let ReFrame checks for a particular system or system partition, you can use the <code>--system</code> option.</p> <p>For example:</p> <ul> <li>To let ReFrame only generate checks for the system named <code>example</code>, use:   <pre><code>reframe --system example ...\n</code></pre></li> <li>To let ReFrame only generate checks for the <code>gpu</code> partition of the system named <code>example</code>, use:   <pre><code>reframe --system example:gpu ...\n</code></pre></li> </ul> <p>Use <code>--dry-run</code> to check the impact of using the <code>--system</code> option.</p>"},{"location":"test-suite/usage/#filter-tag","title":"Filtering by tags","text":"<p>To filter tests using one or more tags, you can use the <code>--tag</code> option.</p> <p>Using <code>--list-tags</code> you can get a list of known tags.</p> <p>To check the impact of this on generated checks by ReFrame, use <code>--list</code> or <code>--dry-run</code>.</p>"},{"location":"test-suite/usage/#ci-tag","title":"<code>CI</code> tag","text":"<p>For each software that is included in the EESSI test suite, a small test is tagged with <code>CI</code> to indicate it can be used in a Continuous Integration (CI) environment.</p> <p>Hence, you can use this tag to let ReFrame only generate checks for small test cases:</p> <pre><code>reframe --tag CI\n</code></pre> <p>For example:</p> <pre><code>$ reframe --name GROMACS --tag CI\n...\n</code></pre>"},{"location":"test-suite/usage/#scale-tags","title":"<code>scale</code> tags","text":"<p>The EESSI test suite defines a set of custom tags that control the scale of checks, which specify many cores/GPUs/nodes should be used for running a check. The number of cores and GPUs serves as an upper limit; the actual count depends on the specific configuration of cores, GPUs, and sockets within the node, as well as the specific test being carried out.</p> tag name description <code>1_core</code> using 1 CPU core 1 GPU <code>2_cores</code> using 2 CPU cores and 1 GPU <code>4_cores</code> using 4 CPU cores and 1 GPU <code>1cpn_2nodes</code> using 1 CPU core per node, 1 GPU per node, and 2 nodes <code>1cpn_4nodes</code> using 1 CPU core per node, 1 GPU per node, and 4 nodes <code>1_8_node</code> using 1/8th of a node (12.5% of available cores/GPUs, 1 at minimum) <code>1_4_node</code> using a quarter of a node (25% of available cores/GPUs, 1 at minimum) <code>1_2_node</code> using half of a node (50% of available cores/GPUs, 1 at minimum) <code>1_node</code> using a full node (all available cores/GPUs) <code>2_nodes</code> using 2 full nodes <code>4_nodes</code> using 4 full nodes <code>8_nodes</code> using 8 full nodes <code>16_nodes</code> using 16 full nodes"},{"location":"test-suite/usage/#using-multiple-tags","title":"Using multiple tags","text":"<p>To filter tests using multiple tags, you can:</p> <ul> <li>use <code>|</code> as separator to indicate that one of the specified tags must match (logical OR, for example <code>--tag='1_core|2_cores'</code>);</li> <li>use the <code>--tag</code> option multiple times to indicate that all specified tags must match (logical AND, for example <code>--tag CI --tag 1_core</code>);</li> </ul>"},{"location":"test-suite/usage/#example-commands","title":"Example commands","text":"<p>Running all GROMACS tests on 4 cores on the <code>cpu</code> partition</p> <pre><code>reframe --run --system example:cpu --name GROMACS --tag 4_cores --performance-report\n</code></pre> <p>List all checks for TensorFlow 2.11 using a single node</p> <pre><code>reframe --list --name %module_name=TensorFlow/2.11 --tag 1_node\n</code></pre> <p>Dry run of TensorFlow CI checks on a quarter (1/4) of a node (on all system partitions)</p> <pre><code>reframe --dry-run --name 'TensorFlow.*CUDA' --tag 1_4_node --tag CI\n</code></pre>"},{"location":"test-suite/usage/#overriding-test-parameters-advanced","title":"Overriding test parameters (advanced)","text":"<p>You can override test parameters using the <code>--setvar</code> option (or <code>-S</code>).</p> <p>This can be done either globally (for all tests), or only for specific tests (which is recommended when using <code>--setvar</code>).</p> <p>For example, to run all GROMACS checks with a specific GROMACS module, you can use:</p> <pre><code>reframe --setvar GROMACS_EESSI.modules=GROMACS/2023.1-foss-2022a ...\n</code></pre> <p>Warning</p> <p>We do not recommend using <code>--setvar</code>, since it is quite easy to make unintended changes to test parameters this way that can result in broken checks.</p> <p>You should try filtering tests using the <code>--name</code> or <code>--tag</code> options instead.</p>"},{"location":"test-suite/writing-portable-tests/","title":"Writing portable tests","text":"<p>This page is a tutorial on how to write a new test for the EESSI test suite.</p> <p>If you already know how to write regular ReFrame tests, we suggest you read the High-level overview and Test requirements sections, then skip ahead to Step 3: implementing as a portable ReFrame test.</p>"},{"location":"test-suite/writing-portable-tests/#high-level-overview","title":"High-level overview","text":"<p>In this tutorial, you will learn how to write a test for the EESSI test suite. It is important to realize in which context the test suite will be run. Roughly speaking, there are three uses:</p> <ul> <li>Running tests for one (or a few) particular applications, as part of the workflow of adding new software to EESSI,  to validate the sanity of the (new) installation</li> <li>Regular (e.g. daily) runs, on a set of HPC clusters, to identify performance regressions</li> <li>By an end-user of EESSI, who runs either a specific test or the full test suite, to validate the functionality of EESSI (or a particular software in EESSI) on the end-user's system</li> </ul> <p>The test suite contains a combination of real-life use cases for end-user scientific software (e.g. tests for GROMACS, TensorFlow, CP2K, OpenFOAM, etc) and low level tests (e.g. OSU Microbenchmarks).</p> <p>The tests in the EESSI test suite are developed using the ReFrame HPC testing framework. Typically, ReFrame tests hardcode system specific information (core counts, performance references, etc) in the test definition. The EESSI test suite aims to be portable, and implements a mixin class that invokes a series of standard hooks to replace information that is typically hardcoded. All system-specific information is then limited to the ReFrame configuration file. As an example: rather than hardcoding that a test should run with 128 tasks (i.e. because a system has 128 core nodes), the EESSI test suite has a hook that can define a test should be run on a \"single, full node\". The hook queries the ReFrame configuration file for the amount of cores per node, and specifies this number as the corresponding amount of tasks. Thus, on a 64-core node, this test would run with 64 tasks, while on a 128-core node, it would run 128 tasks.</p>"},{"location":"test-suite/writing-portable-tests/#test-requirements","title":"Test requirements","text":"<p>To be useful in the aforementioned scenarios, tests need to satisfy a number of requirements. </p> <ul> <li>Tests are implemented in the ReFrame HPC testing framework.</li> <li>Multiple tests may be implemented for a single software package.</li> <li>Tests should run in a reasonable amount of time (less than 1 hour) for all the scales for which it is defined to be valid (on a recent CPU/GPU).</li> <li>There should be at least one light-weight (short, low-core, low-memory) test case. On a decently sized machine (in 2024, that means about 8 cores and 16 GB memory), this test case should run in less than 5 minutes. This test should be marked with the 'CI' tag.</li> <li>Tests should only use a reasonable amount of memory, so that most systems will be able to run them. For low core counts (1-8 cores), 8-16 GB is reasonable. For higher core counts, keeping a memory usage to less than 1 GB/core will ensure that mosts systems will be able to run it.</li> <li>Tests should be portable, meaning they should not contain any system-specific information. If assumptions are made that might not be satisfied on every system (e.g. a test needs at least X cores to run), the test should check for it, and be skipped if the system does not satisfy the requirement.</li> </ul>"},{"location":"test-suite/writing-portable-tests/#step-by-step-tutorial-for-writing-a-portable-reframe-test","title":"Step-by-step tutorial for writing a portable ReFrame test","text":"<p>In the next section, we will show how to write a test for the EESSI test suite by means of an example: we will create a test for mpi4py that executes an <code>MPI_REDUCE</code> call to sum the ranks of all processes. If you're unfamiliar with MPI or <code>mpi4py</code>, or want to see the exact code this test will run, you may want to read Background of the mpi4py test before proceeding. The complete test developed in this tutorial can be found in the <code>tutorials/mpi4py</code> directory in  of the EESSI test suite repository.</p>"},{"location":"test-suite/writing-portable-tests/#step-1-writing-job-scripts-to-execute-tests","title":"Step 1: writing job scripts to execute tests","text":"<p>Although not strictly needed for the implementation of a ReFrame test, it is useful to try and write a job script for how you would want to run this test on a given system. For example, on a system with 128-core nodes, managed by SLURM, we might have the following job scripts to execute the <code>mpi4py_reduce.py</code> code.</p> <p>To run on 2 cores: <pre><code>#!/bin/bash\n#SBATCH --ntasks=2  # 2 tasks, since 2 processes is the minimal size on which I can do a reduction\n#SBATCH --cpus-per-task=1  # 1 core per task (this is a pure multiprocessing test, each process only uses 1 thread)\n#SBATCH --time=5:00  # This test is very fast. It shouldn't need more than 5 minutes\nsource /cvmfs/software.eessi.io/versions/2023.06/init/bash\nmodule load mpi4py/3.1.5-gompi-2023b\nmpirun -np 2 python3 mpi4py_reduce.py --n_iter 1000 --n_warmup 100\n</code></pre> To run on one full node: <pre><code>#!/bin/bash\n#SBATCH --ntasks=128  # min. 2 tasks in total, since 2 processes is the minimal size on which I can do a reduction\n#SBATCH --ntasks-per-node=128\n#SBATCH --cpus-per-task=1  # 1 core per task (this is a pure multiprocessing test, each process only uses 1 thread)\n#SBATCH --time=5:00  # This test is very fast. It shouldn't need more than 5 minutes\nsource /cvmfs/software.eessi.io/versions/2023.06/init/bash\nmodule load mpi4py/3.1.5-gompi-2023b\nmpirun -np 128 python3 mpi4py_reduce.py --n_iter 1000 --n_warmup 100\n</code></pre> To run on two full nodes <pre><code>#!/bin/bash\n#SBATCH --ntasks=256 # min. 2 tasks in total, since 2 processes is the minimal size on which I can do a reduction\n#SBATCH --ntasks-per-node=128 \n#SBATCH --cpus-per-task=1  # 1 core per task (this is a pure multiprocessing test, each process only uses 1 thread)\n#SBATCH --time=5:00  # This test is very fast. It shouldn't need more than 5 minutes\nsource /cvmfs/software.eessi.io/versions/2023.06/init/bash\nmodule load mpi4py/3.1.5-gompi-2023b\nmpirun -np 256 python3 mpi4py_reduce.py --n_iter 1000 --n_warmup 100\n</code></pre></p> <p>Clearly, such job scripts are not very portable: these only work on SLURM systems, we had to duplicate a lot to run on different scales, we would have to duplicate even more if we wanted to test multiple <code>mpi4py</code> versions, etc. This is where <code>ReFrame</code> comes in: it has support for different schedulers, and allows one to easily specify a range of parameters (such as the number of tasks in the above example) to create tests for.</p>"},{"location":"test-suite/writing-portable-tests/#step-2-implementing-as-a-non-portable-reframe-test","title":"Step 2: implementing as a non-portable ReFrame test","text":"<p>First, let us implement this as a non-portable test in ReFrame. This code can be found under <code>tutorials/mpi4py/mpi4py_system_specific.py</code> in the EESSI test suite repository. We will not elaborate on how to write ReFrame tests, it is well-documented in the official ReFrame documentation. We have put extensive comments in the test definition below, to make it easier to understand when you have limited familiarity with ReFrame. Whenever the variables below have a specific meaning in ReFrame, we referenced the official documentation:</p> <pre><code>\"\"\"\nThis module tests mpi4py's MPI_Reduce call\n\"\"\"\n\nimport reframe as rfm\nimport reframe.utility.sanity as sn\n\n# added only to make the linter happy\nfrom reframe.core.builtins import variable, parameter, run_after, performance_function, sanity_function\n\n\n# This python decorator indicates to ReFrame that this class defines a test\n# Our class inherits from rfm.RunOnlyRegressionTest, since this test does not have a compilation stage\n# https://reframe-hpc.readthedocs.io/en/stable/regression_test_api.html#reframe.core.pipeline.RunOnlyRegressionTest\n@rfm.simple_test\nclass EESSI_MPI4PY(rfm.RunOnlyRegressionTest):\n    # Programming environments are only relevant for tests that compile something\n    # Since we are testing existing modules, we typically don't compile anything and simply define\n    # 'default' as the valid programming environment\n    # https://reframe-hpc.readthedocs.io/en/stable/regression_test_api.html#reframe.core.pipeline.RegressionTest.valid_prog_environs\n    valid_prog_environs = ['default']\n\n    # Typically, we list here the name of our cluster as it is specified in our ReFrame configuration file\n    # https://reframe-hpc.readthedocs.io/en/stable/regression_test_api.html#reframe.core.pipeline.RegressionTest.valid_systems\n    valid_systems = ['snellius']\n\n    # ReFrame will generate a test for each module\n    # NOTE: each parameter adds a new dimension to the parametrization space. \n    # (EG 4 parameters with (3,3,2,2) possible values will result in 36 tests).\n    # Be mindful of how many parameters you add to avoid the number of tests generated being excessive.\n    # https://reframe-hpc.readthedocs.io/en/stable/regression_test_api.html#reframe.core.builtins.parameter\n    module_name = parameter(['mpi4py/3.1.4-gompi-2023a', 'mpi4py/3.1.5-gompi-2023b'])\n\n    # ReFrame will generate a test for each scale\n    scale = parameter([2, 128, 256])\n\n    # Our script has two arguments, --n_iter and --n_warmup. By defining these as ReFrame variables, we can\n    # enable the end-user to overwrite their value on the command line when invoking ReFrame.\n    # Note that we don't typically expose ALL variables, especially if a script has many - we expose\n    # only those that we think an end-user might want to overwrite\n    # Number of iterations to run (more iterations takes longer, but results in more accurate timing)\n    # https://reframe-hpc.readthedocs.io/en/stable/regression_test_api.html#reframe.core.builtins.variable\n    n_iterations = variable(int, value=1000)\n\n    # Similar for the number of warmup iterations\n    n_warmup = variable(int, value=100)\n\n    # Define which executable to run\n    # https://reframe-hpc.readthedocs.io/en/stable/regression_test_api.html#reframe.core.pipeline.RegressionTest.executable\n    executable = 'python3'\n\n    # Define which options to pass to the executable\n    # https://reframe-hpc.readthedocs.io/en/stable/regression_test_api.html#reframe.core.pipeline.RegressionTest.executable_opts\n    executable_opts = ['mpi4py_reduce.py', '--n_iter', f'{n_iterations}', '--n_warmup', f'{n_warmup}']\n\n    # Define a time limit for the scheduler running this test\n    # https://reframe-hpc.readthedocs.io/en/stable/regression_test_api.html#reframe.core.pipeline.RegressionTest.time_limit\n    time_limit = '5m00s'\n\n    # Using this decorator, we tell ReFrame to run this AFTER the init step of the test\n    # https://reframe-hpc.readthedocs.io/en/stable/regression_test_api.html#reframe.core.builtins.run_after\n    # See https://reframe-hpc.readthedocs.io/en/stable/pipeline.html for all steps in the pipeline\n    # that reframe uses to execute tests. Note that after the init step, ReFrame has generated test instances for each\n    # of the combinations of parameters above. Thus, now, there are 6 instances (2 module names * 3 scales). Here,\n    # we set the modules to load equal to one of the module names\n    # https://reframe-hpc.readthedocs.io/en/stable/regression_test_api.html#reframe.core.pipeline.RegressionTest.modules\n    @run_after('init')\n    def set_modules(self):\n        self.modules = [self.module_name]\n\n    # Similar for the scale, we now set the number of tasks equal to the scale for this instance\n    @run_after('init')\n    def define_task_count(self):\n        # Set the number of tasks, self.scale is now a single number out of the parameter list\n        # https://reframe-hpc.readthedocs.io/en/stable/regression_test_api.html#reframe.core.pipeline.RegressionTest.num_tasks\n        self.num_tasks = self.scale\n        # Set the number of tasks per node to either be equal to the number of tasks, but at most 128,\n        # since we have 128-core nodes\n        # https://reframe-hpc.readthedocs.io/en/stable/regression_test_api.html#reframe.core.pipeline.RegressionTest.num_tasks_per_node\n        self.num_tasks_per_node = min(self.num_tasks, 128)\n\n    # Now, we check if the pattern 'Sum of all ranks: X' with X the correct sum for the amount of ranks is found\n    # in the standard output:\n    # https://reframe-hpc.readthedocs.io/en/stable/regression_test_api.html#reframe.core.builtins.sanity_function\n    @sanity_function\n    def validate(self):\n        # Sum of 0, ..., N-1 is (N * (N-1) / 2)\n        sum_of_ranks = round(self.scale * ((self.scale - 1) / 2))\n        # https://reframe-hpc.readthedocs.io/en/stable/deferrable_functions_reference.html#reframe.utility.sanity.assert_found\n        return sn.assert_found(r'Sum of all ranks: %s' % sum_of_ranks, self.stdout)\n\n    # Now, we define a pattern to extract a number that reflects the performance of this test\n    # https://reframe-hpc.readthedocs.io/en/stable/regression_test_api.html#reframe.core.builtins.performance_function\n    @performance_function('s')\n    def time(self):\n        # https://reframe-hpc.readthedocs.io/en/stable/deferrable_functions_reference.html#reframe.utility.sanity.extractsingle\n        return sn.extractsingle(r'^Time elapsed:\\s+(?P&lt;perf&gt;\\S+)', self.stdout, 'perf', float)\n</code></pre> <p>This single test class will generate 6 test instances: tests with 2, 128 and 256 tasks for each of the two modules, respectively. It will check the sum of ranks produced at the end in the output, which is how ReFrame will validate that the test ran correctly. Finally, it will also print the performance number that was extracted by the <code>performance_function</code>.</p> <p>This test works, but is not very portable. If we move to a system with 192 cores per node, the current <code>scale</code> parameter is a bit awkward. The test would still run, but we wouldn't have a test instance that just tests this on a full (single) node or two full nodes. Furthermore, if we add a new <code>mpi4py</code> module in EESSI, we would have to alter the test to add the name to the list, since the module names are hardcoded in this test.</p>"},{"location":"test-suite/writing-portable-tests/#as-portable-reframe-test","title":"Step 3: implementing as a portable ReFrame test","text":"<p>In step 2, there were several system-specific items in the test. In this section, we will show how we use inheritance from the <code>EESSI_Mixin</code> class to avoid hard-coding system specific information. The full final test can be found under <code>tutorials/mpi4py/mpi4py_portable_mixin.py</code> in the EESSI test suite repository.</p>"},{"location":"test-suite/writing-portable-tests/#how-eessi_mixin-works","title":"How EESSI_Mixin works","text":"<p>The <code>EESSI_Mixin</code> class provides standardized functionality that should be useful to all tests in the EESSI test-suite. One of its key functions is to make sure tests dynamically try to determine sensible values for the things that were system specific in Step 2. For example, instead of hard coding a task count, the test inheriting from <code>EESSI_Mixin</code> will determine this dynamically based on the amount of available cores per node, and a declaration from the inheriting test class about how you want to instantiate tasks.</p> <p>To illustrate this, suppose you want to launch your test with one task per CPU core. In that case, your test (that inherits from <code>EESSI_Mixin</code>) only has to declare</p> <pre><code>compute_unit = COMPUTE_UNITS.CPU\n</code></pre> <p>The <code>EESSI_Mixin</code> class then takes care of querying the ReFrame config file for the cpu topology of the node, and setting the correct number of tasks per node.</p> <p>Another feature is that it sets defaults for a few items, such as the <code>valid_prog_environs = ['default']</code>. These will likely be the same for most tests in the EESSI test suite, and when they do need to be different, one can easily overwrite them in the child class.</p> <p>Most of the functionality in the <code>EESSI_Mixin</code> class require certain class attributes (such as the <code>compute_unit</code> above) to be set by the child class, so that the <code>EESSI_Mixin</code> class can use those as input. It is important that these attributes are set before the stage in which the <code>EESSI_Mixin</code> class needs them (see the stages of the ReFrame regression pipeline). To support test developers, the <code>EESSI_Mixin</code> class checks if these attributes are set, and gives verbose feedback in case any attributes are missing.</p>"},{"location":"test-suite/writing-portable-tests/#inheriting-from-eessi_mixin","title":"Inheriting from EESSI_Mixin","text":"<p>The first step is to actually inherit from the <code>EESSI_Mixin</code> class:</p> <pre><code>from eessi.testsuite.eessi_mixin import EESSI_Mixin\n...\n@rfm.simple_test\nclass EESSI_MPI4PY(rfm.RunOnlyRegressionTest, EESSI_Mixin):\n</code></pre>"},{"location":"test-suite/writing-portable-tests/#removing-hard-coded-test-scales","title":"Removing hard-coded test scales","text":"<p>First, we remove </p> <p><pre><code>    # ReFrame will generate a test for each scale\n    scale = parameter([2, 128, 256])\n</code></pre> from the test. The <code>EESSI_Mixin</code> class will define the default set of scales on which this test will be run as <pre><code>from eessi.testsuite.constants import SCALES\n...\n    scale = parameter(SCALES.keys())\n</code></pre></p> <p>This ensures the test will run a test case for each of the default scales, as defined by the <code>SCALES</code> constant.</p> <p>If, and only if, your test can not run on all of those scales should you overwrite this parameter in your child class. For example, if you have a test that does not support running on multiple nodes, you could define a filtering function outside of the class <pre><code>def filter_scales():\n    return [\n        k for (k,v) in SCALES.items()\n        if v['num_nodes'] == 1\n    ]\n</code></pre> and then in the class body overwrite the scale parameter with a subset of items from the <code>SCALES</code> constant: <pre><code>    scale = parameter(filter_scales())\n</code></pre></p> <p>Next, we also remove</p> <pre><code>   @run_after('init')\n    def define_task_count(self):\n        self.num_tasks = self.scale\n        self.num_tasks_per_node = min(self.num_tasks, 128)\n</code></pre> <p>as <code>num_tasks</code> and and <code>num_tasks_per_node</code> will be set by the <code>assign_tasks_per_compute_unit</code> hook, which is invoked by the <code>EESSI_Mixin</code> class.</p> <p>Instead, we only set the <code>compute_unit</code>. The number of launched tasks will be equal to the number of compute units. E.g. <pre><code>    compute_unit = COMPUTE_UNITS.CPU\n</code></pre> will launch one task per (physical) CPU core. Other options are <code>COMPUTE_UNITS.HWTHREAD</code> (one task per hardware thread), <code>COMPUTE_UNITS.NUMA_NODE</code> (one task per numa node), <code>COMPUTE_UNITS.CPU_SOCKET</code> (one task per CPU socket), <code>COMPUTE_UNITS.GPU</code> (one task per GPU) and <code>COMPUTE_UNITS.NODE</code> (one task per node). Check the <code>COMPUTE_UNITS</code> constant for the full list of valid compute units. The number of cores per task will automatically be set based on this as the ratio of the number of cores in a node to the number of tasks per node (rounded down). Additionally, the <code>EESSI_Mixin</code> class will set the <code>OMP_NUM_THREADS</code> environment variable equal to the number of cores per task.</p> <p>Note</p> <p><code>compute_unit</code> needs to be set before (or in) ReFrame's <code>setup</code> phase. For the different phases of the pipeline, please see the documentation on how ReFrame executes tests.</p>"},{"location":"test-suite/writing-portable-tests/#replacing-hard-coded-module-names","title":"Replacing hard-coded module names","text":"<p>Instead of hard-coding a module name, we parameterize over all module names that match a certain regular expression. </p> <pre><code>from eessi.testsuite.utils import find_modules\n...\n    module_name = parameter(find_modules('mpi4py'))\n</code></pre> <p>This parameter generates all module names available on the current system matching the expression, and each test instance will load the respective module before running the test.</p> <p>Furthermore, we remove the hook that sets <code>self.module</code>: <pre><code>@run_after('init')\ndef set_modules(self):\n    self.modules = [self.module_name]\n</code></pre> This is now taken care of by the <code>EESSI_Mixin</code> class.</p> <p>Note</p> <p><code>module_name</code> needs to be set before (or in) ReFrame's <code>init</code> phase</p>"},{"location":"test-suite/writing-portable-tests/#replacing-hard-coded-system-names-and-programming-environments","title":"Replacing hard-coded system names and programming environments","text":"<p>First, we remove the hard-coded system name and programming environment. I.e. we remove <pre><code>    valid_prog_environs = ['default']\n    valid_systems = ['snellius']\n</code></pre> The <code>EESSI_Mixin</code> class sets <code>valid_prog_environs = ['default']</code> by default, so that is no longer needed in the child class (but it can be overwritten if needed). The <code>valid_systems</code> is instead replaced by a declaration of what type of device type is needed. We'll create an <code>mpi4py</code> test that runs on CPUs only: <pre><code>    device_type = DEVICE_TYPES.CPU\n</code></pre> but note if we would have wanted to also generate test instances to test GPU &lt;=&gt; GPU communication, we could have defined this as a parameter: <pre><code>    device_type = parameter([DEVICE_TYPES.CPU, DEVICE_TYPES.GPU])\n</code></pre></p> <p>The device type that is set will be used by the <code>filter_valid_systems_by_device_type</code> hook to check in the ReFrame configuration file which of the current partitions contain the relevant device. Typically, we don't set the <code>DEVICE_TYPES.CPU</code> on a GPU partition in the ReFrame configuration, so that we skip all CPU-only tests on GPU nodes. Check the <code>DEVICE_TYPES</code> constant for the full list of valid compute units.</p> <p><code>EESSI_Mixin</code> also filters based on the supported scales, which can again be configured per partition in the ReFrame configuration file. This can e.g. be used to avoid running large-scale tests on partitions that don't have enough nodes to run them.</p> <p>Note</p> <p><code>device_type</code> needs to be set before (or in) ReFrame's <code>init</code> phase</p>"},{"location":"test-suite/writing-portable-tests/#requesting-sufficient-ram-memory","title":"Requesting sufficient RAM memory","text":"<p>To make sure you get an allocation with sufficient memory, your test should declare how much memory per node it needs by defining a <code>required_mem_per_node</code> function in your test class that returns the required memory per node (in MiB). Note that the amount of required memory generally depends on the amount of tasks that are launched per node (<code>self.num_tasks_per_node</code>).</p> <p>Our <code>mpi4py</code> test takes around 200 MB when running with a single task, plus about 70 MB for every additional task. We round this up a little so that we can be sure the test won't run out of memory if memory consumption is slightly different on a different system. Thus, we define:</p> <pre><code>def required_mem_per_node(self):\n    return self.num_tasks_per_node * 100 + 250\n</code></pre> <p>While rounding up is advisable, do keep your estimate realistic. Too high a memory request will mean the test will get skipped on systems that cannot satisfy that memory request. Most HPC systems have at least 1 GB per core, and most laptop/desktops have at least 8 GB total. Designing a test so that it fits within those memory constraints will ensure it can be run almost anywhere.</p> <p>Note</p> <p>The easiest way to get the memory consumption of your test at various task counts is to execute it on a system which runs jobs in cgroups, define <code>measure_memory_usage = True</code> in your class body, and make the <code>required_mem_per_node</code> function return a constant amount of memory equal to the available memory per node on your test system. This will cause the <code>EESSI_Mixin</code> class to read out the maximum memory usage of the cgroup (on the head node of your allocation, in case of multi-node tests) and report it as a performance number.</p>"},{"location":"test-suite/writing-portable-tests/#process-binding","title":"Process binding","text":"<p>The <code>EESSI_Mixin</code> class binds processes to their respective number of cores automatically using the <code>hooks.set_compact_process_binding</code> hook. E.g. for a pure MPI test like <code>mpi4py</code>, each task will be bound to a single core. For hybrid tests that do both multiprocessing and multithreading, tasks are bound to a sequential number of cores. E.g. on a node with 128 cores and a hybrid test with 64 tasks and 2 threads per task, the first task will be bound to core 0 and 1, second task to core 2 and 3, etc. To override this behaviour, one would have to overwrite the <pre><code>@run_after('setup')\ndef assign_tasks_per_compute_unit(self):\n    ...\n</code></pre> function. Note that this function also calls other hooks (such as <code>hooks.assign_task_per_compute_unit</code>) that you probably still want to invoke. Check the <code>EESSI_Mixin</code> class definition to see which hooks you still want to call.</p>"},{"location":"test-suite/writing-portable-tests/#ci-tag","title":"CI Tag","text":"<p>As mentioned in the Test requirements, there should be at least one light-weight (short, low-core, low-memory) test case, which should be marked with the <code>CI</code> tag. The <code>EESSI_Mixin</code> class will automatically add the <code>CI</code> tag if both <code>bench_name</code> (the current variant) and <code>bench_name_ci</code> (the CI variant) are defined. The <code>mpi4py</code> test contains only one test case (which is very light-weight). In this case, it is sufficient to set both to the same name in the class body: <pre><code>bench_name = 'mpi4pi'\nbench_name_ci = 'mpi4pi'\n</code></pre></p> <p>Suppose that our test has 2 variants, of which only <code>'variant1'</code> should be marked <code>CI</code>. In that case, we can define <code>bench_name</code> as a parameter: <pre><code>    bench_name = parameter(['variant1', 'variant2'])\n    bench_name_ci = 'variant1'\n</code></pre> Next, we can define a hook that does different things depending on the variant, for example:  <pre><code>@run_after('init')\ndef do_something(self):\n    if self.bench_name == 'variant1':\n        do_this()\n    elif self.bench_name == 'variant2':\n        do_that()\n</code></pre></p>"},{"location":"test-suite/writing-portable-tests/#readonly-files","title":"Readonly files","text":"<p>To avoid excessive copying of test input files into each stage directory, it is highly recommended to specify a list of files and/or dirs in <code>sourcesdir</code> that are needed but not modified during the test, and thus can be symlinked into the stage dirs. In this case, file <code>mpi4py_reduce.py</code> does not change during the test, so it can be safely symlinked: <pre><code>readonly_files = ['mpi4py_reduce.py']\n</code></pre> We\u2019ve made the <code>readonly_files</code> attribute mandatory for all tests to ensure it\u2019s not overlooked. If you are sure no files should be symlinked in your test, set it to <code>['']</code>: <pre><code>readonly_files = ['']\n</code></pre></p>"},{"location":"test-suite/writing-portable-tests/#thread-binding-optional","title":"Thread binding (optional)","text":"<p>Thread binding is not done by default, but can be done by invoking the <code>hooks.set_compact_thread_binding</code> hook: <pre><code>@run_after('setup')\ndef set_binding(self):\n    hooks.set_compact_thread_binding(self)\n</code></pre></p>"},{"location":"test-suite/writing-portable-tests/#skipping-test-instances","title":"Skipping test instances when required (optional)","text":"<p>Preferably, we prevent test instances from being generated (i.e. before ReFrame's <code>setup</code> phase) if we know that they cannot run on a certain system. However, sometimes we need information on the nodes that will run it, which is only available after the <code>setup</code> phase. That is the case for anything where we need information from e.g. the reframe.core.pipeline.RegressionTest.current_partition.</p> <p>For example, we might know that a test only scales to around 300 tasks, and above that, execution time increases rapidly. In that case, we'd want to skip any test instance that results in a larger amount of tasks, but we only know this after <code>assign_tasks_per_compute_unit</code> has been called (which is done by <code>EESSI_Mixin</code> in after the <code>setup</code> stage). For example, the <code>2_nodes</code> scale would run fine on systems with 128 cores per node, but would exceed the task limit of 300 on systems with <code>192</code> cores per node.</p> <p>We can skip any generated test cases using the <code>skip_if</code> function. For example, to skip the test if the total task count exceeds 300, we'd need to call <code>skip_if</code> after the <code>setup</code> stage (so that <code>self.num_tasks</code> is already set):</p> <pre><code>@run_after('setup')\n    hooks.assign_tasks_per_compute_unit(test=self, compute_unit=COMPUTE_UNITS.CPU)\n\n    max_tasks = 300\n    self.skip_if(self.num_tasks &gt; max_tasks,\n                 f'Skipping test: more than {max_tasks} tasks are requested ({self.num_tasks})')\n</code></pre> <p>The <code>mpi4py</code> test scales up to a very high core count, but if we were to set it for the sake of this example, one would see: <pre><code>[ RUN      ] EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=16_nodes /38aea144 @snellius:genoa+default\n[     SKIP ] ( 1/13) Skipping test: more than 300 tasks are requested (3072)\n[ RUN      ] EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=8_nodes /bfc4d3d4 @snellius:genoa+default\n[     SKIP ] ( 2/13) Skipping test: more than 300 tasks are requested (1536)\n[ RUN      ] EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=4_nodes /8de369bc @snellius:genoa+default\n[     SKIP ] ( 3/13) Skipping test: more than 300 tasks are requested (768)\n[ RUN      ] EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=2_nodes /364146ba @snellius:genoa+default\n[     SKIP ] ( 4/13) Skipping test: more than 300 tasks are requested (384)\n[ RUN      ] EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=1_node /8225edb3 @snellius:genoa+default\n[ RUN      ] EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=1_2_node /4acf483a @snellius:genoa+default\n[ RUN      ] EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=1_4_node /fc3d689b @snellius:genoa+default\n[ RUN      ] EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=1_8_node /73046a73 @snellius:genoa+default\n[ RUN      ] EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=1cpn_4nodes /f08712a2 @snellius:genoa+default\n[ RUN      ] EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=1cpn_2nodes /23cd550b @snellius:genoa+default\n[ RUN      ] EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=4_cores /bb8e1349 @snellius:genoa+default\n[ RUN      ] EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=2_cores /4c0c7c9e @snellius:genoa+default\n[ RUN      ] EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=1_core /aa83ba9e @snellius:genoa+default\n\n...\n</code></pre> on a system with 192 cores per node. I.e. any test of 2 nodes (384 cores) or above would be skipped because it exceeds our max task count.</p>"},{"location":"test-suite/writing-portable-tests/#setting-a-time-limit-optional","title":"Setting a time limit (optional)","text":"<p>By default, the <code>EESSI_Mixin</code> class sets a time limit for jobs of 1 hour. You can overwrite this in your child class: <pre><code>time_limit = '5m00s'\n</code></pre> For the appropriate string formatting, please check the ReFrame documentation on time_limit. We already had this in the non-portable version of our <code>mpi4py</code> test and will keep it in the portable version: since this is a very quick test, specifying a lower time limit will help in getting the jobs scheduled more quickly.</p> <p>Note that for the test to be portable, the time limit should be set such that it is sufficient regardless of node architecture and scale. It is pretty hard to guarantee this with a single, fixed time limit, without knowing upfront what architecture the test will be run on, and thus how many tasks will be launched. For strong scaling tests, you might want a higher time limit for low task counts, whereas for weak scaling tests you might want a higher time limit for higher task counts. To do so, you can consider setting the time limit after setup, and making it dependent on the task count.</p> <p>Suppose we have a weak scaling test that takes 5 minutes with a single task, and 60 minutes with 10k tasks. We can set a time limit based on linear interpolation between those task counts: <pre><code>@run_after('setup')\ndef set_time_limit(self):\n    # linearly interpolate between the single and 10k task count\n    minutes = 5 + self.num_tasks * ((60-5) / 10000)\n    self.time_limit = f'{minutes}m00s'\n</code></pre> Note that this is typically an overestimate of how long the test will take for intermediate task counts, but that's ok: we'd rather overestimate than underestimate the runtime.</p> <p>To be even safer, one could consider combining this with logic to skip tests if the 10k task count is exceeded.</p>"},{"location":"test-suite/writing-portable-tests/#summary","title":"Summary","text":"<p>To make the test portable, we added additional imports: <pre><code>from eessi.testsuite.eessi_mixin import EESSI_Mixin\nfrom eessi.testsuite.constants import COMPUTE_UNITS, DEVICE_TYPES\nfrom eessi.testsuite.utils import find_modules\n</code></pre></p> <p>Made sure the test inherits from <code>EESSI_Mixin</code>: <pre><code>@rfm.simple_test\nclass EESSI_MPI4PY(rfm.runOnlyRegressionTest, EESSI_Mixin):\n</code></pre></p> <p>Removed the following from the class body: <pre><code>valid_prog_environs = ['default']\nvalid_systems = ['snellius']\n\nmodule_name = parameter(['mpi4py/3.1.4-gompi-2023a', 'mpi4py/3.1.5-gompi-2023b'])\nscale = parameter([2, 128, 256])\n</code></pre></p> <p>Added the following to the class body: <pre><code>device_type = DEVICE_TYPES.CPU\ncompute_unit = COMPUTE_UNITS.CPU\n\nmodule_name = parameter(find_modules('mpi4py'))\n</code></pre></p> <p>Defined the class method: <pre><code>def required_mem_per_node(self):\n    return self.num_tasks_per_node * 100 + 250\n</code></pre></p> <p>Removed the ReFrame pipeline hook that sets <code>self.modules</code>: <pre><code>@run_after('init')\ndef set_modules(self):\n     self.modules = [self.module_name]\n</code></pre></p> <p>Removed the ReFrame pipeline hook that sets the number of tasks and number of tasks per node: <pre><code>@run_after('init')\ndef define_task_count(self):\n    # Set the number of tasks, self.scale is now a single number out of the parameter list\n    # https://reframe-hpc.readthedocs.io/en/stable/regression_test_api.html#reframe.core.pipeline.RegressionTest.num_tasks\n    self.num_tasks = self.scale\n    # Set the number of tasks per node to either be equal to the number of tasks, but at most 128,\n    # since we have 128-core nodes\n    # https://reframe-hpc.readthedocs.io/en/stable/regression_test_api.html#reframe.core.pipeline.RegressionTest.num_tasks_per_node\n    self.num_tasks_per_node = min(self.num_tasks, 128)\n</code></pre></p> <p>The final test is thus: <pre><code>\"\"\"\nThis module tests mpi4py's MPI_Reduce call\n\"\"\"\n\nimport reframe as rfm\nimport reframe.utility.sanity as sn\n\nfrom reframe.core.builtins import variable, parameter, run_after, performance_function, sanity_function\n\nfrom eessi.testsuite.eessi_mixin import EESSI_Mixin\nfrom eessi.testsuite.constants import COMPUTE_UNITS, DEVICE_TYPES\nfrom eessi.testsuite.utils import find_modules\n\n@rfm.simple_test\nclass EESSI_MPI4PY(rfm.RunOnlyRegressionTest, EESSI_Mixin):\n    device_type = DEVICE_TYPES.CPU\n    compute_unit = COMPUTE_UNITS.CPU\n\n    module_name = parameter(find_modules('mpi4py'))\n\n    n_iterations = variable(int, value=1000)\n    n_warmup = variable(int, value=100)\n\n    executable = 'python3'\n    executable_opts = ['mpi4py_reduce.py', '--n_iter', f'{n_iterations}', '--n_warmup', f'{n_warmup}']\n\n    time_limit = '5m00s'\n\n    bench_name = 'mpi4pi'\n    bench_name_ci = 'mpi4pi'\n\n    readonly_files = ['mpi4py_reduce.py']\n\n    def required_mem_per_node(self):\n        return self.num_tasks_per_node * 100 + 250\n\n    @sanity_function\n    def validate(self):\n        sum_of_ranks = round(self.num_tasks * ((self.num_tasks - 1) / 2))\n        return sn.assert_found(r'Sum of all ranks: %s' % sum_of_ranks, self.stdout)\n\n    @performance_function('s')\n    def time(self):\n        return sn.extractsingle(r'^Time elapsed:\\s+(?P&lt;perf&gt;\\S+)', self.stdout, 'perf', float)\n</code></pre></p> <p>Note that with only 44 lines of code, this is now very quick and easy to write, because of the default behaviour from the <code>EESSI_Mixin</code> class.</p>"},{"location":"test-suite/writing-portable-tests/#background-of-mpi4py-test","title":"Background of the mpi4py test","text":"<p>To understand what this test does, you need to know some basics of MPI. If you know about MPI, you can skip this section.</p> <p>The MPI standard defines how to communicate between multiple processes that work on a common computational task. Each process that is part of the computational task gets a unique identifier (0 to N-1 for N processes), the MPI rank, which can e.g. be used to distribute a workload. The MPI standard defines communication between two given processes (so-called point-to-point communication), but also between a set of N processes (so-called collective communication).</p> <p>An example of such a collective operation is the MPI_REDUCE call. It reduces data elements from multiple processes with a certain operation, e.g. it takes the sum of all elements or multiplication of all elements.</p>"},{"location":"test-suite/writing-portable-tests/#the-mpi4py-test","title":"The mpi4py test","text":"<p>In this example, we will implement a test that does an <code>MPI_Reduce</code> on the rank, using the <code>MPI.SUM</code> operation. This makes it easy to validate the result, as we know that for N processes, the theoretical sum of all ranks (0, 1, ... N-1) is <code>(N * (N-1) / 2)</code>.</p> <p>Our initial code is a python script <code>mpi4py_reduce.py</code>, which can be found in <code>tutorials/mpi4py/src/mpi4py_reduce.py</code> in the EESSI test suite repository: <pre><code>#!/usr/bin/env python\n\"\"\"\nMPI_Reduce on MPI rank. This should result in a total of (size * (size - 1) / 2),\nwhere size is the total number of ranks.\nPrints the total number of ranks, the sum of all ranks, and the time elapsed for the reduction.\"\n\"\"\"\n\nimport argparse\nimport time\n\nfrom mpi4py import MPI\n\nparser = argparse.ArgumentParser(description='mpi4py reduction benchmark',\n                                 formatter_class=argparse.ArgumentDefaultsHelpFormatter)\nparser.add_argument('--n_warmup', type=int, default=100,\n                    help='Number of warmup iterations')\nparser.add_argument('--n_iter', type=int, default=1000,\n                    help='Number of benchmark iterations')\nargs = parser.parse_args()\n\nn_warmup = args.n_warmup\nn_iter = args.n_iter\n\nsize = MPI.COMM_WORLD.Get_size()\nrank = MPI.COMM_WORLD.Get_rank()\nname = MPI.Get_processor_name()\n\n# Warmup\nt0 = time.time()\nfor i in range(n_warmup):\n    total = MPI.COMM_WORLD.reduce(rank, op=MPI.SUM)\n\n# Actual reduction, multiple iterations for accuracy of timing\nt1 = time.time()\nfor i in range(n_iter):\n    total = MPI.COMM_WORLD.reduce(rank, op=MPI.SUM)\nt2 = time.time()\ntotal_time = (t2 - t1) / n_iter\n\nif rank == 0:\n    print(f\"Total ranks: {size}\")\n    print(f\"Sum of all ranks: {total}\")  # Should be (size * (size-1) / 2)\n    print(f\"Time elapsed: {total_time:.3e}\")\n</code></pre></p> <p>Assuming we have <code>mpi4py</code> available, we could run this manually using <pre><code>$ mpirun -np 4 python3 mpi4py_reduce.py\nTotal ranks: 4\nSum of all ranks: 6\nTime elapsed: 3.609e-06\n</code></pre></p> <p>This started 4 processes, with ranks 0, 1, 2, 3, and then summed all the ranks (<code>0+1+2+3=6</code>) on the process with rank 0, which finally printed all this output. The whole reduction operation is performed <code>n_iter</code> times, so that we get a more reproducible timing.</p>"},{"location":"test-suite/writing-portable-tests/#as-portable-reframe-test-legacy","title":"Step 3: implementing as a portable ReFrame test without using EESSI_Mixin","text":"<p>The approach using inheritance from the <code>EESSI_Mixin</code> class, described above, is strongly preferred and recommended. There might be certain tests that do not fit the standardized approach of <code>EESSI_Mixin</code>, but usually that will be solvable by overwriting hooks set by <code>EESSI_Mixin</code> in the inheriting class. In the rare case that your test is so exotic that even this doesn't provide a sensible solution, you can still invoke the hooks used by <code>EESSI_Mixin</code> manually. Note that this used to be the default way of writing tests for the EESSI test suite.</p> <p>In step 2, there were several system-specific items in the test. In this section, we will show how we use the EESSI hooks to avoid hard-coding system specific information. We do this by replacing the system-specific parts of the test from Step 2 bit by bit. The full final test can be found under <code>tutorials/mpi4py/mpi4py_portable_legacy.py</code> in the EESSI test suite repository.</p>"},{"location":"test-suite/writing-portable-tests/#replacing-hard-coded-test-scales-mandatory","title":"Replacing hard-coded test scales (mandatory)","text":"<p>We replace the hard-coded</p> <pre><code>    # ReFrame will generate a test for each scale\n    scale = parameter([2, 128, 256])\n</code></pre> <p>by </p> <pre><code>from eessi.testsuite.constants import SCALES\n...\n    # ReFrame will generate a test for each scale\n    scale = parameter(SCALES.keys())\n</code></pre> <p>the <code>SCALES</code> constant contains a set of default scales at which we run all tests. For our <code>mpi4py</code> example, that is sufficient. </p> <p>Note</p> <p>It might be that particular tests do not make sense at certain scales. An example is code that only has multithreading, but no multiprocessing support, and is thus only able to run on a single node. In that case, we filter the set of <code>SCALES</code> down to only those where <code>num_nodes = 1</code>, and parameterize the test across those scales:</p> <pre><code>from eessi.testsuite.constants import SCALES\ndef get_singlenode_scales():\n    \"\"\"\n    Filtering function for single node tests\n    \"\"\"\n    return [\n        k for (k, v) in SCALES.items()\n        if v['num_nodes'] == 1\n    ]\n   ...\n   scale = parameter(get_singlenode_scales())\n</code></pre> <p>We also replace</p> <pre><code>    @run_after('init')\n    def define_task_count(self):\n        self.num_tasks = self.scale\n        self.num_tasks_per_node = min(self.num_tasks, 128)\n</code></pre> <p>by</p> <pre><code>from eessi.testsuite import hooks\nfrom eessi.testsuite.constants import SCALES, COMPUTE_UNITS\n    ...\n    @run_after('init')\n    def run_after_init(self):\n        hooks.set_tag_scale(self)\n\n    @run_after('setup')\n    def set_num_tasks_per_node(self):\n        \"\"\" Setting number of tasks per node and cpus per task in this function. This function sets num_cpus_per_task\n        for 1 node and 2 node options where the request is for full nodes.\"\"\"\n        hooks.assign_tasks_per_compute_unit(self, COMPUTE_UNITS.CPU)\n</code></pre> <p>The first hook (<code>set_tag_scale</code>) sets a number of custom attributes for the current test, based on the scale (<code>self.num_nodes</code>, <code>self.default_num_cpus_per_node</code>, <code>self.default_num_gpus_per_node</code>, <code>self.node_part</code>). These are not used by ReFrame, but can be used by later hooks from the EESSI test suite. It also sets a ReFrame scale <code>tag</code> for convenience. These scale <code>tag</code>s are useful for quick test selection, e.g. by running ReFrame with <code>--tag 1_node</code> one would only run the tests generated for the scale <code>1_node</code>. Calling this hook is mandatory for all tests, as it ensures standardization of tag names based on the scales.</p> <p>The second hook, <code>assign_tasks_per_compute_unit</code>, is used to set the task count. This hook sets the <code>self.num_tasks</code> and <code>self.num_tasks_per_node</code> we hardcoded before. In addition, it sets the <code>self.num_cpus_per_task</code>. In this case, we call it with the <code>COMPUTE_UNITS.CPU</code> argument, which means one task will be launched per (physical) CPU available. Thus, for the <code>1_node</code> scale, this would run the <code>mpi4py</code> test with 128 tasks on a 128-core node, and with 192 tasks on a 192-core node. Check the code for other valid <code>COMPUTE_UNITS</code>.</p>"},{"location":"test-suite/writing-portable-tests/#replacing-hard-coded-module-names-mandatory","title":"Replacing hard-coded module names (mandatory)","text":"<p>If we write an <code>mpi4py</code> test, we typically want to run this for all <code>mpi4py</code> modules that are available via our current <code>$MODULEPATH</code>. We do that by replacing</p> <pre><code>    module_name = parameter(['mpi4py/3.1.4-gompi-2023a', 'mpi4py/3.1.5-gompi-2023b'])\n</code></pre> <p>by using the <code>find_modules</code> utility function:</p> <pre><code>from eessi.testsuite.utils import find_modules\n...\n    module_name = parameter(find_modules('mpi4py'))\n</code></pre> <p>We also replace</p> <pre><code>    @run_after('init')\n    def set_modules(self):\n        self.modules = [self.module_name]\n</code></pre> <p>by</p> <pre><code>    @run_after('init')\n    def set_modules(self):\n        hooks.set_modules(self)\n</code></pre> <p>The <code>set_modules</code> hook assumes that <code>self.module_name</code> has been set, but has the added advantage that a user running the EESSI test suite can overwrite the modules to load from the command line when running ReFrame (see Overriding test parameters).</p>"},{"location":"test-suite/writing-portable-tests/#replacing-hard-coded-valid_systems-mandatory","title":"Replacing hard-coded valid_systems (mandatory)","text":"<p>The <code>valid_systems</code> attribute is a mandatory attribute to specify in a ReFrame test. However, we can set it to match any system:</p> <pre><code>valid_systems = [*]\n</code></pre> <p>Normally, <code>valid_systems</code> is used as a way of guaranteeing that a system has the necessary properties to run the test. For example, if we know that <code>my_gpu_system</code> has NVIDIA GPUs and I have a test written for NVIDIA GPUs, I would specify <code>valid_systems['my_gpu_system']</code> for that test. This, however, is a surrogate for declaring what my test needs: I'm saying it needs <code>my_gpu_system</code>, while in fact I could make the more general statement 'this test needs NVIDIA GPUs'.</p> <p>To keep the test system-agnostic we can declare what the test needs by using ReFrame's concept of partition <code>features</code> (a string) and/or <code>extras</code> (a key-value pair); see the ReFrame documentation on <code>valid_systems</code>. For example, a test could declare it needs the <code>gpu</code> feature. Such a test will only be created by ReFrame for partitions that declare (in the ReFrame configuration file) that they have the <code>gpu</code> feature.</p> <p>Since <code>features</code> and <code>extras</code> are full text fields, we standardize those in the EESSI test suite in the <code>eessi/testsuite/constants.py</code> file. For example, tests that require an NVIDIA GPU could specify</p> <pre><code>from eessi.testsuite.constants import EXTRAS, FEATURES, GPU_VENDORS\n...\nvalid_systems = f'+{FEATURES.GPU} %{EXTRAS.GPU_VENDOR}={GPU_VENDORS.NVIDIA}'\n</code></pre> <p>which makes sure that a test instance is only generated for partitions (as defined in the ReFrame configuration file) that specify that they have the corresponding feature and extras:</p> <pre><code>from eessi.testsuite.constants import EXTRAS, FEATURES, GPU_VENDORS\n...\n'features': [\n     FEATURES.GPU,\n],\n'extras': {\n    EXTRAS.GPU_VENDOR: GPU_VENDORS.NVIDIA,\n},\n</code></pre> <p>In practice, one will rarely hard-code this <code>valid_systems</code> string. Instead, we have a hook <code>filter_valid_systems_by_device_type</code>. It does the above, and a bit more: it also checks if the module that the test is generated for is CUDA-enabled (in case of a test for <code>NVIDIA</code> GPUs), and only then will it generate a GPU-based test. Calling this hook is mandatory for all tests (even if just to declare they need a CPU to run).</p> <p>Another aspect is that not all ReFrame partitions may be able to run tests of all of the standard <code>SCALES</code>. Each ReFrame partition must add the subset of <code>SCALES</code> it supports to its list of features.  A test case can declare it needs a certain scale. For example, a test case using the <code>16_nodes</code> scale needs a partition with at least 16 nodes. The <code>filter_supported_scales</code> hook then filters out all partitions that do not support running jobs on 16 nodes. Calling this hook is also mandatory for all tests.</p> <p>There may be other hooks that facilitate valid system selection for your tests, but please check the code for a full list.</p>"},{"location":"test-suite/writing-portable-tests/#requesting-sufficient-memory-mandatory","title":"Requesting sufficient memory (mandatory)","text":"<p>When developing the test, we don't know how much memory the node will have on which it will run. However, we do know how much our application needs.</p> <p>We can declare this need using the <code>req_memory_per_node</code> hook. This hook is mandatory for all tests. If you are on a system with a scheduler that runs jobs within a cgroup and where you can use <code>mpirun</code> or <code>srun</code> as the parallel launcher command in the ReFrame configuration, getting the memory consumption is easy. You can (temporarily) add a <code>postrun_cmds</code> the following to the class body of your test that extracts the maximum memory that was used within your cgroup. For cgroups v1, the syntax would be:</p> <pre><code>   # Temporarily define postrun_cmds to make it easy to find out memory usage\n    postrun_cmds = ['MAX_MEM_IN_BYTES=$(&lt;/sys/fs/cgroup/memory/$(&lt;/proc/self/cpuset)/../memory.max_usage_in_bytes)', 'echo \"MAX_MEM_IN_MIB=$(($MAX_MEM_IN_BYTES/1048576))\"']\n</code></pre> <p>For cgroups v2, the syntax would be:</p> <pre><code>   # Temporarily define postrun_cmds to make it easy to find out memory usage\n   postrun_cmds = ['MAX_MEM_IN_BYTES=$(&lt;/sys/fs/cgroup/$(&lt;/proc/self/cpuset)/../../../memory.peak)', 'echo \"MAX_MEM_IN_MIB=$(($MAX_MEM_IN_BYTES/1048576))\"']\n</code></pre> <p>And define an additional <code>performance_function</code>:</p> <pre><code>    @performance_function('MiB')\n    def max_mem_in_mib(self):\n        return sn.extractsingle(r'^MAX_MEM_IN_MIB=(?P&lt;perf&gt;\\S+)', self.stdout, 'perf', int)\n</code></pre> <p>This results in the following output on 192-core nodes (we've omitted some output for readability):</p> <pre><code>[----------] start processing checks\n[       OK ] ( 1/13) EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=16_nodes /38aea144 @snellius:genoa+default\nP: max_mem_in_mib: 22018 MiB (r:0, l:None, u:None)\n[       OK ] ( 2/13) EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=8_nodes /bfc4d3d4 @snellius:genoa+default\nP: max_mem_in_mib: 21845 MiB (r:0, l:None, u:None)\n[       OK ] ( 3/13) EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=4_nodes /8de369bc @snellius:genoa+default\nP: max_mem_in_mib: 21873 MiB (r:0, l:None, u:None)\n[       OK ] ( 4/13) EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=2_nodes /364146ba @snellius:genoa+default\nP: max_mem_in_mib: 21800 MiB (r:0, l:None, u:None)\n[       OK ] ( 5/13) EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=1_node /8225edb3 @snellius:genoa+default\nP: max_mem_in_mib: 21666 MiB (r:0, l:None, u:None)\n[       OK ] ( 6/13) EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=1_2_node /4acf483a @snellius:genoa+default\nP: max_mem_in_mib: 10768 MiB (r:0, l:None, u:None)\n[       OK ] ( 7/13) EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=1_4_node /fc3d689b @snellius:genoa+default\nP: max_mem_in_mib: 5363 MiB (r:0, l:None, u:None)\n[       OK ] ( 8/13) EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=1_8_node /73046a73 @snellius:genoa+default\nP: max_mem_in_mib: 2674 MiB (r:0, l:None, u:None)\n[       OK ] ( 9/13) EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=1cpn_4nodes /f08712a2 @snellius:genoa+default\nP: max_mem_in_mib: 210 MiB (r:0, l:None, u:None)\n[       OK ] (10/13) EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=1cpn_2nodes /23cd550b @snellius:genoa+default\nP: max_mem_in_mib: 209 MiB (r:0, l:None, u:None)\n[       OK ] (11/13) EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=4_cores /bb8e1349 @snellius:genoa+default\nP: max_mem_in_mib: 753 MiB (r:0, l:None, u:None)\n[       OK ] (12/13) EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=2_cores /4c0c7c9e @snellius:genoa+default\nP: max_mem_in_mib: 403 MiB (r:0, l:None, u:None)\n[       OK ] (13/13) EESSI_MPI4PY %module_name=mpi4py/3.1.5-gompi-2023b %scale=1_core /aa83ba9e @snellius:genoa+default\nP: max_mem_in_mib: 195 MiB (r:0, l:None, u:None)\n</code></pre> <p>If you are not on a system where your scheduler runs jobs in cgroups, you will have to figure out the memory consumption in another way (e.g. by checking memory usage in <code>top</code> while running the test).</p> <p>We now have a pretty good idea how the memory per node scales: for our smallest process count (1 core), it's about 200 MiB per process, while for our largest process count (16 nodes, 16*192 processes), it's 22018 MiB per node (or about 115 MiB per process). If we wanted to do really well, we could define a linear function (with offset) and fit it through the data (and round up to be on the safe side, i.e. make sure there is enough memory). Then, we could call the hook like this:</p> <pre><code>@run_after('setup')\ndef request_mem(self):\n    mem_required = self.num_tasks_per_node * mem_slope + mem_intercept\n    hooks.req_memory_per_node(self, app_mem_req=mem_required)\n</code></pre> <p>In this case, however, the memory consumption per process is low enough that we don't have go through that effort, and generously request 256 MiB per task that is launched on a node. Thus, we call our hook using:</p> <p><pre><code>@run_after('setup')\ndef request_mem(self):\n    mem_required = self.num_tasks_per_node * 256\n    hooks.req_memory_per_node(self, app_mem_req=mem_required)\n</code></pre> Note that requesting too high an amount of memory means the test will be skipped on nodes that cannot meet that requirement (even if they might have been able to run it without actually running out of memory). Requesting too little will risk nodes running out of memory while running the test. Note that many HPC systems have an amount memory of around 1-2 GB/core. It's good to ensure (if you can) that the memory requests for all valid <code>SCALES</code> for your test do not exceed the total amount of memory available on typical nodes.</p>"},{"location":"test-suite/writing-portable-tests/#requesting-taskprocessthread-binding-recommended","title":"Requesting task/process/thread binding (recommended)","text":"<p>Binding processes to a set of cores prevents the OS from migrating such processes to other cores. Especially on multi-socket systems, process migration can cause performance hits, especially if a process is moved to a CPU core on the other socket. Since this is controlled by the OS, and dependent on what other processes are running on the node, it may cause unpredictable performance: in some runs, processes might be migrated, while in others, they aren't.</p> <p>Thus, it is typically better for reproducibility to bind processes to their respective set of cores. The <code>set_compact_process_binding</code> hook can do this for you:</p> <pre><code>@run_after('setup')\ndef set_binding(self):\n    hooks.set_compact_process_binding(self)\n</code></pre> <p>For pure MPI codes, it will bind rank 0 to core 0, rank 1 to core 1, etc. For hybrid codes (MPI + OpenMP, or otherwise codes that do both multiprocessing and multithreading at the same time), it will bind to consecuitive sets of cores. E.g. if a single process uses 4 cores, it will bind rank 0 to cores 0-3, rank 1 to cores 4-7, etc. </p> <p>To impose this binding, the hook sets environment variables that should be respected by the parallel launcher used to launch your application. Check the code to see which parallel launchers are currently supported. The use of this hook is optional, but generally recommended for all multiprocessing codes.</p> <p>For multithreading codes, there <code>set_compact_thread_binding</code> hook is an equivalent hook that can do thread binding, if supported multithreading frameworks are used (e.g. Intel or GNU OpenMP, see the code for all supported frameworks):</p> <pre><code>@run_after('setup')\ndef set_binding(self):\n    hooks.set_compact_thread_binding(self)\n</code></pre> <p>The use of this hook is optional but recommended in most cases. Note that thread binding can sometimes cause unwanted behaviour: even if e.g. 8 cores are allocated to the process and 8 threads are launched, we have seen codes that bind all those threads to a single core (e.g. core 0) when core binding is enabled. Please verify that enabling core binding does not introduce any unwanted binding behaviour for your code.</p>"},{"location":"test-suite/writing-portable-tests/#defining-omp_num_threads-recommended","title":"Defining OMP_NUM_THREADS (recommended)","text":"<p>The <code>set_omp_num_threads</code> hook sets the <code>$OMP_NUM_THREADS</code> environment variable based on the number of <code>cpus_per_task</code> defined in the ReFrame test (which in turn is typically set by the <code>assign_tasks_per_compute_unit</code> hook). For OpenMP codes, it is generally recommended to call this hook, to ensure they launch the correct amount of threads.</p>"},{"location":"training/","title":"Trainings related to EESSI","text":""},{"location":"training/#2025","title":"2025","text":"<ul> <li>EESSI webinar series (May-June 2025) (online tutorials, 5/12/19/26 May &amp; 2 June)</li> </ul>"},{"location":"training/2025/webinar-series-2025Q2/","title":"EESSI webinar series (May-June 2025)","text":"<p>provided by EuroHPC CoE MultiXscale</p> <p>Tip</p> <p>Attending these sessions is free, but you must be registered to get an invitation to join the Zoom webinar sessions!</p> <p>See also Registration.</p> <p>What if you no longer have to install a broad range of scientific software from scratch on every laptop, HPC cluster, or cloud instance you use or maintain, without compromising on performance?</p> <p>The European Environment for Scientific Software Installations (EESSI, https://eessi.io) comes to the rescue!</p> <p>In this webinar series we will provide a comprehensive overview of EESSI: why we started it, how it works, how you can use it, ...</p> <p>You can register for the sessions listed below (either all of them, or selected ones).</p> <p>All sessions will be recorded. Recordings, slides, and materials used will be made publicly available shortly after each session via this page.</p> <p>In you have any questions regarding these webinars, please send an email to <code>support@eessi.io</code>.</p>"},{"location":"training/2025/webinar-series-2025Q2/#sessions","title":"Sessions","text":"<ul> <li>Monday 5 May 2025 (13:30-15:30 CEST): Introduction to EESSI (slides, recording)</li> <li>Monday 12 May 2025 (13:30-15:30 CEST): Introduction to CernVM-FS (slides, recording)</li> <li>Monday 19 May 2025 (13:30-15:30 CEST): Introduction to EasyBuild (incl. EasyBuild 5.0.0)</li> <li>Monday 26 May 2025 (13:30-15:30 CEST): EESSI for CI/CD</li> <li>Monday 2 June 2025 (13:30-15:30 CEST): Using EESSI as the base for a system stack</li> </ul> <p>YouTube playlist with recordings</p>"},{"location":"training/2025/webinar-series-2025Q2/#format","title":"Format","text":"<ul> <li>Online webinars (via Zoom)</li> <li>Mix of presentation &amp; hands-on demos: ~1.5h of content, ~30min for Q&amp;A</li> </ul>"},{"location":"training/2025/webinar-series-2025Q2/#registration","title":"Registration","text":"<p>Attendance is free of cost, but registration is required.</p> <p>Register via https://event.ugent.be/registration/eessi202505</p>"},{"location":"training/2025/webinar-series-2025Q2/#qa-via-slack","title":"Q&amp;A via Slack","text":"<p>For posting questions or comments during the webinar, we strongly prefer that you post them in the <code>#webinar-series-2025q2</code> channel in the EESSI Slack (direct link to that channel).</p> <p>If you haven't joined the EESSI Slack yet, first use the \"<code>Slack channel</code>\" link on the EESSI website (https://eessi.io).</p> <p>There will also be an opportunity at the end of the webinar to ask questions directly to the speakers, should you wish to do so.</p>"},{"location":"training/2025/webinar-series-2025Q2/#useful-links","title":"Useful links","text":"<ul> <li>EESSI website: https://eessi.io</li> <li>EESSI documentation: https://eessi.io/docs</li> <li>CernVM-FS website: https://cernvm.cern.ch/fs</li> <li>CernVM-FS documentation: https://cvmfs.readthedocs.io</li> <li>EasyBuild website: https://easybuild.io</li> <li>EasyBuild documentation: https://docs.easybuild.io</li> <li>MultiXscale website: https://www.multixscale.eu</li> </ul>"},{"location":"training/2025/webinar-series-2025Q2/#session-details","title":"Session details","text":""},{"location":"training/2025/webinar-series-2025Q2/#introduction-to-eessi","title":"Introduction to EESSI","text":"<ul> <li>Monday 5 May 2025, 13:30-15:30 CEST (Zoom webinar)</li> <li>speakers:<ul> <li>Richard Topuchain (University of Bergen)</li> <li>Helena Vela (Do IT Now)</li> </ul> </li> <li>moderators:<ul> <li>Thomas R\u00f6blitz (University of Bergen)</li> <li>Kenneth Hoste (Ghent University)</li> </ul> </li> </ul>"},{"location":"training/2025/webinar-series-2025Q2/#outline","title":"Outline","text":"<p>Discover how EESSI (European Environment for Scientific Software Installation) is transforming the way scientific software is deployed and shared across HPC systems, cloud platforms, and even laptops.</p> <p>In this session, we'll introduce the motivation behind EESSI, its architecture, and how you can start using a fully pre-built, modular software environment \u2014 no matter where you compute. Whether you're an HPC user, sysadmin, or developer, this webinar will show how EESSI can help you save time, improve reproducibility, and simplify your scientific workflows.</p>"},{"location":"training/2025/webinar-series-2025Q2/#materials","title":"Materials","text":"<ul> <li>slides (PDF)</li> <li>recording (YouTube)</li> </ul>"},{"location":"training/2025/webinar-series-2025Q2/#introduction-to-cernvm-fs","title":"Introduction to CernVM-FS","text":"<ul> <li>Monday 12 May 2025, 13:30-15:30 CEST (Zoom webinar)</li> <li>speakers:<ul> <li>Valentin Volkl (CERN)</li> <li>Kenneth Hoste (Ghent University)</li> </ul> </li> </ul>"},{"location":"training/2025/webinar-series-2025Q2/#outline_1","title":"Outline","text":"<p>CernVM-FS, the CernVM File System a.k.a. CVMFS (https://cernvm.cern.ch/fs), is a file distribution service that is particularly well suited to distribute software installations across a large number of systems world-wide in an efficient way.</p> <p>In this webinar, we will introduce you to CernVM-FS, show how to access existing CernVM-FS repositories (like EESSI, cover some aspects specific to using CernVM-FS on HPC systems.</p> <p>It is intended for people who are interested in CernVM-FS (system administrators, support team members, researchers, etc.), no specific prior knowledge or experience with it is required.</p>"},{"location":"training/2025/webinar-series-2025Q2/#materials_1","title":"Materials","text":"<ul> <li>slides (PDF)</li> <li>recording (YouTube)</li> </ul>"},{"location":"training/2025/webinar-series-2025Q2/#introduction-to-easybuild","title":"Introduction to EasyBuild","text":"<ul> <li>Monday 19 May 2025, 13:30-15:30 CEST</li> <li>speakers:<ul> <li>Kenneth Hoste (Ghent University)</li> </ul> </li> </ul>"},{"location":"training/2025/webinar-series-2025Q2/#outline_2","title":"Outline","text":"<p>EasyBuild (https://easybuild.io) is an open-source software installation tool written in Python that aims to support the various installation procedures used by the vast collection of software packages that are typically installed from source code in an HPC environment.</p> <p>In this webinar, we will introduce you to EasyBuild, show how to install and configure it, and present basic usage through hands-on demos. We will also cover some new capabilities that are supported by the recently released EasyBuild v5.0.0.</p>"},{"location":"training/2025/webinar-series-2025Q2/#materials_2","title":"Materials","text":"<ul> <li>slides (PDF)</li> <li>recording (YouTube)</li> </ul>"},{"location":"training/2025/webinar-series-2025Q2/#eessi-for-cicd","title":"EESSI for CI/CD","text":"<ul> <li>Monday 26 May 2025, 13:30-15:30 CEST</li> <li>speakers:<ul> <li>Alan O'Cais (CECAM, University of Barcelona)</li> </ul> </li> </ul>"},{"location":"training/2025/webinar-series-2025Q2/#outline_3","title":"Outline","text":"<p>(more info soon)</p>"},{"location":"training/2025/webinar-series-2025Q2/#using-eessi-as-the-base-for-a-system-stack","title":"Using EESSI as the base for a system stack","text":"<ul> <li>Monday 2 June 2025, 13:30-15:30 CEST</li> <li>speakers:<ul> <li>Bob Dr\u00f6ge (University of Groningen)</li> <li>Pedro Santos Neves (University of Groningen)</li> </ul> </li> </ul>"},{"location":"training/2025/webinar-series-2025Q2/#outline_4","title":"Outline","text":"<p>Despite being very open to community contributions, EESSI is unlikely to provide all the software you want to offer on your system as an HPC site. For instance, it will never be able to provide proprietary software due to license constraints.</p> <p>This session focuses on how you can use EESSI as the base for a system software stack, and easily build additional software on top and add it to your local software share. A recommended setup using CernVM-FS will be shown, but pointers for using any other (shared) filesystem will also be given. Finally, we will show how the EESSI build workflow (using a build bot and pull requests) can be adopted for your local software installations.</p> <p>This webinar is particularly intended for system administrators or support team members that maintain the central software stack for the users of their HPC infrastructure, but it can also be useful for end users who want to install additional software.</p> <p>Tip</p> <p>Attending these sessions is free, but you must be registered to get an invitation to join the Zoom webinar sessions!</p> <p>See also Registration.</p>"},{"location":"tutorial/","title":"Index","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/#best-practices-for-cernvm-fs-in-hpc","title":"Best Practices for CernVM-FS in HPC","text":"<p>This is an introductory tutorial to CernVM-FS, the CernVM File System, with a focus on employing it in the context of High-Performance Computing (HPC).</p> <p>In this tutorial you will learn what CernVM-FS is, how to get access to existing CernVM-FS repositories, how to configure CernVM-FS, and how to use CernVM-FS repositories on HPC infrastructure.</p> <p>Ready to go? Click here to start the tutorial!</p>"},{"location":"tutorial/#contents","title":"Contents","text":"<ul> <li>Home</li> <li>Introduction to CernVM-FS:<ul> <li>What is CernVM-FS?</li> <li>Technical details</li> <li>Flagship repositories</li> </ul> </li> <li>EESSI<ul> <li>What is EESSI?</li> <li>Motivation &amp; goals</li> <li>Inspiration</li> <li>High-level design</li> <li>Using EESSI</li> <li>Getting support</li> </ul> </li> <li>Accessing repositories<ul> <li>CernVM-FS client system</li> <li>Squid proxy server</li> <li>Private Stratum 1 replica server</li> <li>Alternative access methods</li> </ul> </li> <li>Configuration on HPC systems</li> <li>Troubleshooting</li> <li>Monitoring CernVM-FS</li> <li>Performance aspects</li> <li>Containers</li> <li>Creating a CernVM-FS repository</li> <li>Appendix: Terminology</li> </ul>"},{"location":"tutorial/#recording","title":"Recording","text":"<p>A first virtual edition of this tutorial was held on 4 December 2023, the recording is available here:</p> <p> slides (PDF) available for download here </p>"},{"location":"tutorial/#slides","title":"Slides","text":"<p>Available for download here</p>"},{"location":"tutorial/#intended-audience","title":"Intended audience","text":"<p>This tutorial is intended for people with a background in HPC (system administrators, support team members, end users, etc.) and who are new to CernVM-FS; no specific prior knowledge or experience with it is required.</p> <p>We expect it to be most valuable to people who are interested in using or providing access to one or more existing CernVM-FS repositories on HPC infrastructure.</p>"},{"location":"tutorial/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic knowledge of Linux shell environment</li> <li>Basic knowledge of networking (IP address, port, latency)</li> <li>Basic knowledge of Linux file systems</li> <li>Familiarity with High-Performance Computing environments is a plus</li> <li>Hands-on experience with running scientific software workloads is a plus</li> </ul>"},{"location":"tutorial/#practical-information","title":"Practical information","text":""},{"location":"tutorial/#registration","title":"Registration","text":"<p>Attendance is free, but registration is required: https://event.ugent.be/registration/cvmfshpc202312.</p> <p>Registration for online tutorial on Mon 4 Dec 2023 is closed (since Sun 3 Dec 2023)</p>"},{"location":"tutorial/#slack-channel","title":"Slack channel","text":"<p>Dedicated channel in EESSI Slack: <code>#cvmfs-best-practices-hpc</code></p> <p>Click here to join the EESSI Slack</p>"},{"location":"tutorial/#multixscale","title":"MultiXscale","text":"<p>This tutorial was developed and organised in the context of the MultiXscale EuroHPC Centre-of-Excellence.</p> <p>Funded by the European Union. This work has received funding from the European High Performance Computing Joint Undertaking (JU) and countries participating in the project under grant agreement No 101093169.</p>"},{"location":"tutorial/#contributors","title":"Contributors","text":"<ul> <li>Jakob Blomer (CERN, Switzerland)</li> <li>Bob Dr\u00f6ge (University of Groningen, The Netherlands)</li> <li>Kenneth Hoste (Ghent University, Belgium)</li> <li>Alan O'Cais (University of Barcelona, Spain; CECAM)</li> <li>Lara Peeters (Ghent University, Belgium)</li> <li>Laura Promberger (CERN, Switzerland)</li> <li>Thomas R\u00f6blitz (University of Bergen, Norway)</li> <li>Caspar van Leeuwen (SURF, The Netherlands)</li> <li>Valentin V\u00f6lkl (CERN, Switzerland)</li> </ul>"},{"location":"tutorial/#additional-resources","title":"Additional resources","text":"<ul> <li>CernVM-FS website</li> <li>CernVM-FS documentation</li> <li>CernVM-FS @ GitHub</li> <li>CernVM-FS forum</li> <li>Introduction to CernVM-FS by Jakob Blomer (CERN) (2021)</li> <li>Introductory tutorial on CernVM-FS (2021)</li> </ul>"},{"location":"tutorial/configuration_hpc/","title":"Configuration hpc","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/configuration_hpc/#configuring-cernvm-fs-on-hpc-infrastructure","title":"Configuring CernVM-FS on HPC infrastructure","text":"<p>In the previous section we have outlined how to set up a robust CernVM-FS infrastructure, by having a private Stratum 1 replica server and/or dedicated Squid proxy servers. While this approach will work for many HPC systems, some may have slightly more esoteric setups that require specific solutions, which we will discuss in this section.</p>"},{"location":"tutorial/configuration_hpc/#diskless-worker-nodes","title":"Diskless worker nodes","text":"<p>Some HPC systems may have worker nodes without any type of local disk, which is problematic for CernVM-FS since it uses a local cache on the worker nodes. Without this local cache, CernVM-FS can not store the repository content that is being accessed by users.</p> <p>A couple of workarounds are possible in this case:</p> <ul> <li>In-memory client cache</li> <li>Loopback filesystem on a shared filesystem</li> <li>Alien cache</li> </ul>"},{"location":"tutorial/configuration_hpc/#in-memory-client-cache","title":"In-memory client cache","text":"<p>An easy way to set up a client cache on diskless systems is to use a RAM disk like <code>/dev/shm</code>.</p> <p>It suffices to use a path like <code>/dev/shm/cvmfs-cache</code> (or equivalent) as the value for the <code>CVMFS_CACHE_BASE</code> configuration setting in <code>/etc/cvmfs/default.local</code>, along with setting <code>CVMFS_QUOTA_LIMIT</code> to the amount of memory that you would like to dedicate to the CernVM-FS client cache.</p> <p>For example:</p> <pre><code># use max. 4GB of memory for CernVM-FS client cache\nCVMFS_CACHE_BASE=/dev/shm/cvmfs-cache\nCVMFS_QUOTA_LIMIT=4000\n</code></pre> <p>Do not forget to apply the changes made by running:</p> <pre><code>sudo cvmfs_config reload\n</code></pre> <p>An obvious significant drawback of this is that less memory will be available to workloads running on the worker nodes, but it may be worth considering especially if enough memory is available in total.</p> <p>For general information on CernVM-FS cache settings, see the CernVM-FS documentation.</p>"},{"location":"tutorial/configuration_hpc/#loopback-filesystem","title":"Loopback on shared filesystem","text":"<p>The generally recommended solution for diskless worker nodes is to use a loopback filesystem for the CernVM-FS client cache, which can be stored on the cluster's shared filesystem of the HPC cluster. Every worker node will need its own file in this case.</p> <p>This ensures that the parallelism of the shared file system can be exploited, while metadata accesses are performed within the loopback filesystems, and hence not overloading the shared filesystem's metadata server(s).</p> <p>The loopback filesystem files can be created using <code>dd</code> or <code>mkfs</code>. They should be formatted as an <code>ext3</code>, <code>ext4</code>, or <code>xfs</code> file system, and should be 15% larger than the cache size configured on the nodes (with <code>CVMFS_QUOTA_LIMIT</code>).</p> <p>On the worker nodes the loopback filesystem can be mounted from the shared file system, and they should be made available at the location specified in the <code>CVMFS_CACHE_BASE</code> configuration setting (or <code>/var/lib/cvmfs</code>, by default).</p>"},{"location":"tutorial/configuration_hpc/#alien-cache-diskless","title":"Alien cache","text":"<p>An alien cache is a cache that is outside of the (full) control of CernVM-FS.</p> <p>In this scenario you store the cache on a shared filesystem, and have the CernVM-FS processes on all worker nodes use and fill it simultaneously. These processes can pull in the required files that are being accessed by users/jobs, or you can even manually preload the cache.</p> <p>Using the alien cache still requires a very small local cache on the worker nodes for storing some control files. Given its size, you can store this local cache on a shared filesystem, or in memory.</p> <p>Compared to using a loopback filesystem described in the previous subsection, the drawback of storing the alien cache on your shared filesystem is that all metadata operations are now performed on the shared filesystem. Typically, this will result in a large number of metadata operations, and on many shared filesystems will be a significant bottleneck.</p> <p>For more information about an alien cache and configuring it, see the Alien Cache section in the CernVM-FS documentation.</p>"},{"location":"tutorial/configuration_hpc/#offline-worker-nodes","title":"Offline worker nodes","text":"<p>Another typical scenario for HPC systems is that worker nodes do not have (direct) access to the internet.</p> <p>In the context of CernVM-FS, this means that the clients running on the worker nodes are not be able to pull in files from (external) Stratum 1 replica servers.</p> <p>For this scenario, several solutions are available as well:</p> <ul> <li>Squid proxy in local network</li> <li>Private Stratum 1 replica server</li> <li>Alien cache</li> </ul>"},{"location":"tutorial/configuration_hpc/#squid-local","title":"Squid proxy in local network","text":"<p>Setting up a Squid proxy server in the internal network of the cluster, which is highly recommended regardless of whether the worker nodes are offline or not, will circumvent this issue since the worker nodes can be configured to only connect to Stratum 1 servers via the Squid proxy.</p> <p>This means that only the Squid proxy server requires internet access in order to fetch files from the Stratum 1 servers, while the clients will fetch the files from the proxy using the internal network.</p>"},{"location":"tutorial/configuration_hpc/#private-stratum1","title":"Private Stratum 1 replica server","text":"<p>Similar to having a Squid proxy in the internal network of the cluster, one could also opt for setting up a private Stratum 1 replica server that is accessible by the worker nodes, or even do both.</p> <p>Again, only the private Stratum 1 server needs to connect to the internet, as it will need to regularly synchronize with a synchronisation server.</p>"},{"location":"tutorial/configuration_hpc/#alien-cache-offline","title":"Alien cache","text":"<p>As a last resort, you can consider use an alien cache that is being prepopulated on a dedicated system outside of the HPC, which does have internet access.</p> <p>This alien cache can then be made available on the worker nodes, for instance by having it stored on the shared filesystem of the cluster.</p> <p>This is (again) not recommended however, for the same reason as before: this kind of setup will put significant load on the metadata server(s) of the shared filesystem.</p>"},{"location":"tutorial/configuration_hpc/#worker-nodes-without-cernvm-fs","title":"Worker nodes without CernVM-FS","text":"<p>The last scenario that we cover here is for HPC systems that do not have the CernVM-FS client component installed on the worker nodes, for example because the system administrators are not willing to install, configure, and maintain a CernVM-FS installation.</p> <p>Though less ideal than a native installation of CernVM-FS, solutions to make CernVM-FS repositories accessible even in this case exist:</p> <ul> <li>Syncing a to another filesystem</li> <li>Alternative access mechanisms</li> </ul>"},{"location":"tutorial/configuration_hpc/#sync-other-filesystem","title":"Syncing a to another filesystem","text":"<p>A seemingly straightforward solution may be to synchronize (a part of) the contents of a CernVM-FS repository to another filesystem, and make that available on worker nodes.</p> <p>CernVM-FS provides the <code>cvmfs_shrinkwrap</code> utility exactly for this purpose.</p> <p>However, though the solution may sound easy, it has some severe disadvantages: <code>cvmfs_shrinkwrap</code> utility puts a heavy load on the server that is being used to pull in the contents, as it has to fetch all the contents (which may be a large amount of data) in one large bulk operation.</p> <p>In addition, the repository contents will have to be synchronized in some way, which involves rerunning this process regularly.</p> <p>Finally, this approach somewhat defeats the purpose of CernVM-FS, as you will be replacing a filesystem that is optimized for distributing software by one that most likely is not.</p>"},{"location":"tutorial/configuration_hpc/#alternatives","title":"Alternative access mechanisms","text":"<p>Alternative mechanisms to access CernVM-FS repositories exist that do not require system administrator privileges, so they can be leveraged by end users of HPC infrastructure.</p> <p>Examples include using a container runtime like Apptainer, or using <code>cvmfsexec</code>.</p> <p>For more details on these alternatives, see Alternative ways to access CernVM-FS repositories.</p> <p>Parrot connector to CernVM-FS</p> <p>While Parrot is still mentioned in the CernVM-FS documentation (see here), it is no longer recommended to use it, since better alternatives (like <code>cvmfsexec</code>) are available now.</p> <p>(next: Troubleshooting for CernVM-FS repositories)</p>"},{"location":"tutorial/containers/","title":"Containers","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/containers/#containers-and-cernvm-fs","title":"Containers and CernVM-FS","text":"<p>CernVM-FS can also be used to distribute container images, providing many of the same benefits that come with any CernVM-FS installation. Especially the on-demand download of accessed files means that containers start nearly instantly, and are more efficient for large images when only a fraction of the files are read, which is typically the case.</p> <p>Any CernVM-FS repository can be used to distribute container images (although often, dedicated repositories are used, like <code>/cvmfs/unpacked.cern.ch</code>).</p> <p>In order to provide de-duplication and on-demand download, images must be stored unpacked. This requires some dedicated tools, provided by CernVM-FS itself - see the section \"Ingesting container images\" below.</p>"},{"location":"tutorial/containers/#accessing-containers-hosted-in-cernvm-fs-via-apptainer","title":"Accessing containers hosted in CernVM-FS via Apptainer","text":"<p>Apptainer is the recommended way to run containers from CernVM-FS, as it can start a container directly from an unpacked root file system, which is ideal for CernVM-FS.</p> <p>Docker can be used as well but the setup is more complicated, requiring the CernVM-FS graphdriver plugin.</p> <p>For example, to run the <code>tensorflow/tensorflow:2.15.0-jupyter</code> image from Docker Hub that has been unpacked in <code>/cvmfs/unpacked.cern.ch</code>, use the following commands:</p> <pre><code>container=\"registry.hub.docker.com/tensorflow/tensorflow:2.15.0-jupyter\"\npython_code=\"import tensorflow as tf; print(tf.__version__)\"\napptainer run /cvmfs/unpacked.cern.ch/${container} python -c \"${python_code}\"\n</code></pre> <p>This directory just contains the root file system of the image:</p> <pre><code>ls /cvmfs/unpacked.cern.ch/registry.hub.docker.com/tensorflow/tensorflow:2.15.0-jupyter\n</code></pre>"},{"location":"tutorial/containers/#ingesting","title":"Ingesting container images","text":"<p>CernVM-FS provides a suite of container unpacking tools called <code>cvmfs_ducc</code> (provided by the <code>cvmfs-ducc</code> package). This can be used to unpack and ingest container images by simply running</p> <p><pre><code>cvmfs_ducc convert recipe.yaml \n</code></pre> where <code>recipe.yaml</code> is a 'wishlist' of container images available in external registries that should be made available:</p> <pre><code>version: 1\nuser: cvmfsunpacker\ncvmfs_repo: 'unpacked.repo.tld'\ninput:\n    - 'https://registry.hub.docker.com/tensorflow/tensorflow:2.15.0-jupyter'\n    ...\n</code></pre> <p>For more information, see the CernVM-FS documentation.</p>"},{"location":"tutorial/containers/#using-cvmfs-inside-containers","title":"Using <code>/cvmfs</code> inside containers","text":"<p>The easiest way to access CernVM-FS repositories from a container is to set it up on the host and bind-mount it inside the container:</p> <pre><code>docker run -it --volume /cvmfs:/cvmfs:shared ubuntu ls -lna /cvmfs/atlas.cern.ch\n</code></pre> <p>For Apptainer, the same can be done by setting the <code>$SINGULARITY_BIND</code> (or <code>$APPTAINER_BIND</code>) environment variable: </p> <pre><code>export SINGULARITY_BIND=\"/cvmfs\"\n</code></pre> <p>(next: Creating a CernVM-FS repository)</p>"},{"location":"tutorial/creating-repo/","title":"Creating repo","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/creating-repo/#creating-a-cernvm-fs-repository","title":"Creating a CernVM-FS repository","text":"<p>Although creating a new CernVM-FS repository and making it available to the world is not in scope for this tutorial, we do want to give a (very) brief overview of what that entails.</p> <p>For more information on starting with CernVM-FS from scratch to create your own CernVM-FS repository, see the introductory tutorial to the CernVM-FS that was organised at the 6th EasyBuild User Meeting (Jan'21).</p>"},{"location":"tutorial/creating-repo/#stratum-0-creating-repository","title":"Stratum 0 + creating repository","text":"<p>To create a new CernVM-FS repository, you will need to set up a Stratum 0 server, or find an existing one that is willing to host your repository.</p> <p>On a Stratum 0 server, a new repository can be created with:</p> <pre><code>sudo cvmfs_server mkfs example.domain.tld\n</code></pre> <p>For more information on this, see the CernVM-FS documentation, or the second section of the CernVM-FS introductory tutorial.</p>"},{"location":"tutorial/creating-repo/#publishing-content","title":"Publishing content","text":"<p>After creating the repository, you should add some content to it via the update procedure that is documented here, which involves starting a transaction, making changes, and then publishing those changes.</p>"},{"location":"tutorial/creating-repo/#managing-repository","title":"Managing repository","text":"<p>To optimize metadata access for client systems, you may need to look into creating nested catalogs.</p> <p>If files are frequently removed from the repository, you should consider enabling garbage collection.</p>"},{"location":"tutorial/creating-repo/#public-stratum-1-replica-servers","title":"Public Stratum 1 replica servers","text":"<p>To distribute your repository, you should set up one or more public Stratum 1 replica servers, much like we also did in this tutorial (see the Accessing repositories - Private Stratum 1 replica server section).</p> <p>More information on this is available in the CernVM-FS documentation as well.</p> <p>(next: Appendix: Terminology)</p>"},{"location":"tutorial/monitoring/","title":"Monitoring","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/monitoring/#monitoring-cernvm-fs","title":"Monitoring CernVM-FS","text":"<p>There are multiple options available to automate the monitoring of CernVM-FS clients (see CernVM-FS documentation ):</p> <ul> <li>Nagios</li> <li>Telemetry Aggregator</li> <li>HTTP Tracing Header</li> </ul>"},{"location":"tutorial/monitoring/#nagios","title":"Nagios","text":"<p>CernVM-FS supports the Nagios monitoring system. A checker plugin is available on the CernVM-FS download page.</p>"},{"location":"tutorial/monitoring/#telemetry-aggregator","title":"Telemetry Aggregator","text":"<p>The Telemetry Aggregator allows remote monitoring of the internal state of the client. These counters count access to internal data structures and number of errors, and can be accessed locally via <code>cvmfs_talk -i &lt;repo&gt; internal affairs</code>. The Telemetry Aggregator extends this data by also providing the timestamp of the counter collection, the current revision of the repository, and providing these counters in absolute values and delta values relative to the previous measurement. This e.g. allows monitoring if some clients fall behind in updating the repository to the latest revision.</p> <p>By default, the data is sent in Influx data format. The Influx Telemetry Aggregator also allows defining custom user-defined, static tags and fields. Other formats are possible but must be provided as a source code plugin.</p> <p>To activate it the following lines need to be added to the client config (e.g. <code>/etc/cvmfs/default.local</code>): <pre><code>CVMFS_TELEMETRY_SEND=ON\nCVMFS_TELEMETRY_RATE=&lt;rate in seconds&gt; # minimum send rate &gt;= 5 sec\nCVMFS_INFLUX_HOST=localhost                 # IP address\nCVMFS_INFLUX_PORT=8092                      # Port\nCVMFS_INFLUX_METRIC_NAME=&lt;measurement name&gt; # \"Table\" name\nCVMFS_INFLUX_EXTRA_TAGS=\"some_tag=42,some_tag2=27\" # optional // tags are always sent\nCVMFS_INFLUX_EXTRA_FIELDS=\"somefield=3\"            # optional // fields are only sent in absolute data\n</code></pre></p>"},{"location":"tutorial/monitoring/#http-tracing-header","title":"HTTP Tracing Header","text":"<p>CernVM-FS offers to add user-defined, static key-value pairs to the HTTP header for any of its client HTTP request. This includes download of uncached files, selection of proxy and servers (S0/S1).</p> <p>For this the following lines need to be added to the client config (e.g. <code>/etc/cvmfs/default.local</code>): <pre><code>CVMFS_HTTP_TRACING=on \nCVMFS_HTTP_TRACING_HEADERS='node:pn214|tag2:some_tag'\n</code></pre></p> <p>This results to the following header <pre><code>(download) CURL Header for URL: /data/81/7c882d4a2e9dd7f9c5c2bfb4e04ff316e436dfC is:\nConnection: Keep-Alive\nPragma:\nUser-Agent: cvmfs Fuse 2.12.6\nX-CVMFS-node: pn214\nX-CVMFS-tag2: some_tag\nX-CVMFS-PID: 481270\nX-CVMFS-GID: 0\nX-CVMFS-UID: 0\n</code></pre></p>"},{"location":"tutorial/performance/","title":"Performance","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/performance/#performance-aspects-of-cernvm-fs","title":"Performance aspects of CernVM-FS","text":"<p>One aspect we can not ignore in the context of software on HPC infrastructure is performance (the P in HPC).</p>"},{"location":"tutorial/performance/#start-up-performance","title":"Start-up performance","text":"<p>When installations of scientific software applications are provided via a CernVM-FS repository, the main performance metric to worry about is start-up time: the amount of time it takes until an application can start running. This requires that not only the binary program that is being launched itself is somehow available on the system (on disk, in memory, etc.), but also that all files required by it (libraries, dependencies) are available, including the ones they require in turn, etc.</p> <p>Parallel filesystems like GPFS (now IBM Storage Scale) and Lustre, which are ubiquitous on HPC systems, are notorious for not performing well in this respect, which is not surprising since they mainly target a very different use case: large-scale high-performance I/O on large datasets.</p> <p>This has led to all sorts of creative workarounds for \"the startup problem\", including for example tools like Spindle, and recommendations to not install (in particular Python) software directly on the parallel filesystem but to use a container image instead (see the documentation of the current flagship EuroHPC system LUMI).</p> <p>A note on the presented performance results</p> <p>The start-up timing results shown in this section are by no means meant to be a statistically rigorous study of software start-up time.</p> <p>That said, these results should be indicative of what you may see on production HPC systems, and give a good view on the start-up times that you will observe for software provided via CernVM-FS, relative to alternatives like GPFS, Lustre, NFS, local disk, etc.</p> <p>More details on the experimental setup are available at the end of this section.</p>"},{"location":"tutorial/performance/#status-of-relevant-caches","title":"Status of relevant caches","text":"<p>The status of the Linux kernel file system cache, the GPFS caching mechanisms (page pool, stat cache, etc.), and the CernVM-FS client cache are key factors in start-up performance (when they are relevant to the file system being accessed).</p> <p>We discriminate between 3 scenarios: cold cache, hot cache, and warm cache.</p>"},{"location":"tutorial/performance/#cold_cache","title":"Cold cache","text":"<p>We use the term \"cold cache\" when none of files required for starting a particular software application are available in any of the relevant client-side caches.</p> <p>This is the worst-case scenario, since the necessary files have to be obtained elsewhere first, which could be from local disk, or from a remote server (either in the local network, or remotely), which may heavily impact start-up time.</p> <p>To ensure that the caches on the client system are cold, we actively clear all caches each time before we evaluate each start-up performance.</p>"},{"location":"tutorial/performance/#hot_cache","title":"Hot cache","text":"<p>When all files required for running a particular software application are already cached in memory on the client system (in the kernel file system cache, or in the GPFS caches), we have a \"hot cache\" situation.</p> <p>This is the best possible scenario, which is typically the case when the software application has been used recently on that client system.</p> <p>To ensure that the caches on the client system are hot, we first do a couple of warmup runs before we start evaluating start-up performance.</p>"},{"location":"tutorial/performance/#warm_cache","title":"Warm cache","text":"<p>Finally, we also consider a \"warm cache\" situation, in particular when evaluating start-up time for software provided via CernVM-FS. In this situation, all necessary files are available in the CernVM-FS client cache (which is typically on the local disk of the client), but not yet in the in-memory kernel file system cache. As a result, there will be an impact on start-up performance, since the files have to be loaded from (local) disk first.</p> <p>This is a fairly likely scenario, especially if the CernVM-FS client cache is sufficiently large to cover typical workloads being run \u2013 whether that's feasible or not depends a lot on the workload mix.</p> <p>To evaluate start-up performance in this scenario, we:</p> <ol> <li>First do a couple of warmup runs to populate the CernVM-FS client cache;</li> <li>Clear the kernel file system cache;</li> <li>Evaluate the start-up performance once;</li> </ol> <p>Steps 2 and 3 are then repeated to get multiple performance results in the same scenario.</p>"},{"location":"tutorial/performance/#real-world-scenario","title":"Real-world scenario","text":"<p>In a production setup of an HPC cluster, where typically multiple thousands of jobs are being run every day, the actual situation will usually be a mix of these 3 idealistic scenarios, since some files may have been accessed very recently (for example common libraries from the EESSI compatibility layer, or common dependencies from the EESSI software layer), while others may only be in the CernVM-FS client cache, or not cached yet at all (or may have been evicted from the cache due to space constraints).</p>"},{"location":"tutorial/performance/#tensorflow-start-up-performance","title":"TensorFlow start-up performance","text":"<p>We have evaluated the start-up performance of TensorFlow across a wide range of system configurations, by timing how long it takes to run the following command:</p> <pre><code>python -c 'import tensorflow'\n</code></pre> <p>Although this is a trivial single-core workload, it yields some interesting insights into start-up performance for software provided via CernVM-FS and alternatives.</p> <p>More details on this workload, in particular an overview of how many files are required to run it, are available in the Test workload details section.</p>"},{"location":"tutorial/performance/#local-filesystems","title":"Local filesystems","text":"<p>To set the stage, we first evaluate start-up performance using only local filesystems on the client: local disk (SSD, <code>ext4</code>, <code>/tmp</code>) and RAM disk (DDR4 RAM memory, <code>/dev/shm</code>).</p> <p>Using RAM disk for all software installations is not exactly a realistic scenario on an HPC cluster, because of the wide variety of software applications and libraries that are typically employed, and the total amount of storage space that is required to host the necessary software installations. Nevertheless, it is worth evaluating start-up performance with a setup like this, if only to have a clear view on what the best possible start-up time is that we can achieve.</p> <p>Using local disk to provide a large central software stack that caters to the needs of the diverse set of end users is unlikely to be feasible either. In addition, this approach implies a significant maintenance burden since the provided software installations must be identical across all client systems at all times, and typically requires limiting both what is centrally provided and how long software versions remain available. There are HPC sites that do take this approach however, one notable example being TACC, who provide an overview of their central software stack here.</p> <p> </p> <p>These first results show that starting TensorFlow takes ~2.0 seconds when the necessary files can be served directly from RAM disk, and ~2.1 seconds from the kernel file system cache (hot cache).</p> <p>With a cold cache and using software installations located on a local SSD disk, the start-up time of TensorFlow roughly doubles to ~4.3 seconds.</p> <p>These times will be our reference points going forward.</p>"},{"location":"tutorial/performance/#parallel-file-systems","title":"Parallel file systems","text":"<p>Central software stacks on HPC systems are typically provided via some kind of distributed parallel file system, since that significantly reduces the maintenance burden (automatic synchronisation across client systems), and effectively removes the size limitation aspect since these parallel file systems typically have tens to thousands (or more) of TBs of available disk space.</p>"},{"location":"tutorial/performance/#nfs","title":"NFS","text":"<p>Let's start with a traditional and fairly standard approach, which is to make a central software stack available via an export of a centrally managed shared file system using NFS. In this particular case we evaluated TensorFlow start-up time on a worker node of the HPC-UGent Tier-2 cluster victini, which uses NFS-Ganesha.</p> <p> </p> <p>Here we already observe a significant, yet still somewhat limited, increase in start-up time.</p> <p>With a cold cache, ~6.4 seconds are required to start TensorFlow, and there is notably larger variation in the start-up times; neither of these observations is a surprise with NFS.</p> <p>The start-up time with a hot cache is also significantly higher compared to using local filesystems at ~3.8 seconds, but since this is an older generation system we can not directly compare these times to the ones observed for local disk and RAM disk earlier. There is a significant penalty involved though when using NFS, since on the same system we observed start-up times of ~2.5 seconds when using RAM disk, as well as with a hot kernel file system cache.</p> <p>While these start-up times are still quite OK, it is worth noting that NFS is notorious for not scaling well when it needs to serve many different client systems, which is not apparent in these results since only a single client system was used.</p>"},{"location":"tutorial/performance/#lustre","title":"Lustre","text":"<p>Lustre is a popular open-source distributed parallel file system that is used on many large-scale HPC clusters, including VSC Tier-1 Hortense and flagship EuroHPC pre-exascale system LUMI.</p> <p>It is often also the only shared file system that is available on these systems, and hence is the most obvious choice to make software installations available to the cluster worker nodes.</p> <p> </p> <p>We considered two different ways of accessing the Lustre file system of VSC Tier-1 Hortense (see below for more details) on which TensorFlow was installed:</p> <ul> <li>directly, via a read-write mount point;</li> <li>indirectly, via a read-only mount point (which is recommended on Hortense);</li> </ul> <p>In both cases, the start-up times were quite similar, with a dramatic increase to ~75 seconds in the cold cache situation, and a very reasonable ~2.8-2.9 seconds with a hot cache.</p> <p>The start-up time of well over 1 minute for TensorFlow with a cold cache is a clear sign that (this particular version and configuration of) Lustre is not well suited for serving software installations. This is a well-known problem, see for example the \"Avoid Accessing Executables on Lustre Filesystems\" recommendation that is included in the Lustre Best Practices documentation published by the HECC group at NASA for their Pleiades system, and the recommendation for LUMI to not install Python software directly on the Lustre file system.</p>"},{"location":"tutorial/performance/#gpfs","title":"GPFS","text":"<p>Another very popular (commercial) distributed parallel file system is IBM Storage Scale, formerly known as IBM Spectrum Scale, and commonly referred to by its original name GPFS.</p> <p>We evaluated the start-up performance of TensorFlow on the 4 different GPFS file systems that are available in the HPC-UGent Tier-2 infrastructure (see here for more information):</p> <ul> <li><code>apps</code>, which provides the central software stack (along with home directories);</li> <li><code>data</code>, which is intended for long-term storage of large volumes of data;</li> <li><code>scratch</code>, which is recommended for live input/output of jobs;</li> <li><code>scratch (SSD)</code>, an additional smaller scratch file system backed by SSDs, which is recommended for I/O-intensive workloads;</li> </ul> <p> </p> <p>Cold cache start-up times for TensorFlow ranging from ~35 to ~48 seconds are observed for the <code>apps</code>, <code>data</code>, and <code>scratch</code> file systems, with only the <code>scratch (SSD)</code> file system exhibiting somewhat reasonable cold start-up times of ~5.9 seconds.</p> <p>While there is a clear decrease in start-up times when the various GPFS caching mechanisms (page pool, stat cache, file cache) are hot, the situation is still quite dramatic with ~27 to ~33 seconds being needed to start TensorFlow, except for <code>scratch (SSD)</code> where it takes ~5.1 seconds. This implies that the GPFS caching mechanism is not that effective, and that we are still being exposed a lot to the file system latency.</p> <p>The main reason for this is that the GPFS \"stat cache\", which is a client-side caching mechanism for <code>stat</code> system calls that is common across all GPFS files systems available on that client, is set to only have 1,000 entries in the HPC-UGent Tier-2 setup (which is the default for the <code>maxStatCache</code> configuration setting in GPFS). While this could obviously be tuned to improve start-up performance of software, this should not be done on a hunch since it may adversely affect the overall stability of the GPFS storage servers.</p>"},{"location":"tutorial/performance/#cernvm-fs","title":"CernVM-FS","text":"<p>Now that we have an extensive set of reference start-up times, we can evaluate the start-up performance when using a TensorFlow installation that is provided via CernVM-FS.</p> <p>Along with a worker node in the HPC-UGent Tier-2 cluster doduo (located in Ghent, Belgium) as client system, we consider the following configurations:</p> <ul> <li>a private proxy server that is accessible from the client system via a high-speed network;</li> <li>a private Stratum 1 server that is available in the local network via Gbit   Ethernet;</li> <li>the public Stratum 1 server for EESSI in AWS availability zone <code>eu-central-1a</code>;</li> <li>the public Stratum 1 server for EESSI in Azure location <code>East US (Zone 1)</code>;</li> </ul> <p>More technical details on network connectivity to these servers are available below.</p> <p>CernVM-FS was explicitly configured to only use one of these servers, via the <code>CVMFS_SERVER_URL</code> and/or <code>CVMFS_HTTP_PROXY</code> client configuration settings.</p>"},{"location":"tutorial/performance/#cold-cache","title":"Cold cache","text":"<p>Let's start with the worst-case cold cache scenario, in which CernVM-FS needs to download all necessary files to the client system from a (local or remote) server before TensorFlow can be started.</p> <p> </p> <p>We observe very reasonable cold start-up times when using an in-network private proxy server (~8.6 seconds) or private Stratum 1 replica server (~11.0 seconds), significantly better than what we observed for GPFS and Lustre (both of which are accessible from cluster worker nodes via a dedicated high-speed network).</p> <p>When CernVM-FS needs to download the necessary files from a remote public Stratum 1 server we of course observe dramatically longer start-up times, from ~62 seconds when using the relatively close one (within Europe), to about 6 minutes when having to go across the Atlantic.</p> <p>This highlights the need for a private proxy or Stratum 1 replica server for a production-quality CernVM-FS setup.</p>"},{"location":"tutorial/performance/#hot-warm-cache","title":"Hot + warm cache","text":"<p>In the hot cache and warm cache scenarios, in which all necessary files are already available locally on the client system either in-memory or on the local disk, we observe much better start-up times, as expected:</p> <p> </p> <p>With a hot kernel file system cache, we see an average start-up time for TensorFlow of ~2.25 seconds, which suggests there is a ~7% overhead introduced by CernVM-FS. Note that this is still significantly better than what we observed for NFS, Lustre, and GPFS.</p> <p>In the warm cache scenarios where CernVM-FS serves all required files from its client cache on a local SSD disk we see start-up times that are on average ~3.9-4.3 seconds, depending on the network latency to the remote server used in the CernVM-FS client configuration (and interestingly, with a larger variance when using a local proxy or Stratum 1, which may be because of other activity on the local cluster network). We did not try to optimize these warm start-up times by changing the CernVM-FS configuration settings, but some options are already supported by CernVM-FS that could reduce the impact of network latency considerably.</p> <p>When using a RAM disk as location for the CernVM-FS client cache in combination with a private proxy server, the start-up time in the warm cache scenario was reduced to ~2.56 seconds, and a lot less variation was observed (although that could be coincidental).</p>"},{"location":"tutorial/performance/#additional-performance-metrics","title":"Additional performance metrics","text":"<p>Next to software start-up time on a single client system, additional performance metrics should be evaluated as well, including:</p> <ul> <li>The scalability of a CernVM-FS setup when lots of worker nodes of an HPC cluster use software   provided via CernVM-FS, in particular when running (large-scale) MPI applications;</li> <li>The impact of having the CernVM-FS \"service\" running on the client systems, in particular to what extent   it increases OS jitter which can impact performance of workloads;</li> </ul> <p>A more extensive performance study that covers these aspects as well is out of scope for this tutorial.</p>"},{"location":"tutorial/performance/#test-configuration-details","title":"Test configuration details","text":"<p>A multitude of different system configurations is considered to evaluate start-up performance of the test workloads.</p>"},{"location":"tutorial/performance/#client-system","title":"Client system","text":"<p>The client system used in the tests is a worker node of the HPC-UGent Tier-2 cluster \"doduo\", with two exceptions:</p> <ul> <li>When testing NFS, the HPC-UGent Tier-2 cluster \"victini\" was used instead;</li> <li>When testing Lustre, the VSC Tier-1 cluster \"Hortense\" was used instead;</li> </ul> <p>(see System configurations below for more technical details)</p>"},{"location":"tutorial/performance/#software-stack","title":"Software stack","text":"<p>Software installations being used are available via either:</p> <ul> <li>a GPFS filesystem, directly attached to the cluster via a high-speed network;</li> <li>a Lustre filesystem, directly attached to the cluster via a high-speed network;</li> <li>an NFS mount of a GPFS filesystem, via a 10Gbit Ethernet connection;</li> <li>individual CernVM-FS setups:<ul> <li>with a client cache on local disk (SSD, <code>ext4</code>), or in RAM disk (<code>/dev/shm</code>);</li> <li>without and with (only) a (private) proxy server in the local network;</li> <li>without and with (only) a private Stratum 1 replica server in the network;</li> <li>with (only) a specific public Stratum 1 replica server: one in AWS <code>eu-west</code> region,   another in Azure <code>us-east</code> region;</li> </ul> </li> </ul> <p>(see System configurations below for more technical details)</p>"},{"location":"tutorial/performance/#test_workload_details","title":"Test workload details","text":""},{"location":"tutorial/performance/#tensorflow_details","title":"TensorFlow","text":"<p>We evaluate the start-up performance of TensorFlow, which is considered to be a representative example of a scientific workload implemented in Python, which is a tremendously popular programming language in scientific research. We used TensorFlow version 2.13.0, installed with EasyBuild v4.8.2, on top of Python version 3.11.3, which is available in EESSI.</p> <p>Before starting TensorFlow we first load the module to update the environment such that TensorFlow is available:</p> <pre><code>module load TensorFlow/2.13.0-foss-2023a\n</code></pre> <p>To evaluate the start-up performance of TensorFlow, we simply run:</p> <pre><code>python -c 'import tensorflow'\n</code></pre> <p>Timing information is collected using the GNU <code>time</code> command, as follows:</p> <pre><code>/usr/bin/time --format '%e' python -c 'import tensorflow'\n</code></pre>"},{"location":"tutorial/performance/#required-files","title":"Required files","text":"<p>Based on the statistics for and the contents of the CernVM-FS client cache after running the specified command on an <code>x86_64</code> client system (see the details on the HPC-UGent Tier-2 cluster doduo below), starting from a cold CernVM-FS client cache, we know that importing the <code>tensorflow</code> Python package:</p> <ul> <li>triggers ~3,680 <code>open()</code> calls + ~510 <code>opendir</code> calls (which includes non-existing paths);</li> <li>requires ~3,470 files, including:<ul> <li>~2,200 files from the TensorFlow installation itself (~94% <code>*.pyc</code> files);</li> <li>~950 files from Python packages outside of the TensorFlow installation directory,    of which are ~82% <code>*.pyc</code> files and ~12% shared libraries (<code>.so</code>);</li> <li>17 files from the EESSI compatibility layer;</li> </ul> </li> <li>pulls in about ~1.1GB of data in total;</li> </ul> <p>As such, this is a challenge for parallel filesystems like GPFS and Lustre, as the performance results clearly show.</p>"},{"location":"tutorial/performance/#experimental_setup","title":"Experimental setup","text":""},{"location":"tutorial/performance/#system_configurations","title":"System configurations","text":"HPC-UGent Tier-2 cluster 'doduo' <p>Hardware:</p> <ul> <li>Dual-socket AMD EPYC 7552 CPU (AMD Rome, 96 cores in total)</li> <li>256GB of DDR4 RAM memory</li> <li>240GB SSD local disk (<code>ext4</code>)</li> <li>HDR-100 InfiniBand interconnect</li> </ul> <p>Operating system:</p> <ul> <li>Red Hat Enterprise Linux 8.8</li> <li>Linux kernel <code>4.18.0-477.27.1.el8_8.x86_64</code></li> <li>GPFS (now IBM Storage Scale) version 5.1.8-2 (<code>pagepool=4G</code>, <code>maxStatCache=1000</code>, <code>maxFilesToCache=4000</code>)</li> <li>CermVM-FS 2.11.2</li> </ul> <p>(see also HPC-UGent Tier-2 infrastructure overview)</p> HPC-UGent Tier-2 cluster 'victini' <p>Hardware:</p> <ul> <li>Dual-socket AMD EPYC 7552 CPU (AMD Rome, 96 cores in total)</li> <li>256GB of DDR4 RAM memory</li> <li>240GB SSD local disk (<code>ext4</code>)</li> <li>10Gbit Ethernet interconnect</li> </ul> <p>Operating system:</p> <ul> <li>Red Hat Enterprise Linux 8.8</li> <li>Linux kernel <code>4.18.0-477.27.1.el8_8.x86_64</code></li> <li>NFS-Ganesha 3.5</li> <li>CermVM-FS 2.11.2</li> </ul> <p>(see also HPC-UGent Tier-2 infrastructure overview)</p> VSC Tier-1 cluster 'Hortense' <p>Hardware:</p> <ul> <li>Dual-socket Intel Xeon Gold 6140 (CPU Skylake, 36 cores in total)</li> <li>96GB of DDR4 RAM memory</li> <li>900GB SAS HDD local disk (<code>ext4</code>)</li> <li>HDR-100 InfiniBand interconnect</li> </ul> <p>Operating system:</p> <ul> <li>Red Hat Enterprise Linux 8.8</li> <li>Linux kernel <code>4.18.0-477.27.1.el8_8.x86_64</code></li> <li>Lustre 2.12.9</li> <li>CermVM-FS 2.11.2 (with client cache of 4GB on SSD local disk)</li> </ul> <p>(see also VSC documentation page on Hortense)</p> Network details <p>Bandwidth</p> <p>Network bandwidth to HPC-UGent Tier-2 <code>doduo</code> cluster worker node from relevant servers, as measured with <code>iperf3</code> v3.15:</p> <ul> <li>private Squid proxy server in HPC-UGent network: ~22,500 Mbits/sec</li> <li>private Stratum 1 replica server in HPC-UGent network: ~940 Mbits/sec</li> <li>EESSI Stratum 1 replica server in AWS <code>eu-west</code> region: ~930 Mbits/sec</li> <li>EESSI Stratum 1 replica server in Azure <code>us-east</code> region: ~280 Mbits/sec</li> </ul> <p>Server-side <code>iperf3</code> command: <code>iperf3 -V -s -p 80</code> Client-side <code>iperf3</code> command: <code>iperf3 -V -c SERVER_HOSTNAME_OR_IP -p 80 -f m</code></p> <p>Latency</p> <p>Network latency between HPC-UGent Tier-2 <code>doduo</code> cluster worker node and relevant servers, as measured with <code>tcptraceroute</code> v2.1.0-6:</p> <ul> <li>private Squid proxy server in HPC-UGent network: ~0.2 ms</li> <li>private Stratum 1 replica server in HPC-UGent network: ~0.7 ms</li> <li>EESSI Stratum 1 replica server in AWS <code>eu-west</code> region: ~14 ms</li> <li>EESSI Stratum 1 replica server in Azure <code>us-east</code> region: ~84 ms</li> </ul>"},{"location":"tutorial/performance/#relevant-commands","title":"Relevant commands","text":"Kernel file system cache <p>To clear kernel file system cache:</p> <pre><code>sudo sysctl -w vm.drop_caches=3\n</code></pre> <p>To check file system cache usage:</p> <pre><code>vmstat -s -S M | grep buffer\n</code></pre> CernVM-FS client cache <p>To clear the CernVM-FS client cache:</p> <pre><code>sudo cvmfs_config wipecache\n</code></pre> <p>To check size of CernVM-FS client cache on disk (path determined by <code>CVMFS_CACHE_BASE</code> configuration setting):</p> <pre><code>sudo du -sh /var/lib/cvmfs\n</code></pre> <p>To check CernVM-FS client cache usage:</p> <pre><code>cvmfs_config stat -v\n</code></pre> <p>To check CernVM-FS client cache usage for a particular repository:</p> <pre><code>cvmfs_config stat -v software.eessi.io\n</code></pre> <p>To check which files are included in the CernVM-FS client cache, use:</p> <pre><code>sudo cvmfs_talk -i software.eessi.io cache list\n</code></pre> GPFS caching mechanisms <p>To clear all caches used by GPFS (page pool, stat cache, files cache, etc.), we simply shut down GPFS on the client system, and restart it:</p> <pre><code>mmshutdown\nmmstartup\n</code></pre> <p>This should only be done on an idle system, since this will trigger an unmount of all GPFS file systems on that client.</p> <p>(next: Containers and CernVM-FS)</p>"},{"location":"tutorial/troubleshooting/","title":"Troubleshooting","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/troubleshooting/#troubleshooting-for-cernvm-fs","title":"Troubleshooting for CernVM-FS","text":"<p>When you experience problems with getting access to a CernVM-FS repository, it can be tricky to figure out what the actual underlying cause is, given the complexity of a typical CernVM-FS setup.</p> <p>In this section we provide some guidelines on how to troubleshoot some potential problems you may run into with CernVM-FS. We focus on client-side issues: problems that may arise on a CernVM-FS client system itself, or with the connection to external servers like a Squid proxy or a Stratum 1 replica server.</p> <p>While some commands suggested below that can help to determine the actual problem at hand require system administrator privileges (indicated with the use of <code>sudo</code>), several can also be run as an unprivileged user.</p> <p> </p> <p>Note</p> <p>In this section, we will continue to use the EESSI CernVM-FS repository <code>software.eessi.io</code> as a running example, but the troubleshooting guidelines are by no means specific to EESSI.</p> <p>Make sure you adjust the example commands to the CernVM-FS repository you are using, if needed.</p>"},{"location":"tutorial/troubleshooting/#typical-problems","title":"Typical problems","text":""},{"location":"tutorial/troubleshooting/#error-messages","title":"Error messages","text":"<p>The error messages that you may encounter when accessing a CernVM-FS repository are often quite cryptic, especially if you are not very familiar with CernVM-FS, or with file systems and networking on Linux systems in general.</p> <p>Here are a couple of examples:</p> <ul> <li> <p>The CernVM-FS repository may not be known (yet) on your system, which will result   in a (clear) error message like this when you try to access it:   <pre><code>$ ls /cvmfs/software.eessi.io\nls: cannot access '/cvmfs/software.eessi.io': No such file or directory\n</code></pre></p> </li> <li> <p>You may see errors messages that suggest network connectivity problems, like:   <pre><code>Failed to discover HTTP proxy servers (23 - proxy auto-discovery failed)\n</code></pre></p> </li> <li> <p>Other problems may be quite specific to the internals of CernVM-FS,   rather than being configuration or networking issues. Examples include:   <pre><code>Failed to initialize root file catalog (16 - file catalog failure)\n</code></pre> <pre><code>Failed to transfer ownership of /var/lib/cvmfs/shared to cvmfs\n</code></pre> <pre><code>ls: cannot open directory '/cvmfs/config-repo.cern.ch': Too many levels of symbolic links\n</code></pre> <pre><code>Transport endpoint is not connected\n</code></pre>   The last error message indicates that FUSE has failed.</p> </li> </ul> <p>We will give some advice below on how you might figure out what is wrong when seeing error messages like this.</p>"},{"location":"tutorial/troubleshooting/#lag-andor-hangs","title":"Lag and/or hangs","text":"<p>When you notice lag of even (perceived) hanging when accessing a CernVM-FS repository, you should consider revising the connectivity- and cache-related configuration settings.</p>"},{"location":"tutorial/troubleshooting/#general-approach","title":"General approach","text":"<p>In general, it is recommended to take a step-by-step approach to troubleshooting:</p> <ul> <li>Start with verifying the CernVM-FS (client) installation;</li> <li>Review the CernVM-FS configuration;</li> <li>Consider potential network connectivity issues;</li> <li>Keep an eye out for mounting problems;</li> <li>Make sure you have sufficient available resources like memory and local disk space;</li> <li>Rule out any cache-related shenanigans;</li> </ul> <p>Always keep in mind to check the logs, and also consider to employ the other tools that we put forward.</p>"},{"location":"tutorial/troubleshooting/#common-problems","title":"Common problems","text":""},{"location":"tutorial/troubleshooting/#installation","title":"CernVM-FS installation","text":"<p>Make sure that CernVM-FS is actually installed (correctly).</p> <p>Check whether both the <code>/cvmfs</code> directory and the <code>cvmfs</code> service account exists on the system: <pre><code>ls /cvmfs\nid cvmfs\n</code></pre></p> <p>Either of these errors would be a clear indication that CernVM-FS is not installed, or that the installation was not completed: <pre><code>ls: cannot access '/cvmfs': No such file or directory\n</code></pre> <pre><code>id: \u2018cvmfs\u2019: no such user\n</code></pre></p> <p>You can also check whether the <code>cvmfs2</code> command is available, and working:</p> <pre><code>cvmfs2 --help\n</code></pre> <p>which should produce output that starts with:</p> <pre><code>The CernVM File System\nVersion 2.11.2\n</code></pre> <p>In case of problems, revise the section on installing the CernVM-FS client.</p>"},{"location":"tutorial/troubleshooting/#configuration","title":"CernVM-FS configuration","text":"<p>A common issue is incorrectly configuring CernVM-FS, either by making a silly mistake in a configuration file, or by not taking into account the hierarchy of configuration files that CernVM-FS considers.</p>"},{"location":"tutorial/troubleshooting/#reloading","title":"Reloading","text":"<p>Don't forget to reload the CernVM-FS configuration after you've made changes to it:</p> <pre><code>sudo cvmfs_config reload\n</code></pre> <p>Note that changes to specific configuration settings, in particular those related to FUSE, will not be reloaded with this command, since they require remounting the repository.</p>"},{"location":"tutorial/troubleshooting/#show-configuration","title":"Show configuration","text":"<p>Verify the configuration via <code>cvmfs_config showconfig</code>:</p> <pre><code>cvmfs_config showconfig software.eessi.io\n</code></pre> <p>Using the <code>-s</code> option, you can trim the output to only show non-empty configuration settings: <pre><code>cvmfs_config showconfig -s software.eessi.io\n</code></pre></p> <p>We strongly advise combining this command with <code>grep</code> to check for specific configuration settings, like:</p> <pre><code>$ cvmfs_config showconfig software.eessi.io | grep CVMFS_SERVER_URL\nCVMFS_SERVER_URL='http://aws-eu-central-s1.eessi.science/cvmfs/software.eessi.io;http://azure-us-east-s1.eessi.science/cvmfs/software.eessi.io'    # from /cvmfs/cvmfs-config.cern.ch/etc/cvmfs/domain.d/eessi.io.conf\n</code></pre> <p>Be aware that <code>cvmfs_config showconfig</code> will read the configuration files as they are currently, but that does not necessarily mean that those configuration settings are currently active; see also reloading.</p>"},{"location":"tutorial/troubleshooting/#non-existing-repositories","title":"Non-existing repositories","text":"<p>Keep in mind that <code>cvmfs_config</code> does not check whether the specified repository is actually known at all. Try for example querying the configuration for the fictional <code>vim.or.emacs.io</code> repository:</p> <pre><code>cvmfs_config showconfig vim.or.emacs.io\n</code></pre>"},{"location":"tutorial/troubleshooting/#active_configuration","title":"Inspect active configuration","text":"<p>Inspect the active configuration that is currently used by talking to the running CernVM-FS service via <code>cvmfs_talk</code>.</p> <p>Note</p> <p>This requires that the specified CernVM-FS repository is currently mounted.</p> <pre><code>ls /cvmfs/software.eessi.io &gt; /dev/null  # to trigger mount if not mounted yet\nsudo cvmfs_talk -i software.eessi.io parameters\n</code></pre> <p><code>cvmfs_talk</code> can also be used to query other live aspects of a particular repository, see the output of <code>cvmfs_talk --help</code>. For example:</p> <ul> <li>The current revision of repository contents (via <code>revision</code>);</li> <li>Information on the Stratum 1 replica server being used (via <code>host ...</code>);</li> <li>Information on the proxy server being used (via <code>proxy ...</code>);</li> <li>Information on the CernVM-FS client cache (via <code>cache ...</code>);</li> </ul>"},{"location":"tutorial/troubleshooting/#non-mounted-repositories","title":"Non-mounted repositories","text":"<p>If running <code>cvmfs_talk</code> fails with an error like \"<code>Seems like CernVM-FS is not running</code>\", try triggering a mount of the repository first by accessing it (with <code>ls</code>), or by running:</p> <pre><code>cvmfs_config probe software.eessi.io\n</code></pre> <p>If the latter succeeds but accessing the repository does not, there may be an issue with the (active) configuration, or there may be a connectivity problem.</p>"},{"location":"tutorial/troubleshooting/#repository-public-key","title":"Repository public key","text":"<p>In order for CernVM-FS to access a repository the corresponding public key must be available, in a domain-specific subdirectory of <code>/etc/cvmfs/keys</code>, like: <pre><code>$ ls /etc/cvmfs/keys/cern.ch\ncern-it1.cern.ch.pub  cern-it4.cern.ch.pub  cern-it5.cern.ch.pub\n</code></pre></p> <p>or in the active CernVM-FS config repository, like for EESSI:</p> <pre><code>$ ls /cvmfs/cvmfs-config.cern.ch/etc/cvmfs/keys/eessi.io\neessi.io.pub\n</code></pre>"},{"location":"tutorial/troubleshooting/#connectivity","title":"Connectivity issues","text":"<p>There could be various issues related to network connectivity, for example a firewall blocking connections.</p> <p>CernVM-FS uses plain <code>HTTP</code> as data transfer protocol, so basic tools can be used to investigate connectivity issues.</p> <p>You should make sure that the client system can connect to the Squid proxy and/or Stratum-1 replica server(s) via the required ports.</p>"},{"location":"tutorial/troubleshooting/#determine_proxy","title":"Determine proxy server","text":"<p>First figure out if a proxy server is being used via: <pre><code>sudo cvmfs_talk -i software.eessi.io proxy info\n</code></pre></p> <p>This should produce output that looks like:</p> <pre><code>Load-balance groups:\n[0] http://PROXY_IP:3128 (PROXY_IP, +6h)\n[1] DIRECT\nActive proxy: [0] http://PROXY_IP:3128\n</code></pre> <p>(to protect the innocent, the actual proxy IP was replaced with \"<code>PROXY_IP</code>\" in the output above)</p> <p>The last line indicates that a proxy server is indeed being used currently.</p> <p><code>DIRECT</code> would mean that no proxy server is being used.</p>"},{"location":"tutorial/troubleshooting/#access-to-proxy-server","title":"Access to proxy server","text":"<p>If a proxy server is used, you should check whether it can be accessed at port <code>3128</code> (default Squid port).</p> <p>For this, you can use standard networking tools (if available):</p> <ul> <li><code>nc</code>, ncat, a reimplementation of netcat:   <pre><code>nc -vz PROXY_IP 3128\n</code></pre></li> <li><code>telnet</code>:   <pre><code>telnet PROXY_IP 3128\n</code></pre></li> <li><code>tcptraceroute</code>:   <pre><code>sudo tcptraceroute PROXY_IP 3128\n</code></pre></li> </ul> <p>You will need to replace \"<code>PROXY_IP</code>\" in the commands above with the actual IP (or hostname) of the proxy server being used.</p>"},{"location":"tutorial/troubleshooting/#determine-stratum-1","title":"Determine Stratum 1","text":"<p>Check which Stratum 1 servers are currently configured:</p> <pre><code>cvmfs_config showconfig software.eessi.io | grep CVMFS_SERVER_URL\n</code></pre> <p>Determine which Stratum 1 is currently being used by CernVM-FS:</p> <pre><code>$ sudo cvmfs_talk -i software.eessi.io host info\n  [0] http://aws-eu-central-s1.eessi.science/cvmfs/software.eessi.io (unprobed)\n  [1] http://azure-us-east-s1.eessi.science/cvmfs/software.eessi.io (unprobed)\nActive host 0: http://aws-eu-central-s1.eessi.science/cvmfs/software.eessi.io\n</code></pre> <p>In this case, the public Stratum 1 for EESSI in AWS <code>eu-central</code> is being used: <code>aws-eu-central-s1.eessi.science</code>.</p>"},{"location":"tutorial/troubleshooting/#access-to-stratum-1","title":"Access to Stratum 1","text":"<p>If no proxy is being used (<code>CVMFS_HTTP_PROXY</code> is set to <code>DIRECT</code>, see also above), you should check whether the active Stratum 1 is directly accessible at port <code>80</code>.</p> <p>Again, you can use standard networking tools for this:</p> <p><pre><code>nc -vz aws-eu-central-s1.eessi.science 80\n</code></pre> <pre><code>telnet aws-eu-central-s1.eessi.science 80\n</code></pre> <pre><code>sudo tcptraceroute aws-eu-central-s1.eessi.science 80\n</code></pre></p>"},{"location":"tutorial/troubleshooting/#download-from-stratum-1","title":"Download from Stratum 1","text":"<p>To see whether a Stratum 1 replica server can be used to download repository contents from, you can use <code>curl</code> to check whether the <code>.cvmfspublished</code> file is accessible ( this file must exist in every repository ):</p> <pre><code>S1_URL=\"http://aws-eu-central-s1.eessi.science\"\ncurl --head ${S1_URL}/cvmfs/software.eessi.io/.cvmfspublished\n</code></pre> <p>If CernVM-FS is configured to use a proxy server, you should let <code>curl</code> use it too: <pre><code>P_URL=\"http://PROXY_IP:3128\"\nS1_URL=\"http://aws-eu-central-s1.eessi.science\"\ncurl --proxy ${P_URL} --head ${S1_URL}/cvmfs/software.eessi.io/.cvmfspublished\n</code></pre> or equivalently via the standard <code>http_proxy</code> environment variable that <code>curl</code> picks up on: <pre><code>S1_URL=\"http://aws-eu-central-s1.eessi.science\"\nhttp_proxy=\"PROXY_IP:3128\" curl --head ${S1_URL}/cvmfs/software.eessi.io/.cvmfspublished\n</code></pre></p> <p>Make sure you replace \"<code>PROXY_IP</code>\" in the commands above with the actual IP (or hostname) of the proxy server.</p> <p>If you see a <code>200</code> HTTP return code in the first line of output produced by <code>curl</code>, access is working as it should:</p> <pre><code>HTTP/1.1 200 OK\n</code></pre> <p>If you see <code>403</code> as return code, then something is blocking the connection:</p> <pre><code>HTTP/1.1 403 Forbidden\n</code></pre> <p>In this case, you should check whether a firewall is being used, or whether an ACL in the Squid proxy configuration is the culprit.</p> <p>If you see <code>404</code> as return code, you made a typo in the <code>curl</code> command : <pre><code>HTTP/1.1 404 Not Found\n</code></pre> Maybe you forgot the '<code>.</code>' in <code>.cvmfspublished</code>?</p> <p>Note</p> <p>A Stratum 1 server does not provide access to all possible CernVM-FS repositories.</p> <p>It has to be configured to serve particular repositories, as shown in Private Stratum 1 replica server - Creating repository replica.</p>"},{"location":"tutorial/troubleshooting/#network-latency-bandwidth","title":"Network latency &amp; bandwidth","text":"<p>To check the network latency and bandwidth, you can use <code>iperf3</code> and <code>tcptraceroute</code>, see also Network details in System configurations of the Performance section of this tutorial.</p>"},{"location":"tutorial/troubleshooting/#mounting","title":"Mounting problems","text":""},{"location":"tutorial/troubleshooting/#autofs","title":"<code>autofs</code>","text":"<p>Keep in mind that (by default) CernVM-FS repositories are mounted via <code>autofs</code>.</p> <p>Hence, you should not rely on the output of <code>ls /cvmfs</code> to determine which repositories can be accessed with your current configuration, since they may not be mounted currently.</p> <p>You can check whether a specific repository is available by trying to access it directly:</p> <pre><code>ls /cvmfs/software.eessi.io\n</code></pre>"},{"location":"tutorial/troubleshooting/#currently-mounted-repositories","title":"Currently mounted repositories","text":"<p>To check which CernVM-FS repositories are currently mounted, run: <pre><code>cvmfs_config stat\n</code></pre></p>"},{"location":"tutorial/troubleshooting/#probing","title":"Probing","text":"<p>To check whether a repository can be mounted, you can try to probe it:</p> <pre><code>$ cvmfs_config probe software.eessi.io\nProbing /cvmfs/software.eessi.io... OK\n</code></pre>"},{"location":"tutorial/troubleshooting/#manual-mounting","title":"Manual mounting","text":"<p>If you can not get access to a repository via auto-mounting by <code>autofs</code>, you can try to manually mount it, since that may reveal specific error messages:</p> <pre><code>mkdir -p /tmp/cvmfs/eessi\nsudo mount -t cvmfs software.eessi.io /tmp/cvmfs/eessi\n</code></pre> <p>You can even try using the <code>cvmfs2</code> command directly to mount a repository: <pre><code>mkdir -p /tmp/cvmfs/eessi\nsudo /usr/bin/cvmfs2 -d -f \\\n    -o rw,system_mount,fsname=cvmfs2,allow_other,grab_mountpoint,uid=$(id -u cvmfs),gid=$(id -g cvmfs),libfuse=3 \\\n    software.eessi.io /tmp/cvmfs/eessi\n</code></pre> which prints lots of information for debugging (option <code>-d</code>).</p>"},{"location":"tutorial/troubleshooting/#resources","title":"Insufficient resources","text":"<p>Keep in mind that the problems you observe may be the result of a shortage in resources, for example:</p> <ul> <li>Lack of sufficient memory, for example for the kernel file system cache, which will typically   lead to degrated (start-up) performance;</li> <li>Lack of sufficient disk space, for the CernVM-FS client cache, for the proxy server,   or for the private Stratum 1 replica server;</li> <li>Network latency issues, either within the local network (to the proxy server or Stratum 1 replica server),   or to the outside world (public Stratum 1 replica servers) \u2013 see also the Connectivity   section;</li> </ul>"},{"location":"tutorial/troubleshooting/#caching","title":"Caching woes","text":"<p>CernVM-FS assumes that the local cache directory is trustworthy.</p> <p>Although unlikely, problems you are observing could be caused by some form of corruption in the CernVM-FS client cache, for example due to problems outside of the control of CernVM-FS (like a disk partition running full).</p> <p>Even in the absence of problems it may still be interesting to inspect the contents of the client cache, for example when trying to understand performance-related problems.</p>"},{"location":"tutorial/troubleshooting/#checking-cache-usage","title":"Checking cache usage","text":"<p>To check the current usage of the client cache across all repositories, you can use:</p> <pre><code>cvmfs_config stat -v\n</code></pre> <p>You can get machine-readable output by not using the <code>-v</code> option (which is for getting human-readable output).</p> <p>To only get information on cache usage for a particular repository, pass it as an extra argument:</p> <pre><code>cvmfs_config stat -v software.eessi.io\n</code></pre> <p>To check overall cache size, use <code>du</code> on the cache directory (determined by <code>CVMFS_CACHE_BASE</code>):</p> <pre><code>$ sudo du -sh /var/lib/cvmfs\n1.1G    /var/lib/cvmfs\n</code></pre>"},{"location":"tutorial/troubleshooting/#inspecting-cache-contents","title":"Inspecting cache contents","text":"<p>To inspect which files are currently included in the client cache, run the following command:</p> <pre><code>sudo cvmfs_talk -i software.eessi.io cache list\n</code></pre>"},{"location":"tutorial/troubleshooting/#checking-cache-consistency","title":"Checking cache consistency","text":"<p>To check the consistency of the CernVM-FS cache, use <code>cvmfs_fsck</code>: <pre><code>sudo time cvmfs_fsck -j 8 /var/lib/cvmfs/shared\n</code></pre></p> <p>This will take a while, depending on the current size of the cache, and how many cores to use are specified (via the <code>-j</code> option).</p>"},{"location":"tutorial/troubleshooting/#clearing-client-cache","title":"Clearing client cache","text":"<p>To start afresh, you can clear the CernVM-FS client cache: <pre><code>sudo cvmfs_config wipecache\n</code></pre></p>"},{"location":"tutorial/troubleshooting/#logs","title":"Logs","text":"<p>By default CernVM-FS logs to syslog, which usually corresponds to either <code>/var/log/messages</code> or <code>/var/log/syslog</code>.</p> <p>Scanning these logs for messages produced by <code>cvmfs2</code> may help to determine the root cause of a problem.</p>"},{"location":"tutorial/troubleshooting/#debug-log","title":"Debug log","text":"<p>For obtaining more detailed information, CernVM-FS provides the <code>CVMFS_DEBUGLOG</code> configuration setting: <pre><code>CVMFS_DEBUGLOG=/tmp/cvmfs-debug.log\n</code></pre></p> <p>CernVM-FS will log more information to the specified debug log file after reloading the CernVM-FS configuration (supported since CernVM-FS 2.11.0).</p> <p>Debug logging is a bit like a firehose - use with care!</p> <p>Note that with debug logging enabled every operation performed by CernVM-FS will be logged, which quickly generates large files and introduces a significant overhead, so it should only be enabled temporarily when trying to obtain more information on a particular problem.</p> <p>Make sure that the debug log file is writable!</p> <p>Make sure that the <code>cvmfs</code> user has write permission to the path specified in <code>CVMFS_DEBUGLOG</code>.</p> <p>If not, you will not only get no debug logging information, but it will also lead to client failures!</p> <p>For more information on debug logging, see the CernVM-FS documentation.</p>"},{"location":"tutorial/troubleshooting/#logs-via-extended-attributes","title":"Logs via extended attributes","text":"<p>An interesting source of information for mounted CernVM-FS repositories is the extended attributes that CernVM-FS uses, which can accessed via the <code>attr</code> command (see also the CernVM-FS documentation).</p> <p>In particular the <code>logbuffer</code> attribute, which contains the last log messages for that particular repository, which can be accessed without special privileges that are required to access log messages emitted to <code>/var/log/*</code>.</p> <p>For example: <pre><code>$ attr -g logbuffer /cvmfs/software.eessi.io\nAttribute \"logbuffer\" had a 283 byte value for /cvmfs/software.eessi.io:\n[3 Dec 2023 21:01:33 UTC] switching proxy from (none) to http://PROXY_IP:3128 (set proxies)\n[3 Dec 2023 21:01:33 UTC] switching proxy from (none) to http://PROXY_IP:3128 (cloned)\n[3 Dec 2023 21:01:33 UTC] switching proxy from http://PROXY_IP:3128 to DIRECT (set proxies)\n</code></pre></p>"},{"location":"tutorial/troubleshooting/#other-tools","title":"Other tools","text":""},{"location":"tutorial/troubleshooting/#general-check","title":"General check","text":"<p>To verify whether the basic setup is sound, run: <pre><code>sudo cvmfs_config chksetup\n</code></pre> which should print \"<code>OK</code>\".</p> <p>If something is wrong, it may report a problem like:</p> <pre><code>Warning: autofs service is not running\n</code></pre> <p>You can also use <code>cvmfs_config</code> to perform a status check, and verify that the command has exit code zero:</p> <pre><code>$ sudo cvmfs_config status\n$ echo $?\n0\n</code></pre> <p>(next: Performance aspects of CernVM-FS)</p>"},{"location":"tutorial/access/","title":"Index","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/access/#accessing-cernvm-fs-repositories","title":"Accessing CernVM-FS repositories","text":"<ul> <li>Setting up a CernVM-FS client system</li> <li>Setting up a proxy server</li> <li>Setting up a Stratum 1 replica server</li> <li>Alternative ways to access CernVM-FS repositories</li> </ul>"},{"location":"tutorial/access/alternatives/","title":"Alternatives","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/access/alternatives/#alternative-ways-to-access-cernvm-fs-repositories","title":"Alternative ways to access CernVM-FS repositories","text":"<p>While a native installation of CernVM-FS on the client system, along with a proxy server and/or Stratum 1 replica server for large-scale production setups, is recommended, there are other alternatives available for getting access to CernVM-FS repositories.</p> <p>We briefly cover some of these here, mostly to clarify that there are alternatives available, including some that do not require system administrator permissions.</p>"},{"location":"tutorial/access/alternatives/#cvmfsexec","title":"<code>cvmfsexec</code>","text":"<p>Using <code>cvmfsexec</code>, mounting of CernVM-FS repositories as an unprivileged user is possible, without having CernVM-FS installed system-wide.</p> <p><code>cvmfsexec</code> supports multiple ways of doing this depending on the OS version and system configuration, more specifically whether or not particular features are enabled, like:</p> <ul> <li>FUSE mounting with <code>fusermount</code>;</li> <li>unprivileged user namespaces;</li> <li>unprivileged namespace fuse mounts;</li> <li>a <code>setuid</code> installation of Singularity 3.4+ (via <code>singcvmfs</code> which uses the <code>--fusemount</code> feature),   or an unprivileged installation of Singularity 3.6+;</li> </ul> <p>Start by cloning the <code>cvmfsexec</code> repository from GitHub, and change to the <code>cvmfsexec</code> directory:</p> <pre><code>git clone https://github.com/cvmfs/cvmfsexec.git\ncd cvmfsexec\n</code></pre> <p>Before using <code>cvmfsexec</code>, you first need to make a <code>dist</code> directory that includes CernVM-FS, configuration files, and scripts. For this, you can run the <code>makedist</code> script that comes with <code>cvmfsexec</code>:</p> <pre><code>./makedist default\n</code></pre> <p>With the <code>dist</code> directory in place, you can use <code>cvmfsexec</code> to run commands in an environment where a CernVM-FS repository is mounted.</p> <p>For example, we can run a script named <code>test_eessi.sh</code> that contains:</p> <pre><code>#!/bin/bash\n\nsource /cvmfs/software.eessi.io/versions/2023.06/init/bash\n\nmodule load TensorFlow/2.13.0-foss-2023a\n\npython -V\npython3 -c 'import tensorflow as tf; print(tf.__version__)'\n</code></pre> <p>which gives: <pre><code>$ ./cvmfsexec software.eessi.io -- ./test_eessi.sh\n\nCernVM-FS: loading Fuse module... done\nCernVM-FS: mounted cvmfs on /home/rocky/cvmfsexec/dist/cvmfs/cvmfs-config.cern.ch\nCernVM-FS: loading Fuse module... done\nCernVM-FS: mounted cvmfs on /home/rocky/cvmfsexec/dist/cvmfs/software.eessi.io\n\nFound EESSI repo @ /cvmfs/software.eessi.io/versions/2023.06!\narchdetect says x86_64/amd/zen2\nUsing x86_64/amd/zen2 as software subdirectory.\nUsing /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen2/modules/all as the directory to be added to MODULEPATH.\nFound Lmod configuration file at /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen2/.lmod/lmodrc.lua\nInitializing Lmod...\nPrepending /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen2/modules/all to $MODULEPATH...\nEnvironment set up to use EESSI (2023.06), have fun!\n\nPython 3.11.3\n2.13.0\n</code></pre></p> <p>By default, the CernVM-FS client cache directory will be located in <code>dist/var/lib/cvmfs</code>.</p> <p>For more information on <code>cvmfsexec</code>, see https://github.com/cvmfs/cvmfsexec.</p>"},{"location":"tutorial/access/alternatives/#apptainer-with-fusemount","title":"Apptainer with <code>--fusemount</code>","text":"<p>If Apptainer is available, you can get access to a CernVM-FS repository by using a container image that includes the CernVM-FS client component (see for example the Docker recipe for the client container used in EESSI, which is available here).</p> <p>Using the <code>--fusemount</code> option you can specify that a CernVM-FS repository should be mounted when starting the container. For example for EESSI, you should use:</p> <pre><code>apptainer ... --fusemount \"container:cvmfs2 software.eessi.io /cvmfs/software.eessi.io\" ...\n</code></pre> <p>There are a couple of caveats here:</p> <ul> <li> <p>If the configuration for the CernVM-FS repository is provided via the <code>cvmfs-config</code> repository,   you need to instruct Apptainer to also mount that, by using the <code>--fusemount</code> option twice: once for   the <code>cvmfs-config</code> repository, and once for the target repository itself:   <pre><code>FUSEMOUNT_CVMFS_CONFIG=\"container:cvmfs2 cvmfs-config.cern.ch /cvmfs/cvmfs-config.cern.ch\"\nFUSEMOUNT_EESSI=\"container:cvmfs2 software.eessi.io /cvmfs/software.eessi.io\"\napptainer ... --fusemount \"${FUSEMOUNT_CVMFS_CONFIG}\" --fusemount \"${FUSEMOUNT_EESSI}\" ...\n</code></pre></p> </li> <li> <p>Next to mounting CernVM-FS repositories, you also need to bind mount local writable directories   to <code>/var/run/cvmfs</code>, since CernVM-FS needs write access in those locations (for the CernVM-FS client cache):   <pre><code>mkdir -p /tmp/$USER/{var-lib-cvmfs,var-run-cvmfs}\nexport APPTAINER_BIND=\"/tmp/$USER/var-run-cvmfs:/var/run/cvmfs,/tmp/$USER/var-lib-cvmfs:/var/lib/cvmfs\"\napptainer ... --fusemount ...\n</code></pre></p> </li> </ul> <p>To try this, you can use the EESSI client container that is available in Docker Hub, to start an interactive shell in which EESSI is available, as follows:</p> <pre><code>mkdir -p /tmp/$USER/{var-lib-cvmfs,var-run-cvmfs}\nexport APPTAINER_BIND=\"/tmp/$USER/var-run-cvmfs:/var/run/cvmfs,/tmp/$USER/var-lib-cvmfs:/var/lib/cvmfs\"\nFUSEMOUNT_CVMFS_CONFIG=\"container:cvmfs2 cvmfs-config.cern.ch /cvmfs/cvmfs-config.cern.ch\"\nFUSEMOUNT_EESSI=\"container:cvmfs2 software.eessi.io /cvmfs/software.eessi.io\"\napptainer shell --fusemount \"${FUSEMOUNT_CVMFS_CONFIG}\" --fusemount \"${FUSEMOUNT_EESSI}\" docker://ghcr.io/eessi/client-pilot:centos7\n</code></pre>"},{"location":"tutorial/access/alternatives/#alien-cache","title":"Alien cache","text":"<p>An alien cache can be used, optionally in combination with preloading, as another alternative, typically in combination with using a container image or unprivileged user namespaces.</p> <p>For more information, see the Alien cache subsection in the next part of the tutorial.</p> <p>(next: Configuration on HPC systems)</p>"},{"location":"tutorial/access/client/","title":"Client","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/access/client/#cernvm-fs-client-system","title":"CernVM-FS client system","text":"<p>The recommended way to gain access to CernVM-FS repositories is to set up a system-wide native installation of CernVM-FS on the client system(s), which comes down to:</p> <ul> <li>Installing the client component of CernVM-FS;</li> <li>Creating a minimal client configuration file (<code>/etc/cvmfs/default.local</code>);</li> <li>Completing the client setup by:<ul> <li>Creating a<code>cvmfs</code> user account and group;</li> <li>Creating the <code>/cvmfs</code> and <code>/var/lib/cvmfs</code> directories;</li> <li>Configuring <code>autofs</code> to enable auto-mounting of repositories (recommended).</li> </ul> </li> </ul> <p>For repositories that are not included in the default CernVM-FS configuration you also need to provide some additional information specific to those repositories in order to access them.</p> <p>This is not a production-ready setup (yet)!</p> <p>While these basic steps are enough to gain access to CernVM-FS repositories, this is not sufficient to obtain a production-ready setup.</p> <p>This is especially true on HPC infrastructure that typically consists of a large number of worker nodes on which software provided by one or more CernVM-FS repositories will be used.</p> <p>After covering the basic client setup in this section, we will outline how to make accessing of CernVM-FS repositories more reliable and performant, by also setting up a proxy server and CernVM-FS Stratum 1 replica server.</p>"},{"location":"tutorial/access/client/#installing-cernvm-fs-client","title":"Installing CernVM-FS client","text":"<p>Start with installing the <code>cvmfs</code> package which provides the CernVM-FS client component:</p> For RHEL-based Linux distros (incl. CentOS, Rocky, Fedora, ...)For Debian-based Linux distros (incl. Ubuntu) <pre><code># install cvmfs-release package to add yum repository\nsudo yum install -y https://ecsft.cern.ch/dist/cvmfs/cvmfs-release/cvmfs-release-latest.noarch.rpm\n\n# install CernVM-FS client package\nsudo yum install -y cvmfs\n</code></pre> <pre><code># install cvmfs-release package to add apt repository\nsudo apt install lsb-release\ncurl -OL https://ecsft.cern.ch/dist/cvmfs/cvmfs-release/cvmfs-release-latest_all.deb\nsudo dpkg -i cvmfs-release-latest_all.deb\nsudo apt update\n\n# install CernVM-FS client package\nsudo apt install -y cvmfs\n</code></pre> <p>If none of the available <code>cvmfs</code> packages are compatible with your system, you can also build CernVM-FS from source.</p>"},{"location":"tutorial/access/client/#minimal_configuration","title":"Minimal client configuration","text":"<p>Next to installing the CernVM-FS client, you should also create a minimal configuration file for it.</p> <p>This is typically done in <code>/etc/cvmfs/default.local</code>, which should contain something like:</p> <pre><code>CVMFS_CLIENT_PROFILE=\"single\" # a single node setup, not a cluster\nCVMFS_QUOTA_LIMIT=10000\n</code></pre> <p>More information on the structure of <code>/etc/cvmfs</code> and supported configuration settings is available in the CernVM-FS documentation.</p> Client profile setting (click to expand) <p>With <code>CVMFS_CLIENT_PROFILE=\"single\"</code> we specify that this CernVM-FS client should:</p> <ul> <li>Use the proxy server specified via <code>CVMFS_HTTP_PROXY</code>, if that configuration setting is defined;</li> <li>Directly connect to a Stratum-1 replica server that provides the repository being used if no proxy server   is specified via <code>CVMFS_HTTP_PROXY</code>.</li> </ul> <p>As an alternative to defining <code>CVMFS_CLIENT_PROFILE</code>, you can also set <code>CVMFS_HTTP_PROXY</code> to <code>DIRECT</code> to specify that no proxy server should be used by CernVM-FS:</p> <pre><code>CVMFS_HTTP_PROXY=\"DIRECT\"\n</code></pre> <p>We will get back to <code>CVMFS_HTTP_PROXY</code> later when setting up a proxy server.</p> Maximum size of client cache (click to expand) <p>The <code>CVMFS_QUOTA_LIMIT</code> configuration setting specifies the maximum size of the CernVM-FS client cache (in MBs).</p> <p>In the example above, we specify that no more than ~10GB should be used for the client cache.</p> <p>When the specified quota limit is reached, CernVM-FS will automatically remove files from the cache according to the Least Recently Used (LRU) policy, until half of the maximum cache size has been freed.</p> <p>The location of the cache directory can be controlled by <code>CVMFS_CACHE_BASE</code> if needed (default: <code>/var/lib/cvmfs</code>), but must be a on a local file system of the client, not a network file system that can be modified by multiple hosts.</p> <p>Using a directory in a RAM disk (like <code>/dev/shm</code>) for the CernVM-FS client cache can be considered if enough memory is available in the client system, which would help reduce latency and start-up performance of software.</p> <p>For more information on cache-related configuration settings, see the CernVM-FS documentation.</p>"},{"location":"tutorial/access/client/#configuration_hierarchy","title":"Hierarchy of configuration files","text":"<p>CernVM-FS can be configured through a hierarchy of configuration files (sometimes also referred to as parameter files), which can be located under either <code>/etc/cvmfs</code>, or the CernVM-FS configuration repository that is being used (there can be only one), which lives under <code>/cvmfs</code> and is determined by the <code>CVMFS_CONFIG_REPOSITORY</code> configuration setting.</p> <p>There are 3 levels of configuration files: general, domain-specific, and repository-specific.</p> <p>Each CernVM-FS configuration file has either <code>.conf</code> or <code>.local</code> as file extension.</p>"},{"location":"tutorial/access/client/#order-of-configuration-files","title":"Order of configuration files","text":"<p>A CernVM-FS configuration file is sourced to set the configuration settings (a.k.a. parameters) it specifies, in the order outlined below:</p> <ul> <li>By level: first general, then domain-specific, finally repository-specific;</li> <li>Within each level:<ul> <li><code>.conf</code> before <code>.local</code>;</li> <li>CernVM-FS configuration repository before <code>/etc/cvmfs</code> (except for general level);</li> </ul> </li> </ul> <p>As a result, a configuration file that is picked up later can override configuration settings that were specified in an earlier consider configuration file.</p> <p>Concrete example: the settings in the general <code>/etc/cvmfs/default.local</code> configuration file are overridden by those specified in the domain-specific configuration file <code>/cvmfs/cvmfs-config.cern.ch/etc/cvmfs/domain.d/eessi.io.conf</code> (which is located in the default CernVM-FS configuration repository <code>cvmfs-config.cern.ch</code>).</p>"},{"location":"tutorial/access/client/#cfg_general","title":"General level","text":"<p>At the general level, the following configuration files are considered (in order):</p> <ul> <li><code>/etc/cvmfs/default.conf</code></li> <li><code>/etc/cvmfs/default.d/*.conf</code> (in alphabetical order)</li> <li><code>$CVMFS_CONFIG_REPOSITORY/etc/cvmfs/default.conf</code></li> <li><code>/etc/cvmfs/default.local</code></li> </ul>"},{"location":"tutorial/access/client/#cfg_domain","title":"Domain-specific level","text":"<p>At the domain-specific level, the following configuration files are considered (in order):</p> <ul> <li><code>$CVMFS_CONFIG_REPOSITORY/etc/cvmfs/domain.d/DOMAIN.conf</code></li> <li><code>/etc/cvmfs/domain.d/DOMAIN.conf</code></li> <li><code>/etc/cvmfs/domain.d/DOMAIN.local</code></li> </ul> <p>where \"<code>DOMAIN</code>\" is replaced by the domain of the CernVM-FS repository being considered, like <code>eessi.io</code> for <code>software.eessi.io</code>.</p>"},{"location":"tutorial/access/client/#cfg_repository","title":"Repository-specific level","text":"<p>At the repository-specific level, the following configuration files are considered (in order):</p> <ul> <li><code>$CVMFS_CONFIG_REPOSITORY/etc/cvmfs/config.d/&lt;your_repository&gt;.conf</code></li> <li><code>/etc/cvmfs/config.d/&lt;your_repository&gt;.conf</code></li> <li><code>/etc/cvmfs/config.d/&lt;your_repository&gt;.local</code></li> </ul>"},{"location":"tutorial/access/client/#show-configuration","title":"Show configuration","text":"<p>To show all configuration settings in alphabetical order, including by which configuration file it got set, use <code>cvmfs_config showconfig</code>, for example:</p> <pre><code>cvmfs_config showconfig software.eessi.io\n</code></pre> <p>For <code>CVMFS_QUOTA_LIMIT</code>, you should see this in the output:</p> <pre><code>CVMFS_QUOTA_LIMIT=10000    # from /etc/cvmfs/default.local\n</code></pre> <p>See also Inspecting repository configuration.</p>"},{"location":"tutorial/access/client/#completing-the-client-setup","title":"Completing the client setup","text":"<p>To complete the setup of the CernVM-FS client component, we need to make sure that a <code>cvmfs</code> service account and group are present on the system, and the <code>/cvmfs</code> and <code>/var/lib/cvmfs</code> directories exist with the correct ownership and permissions.</p> <p>This should be taken care of by the post-install script that is run when installing the <code>cvmfs</code> package, so you will only need to take action on these aspects if you were installing the CernVM-FS client from source.</p> <p>In addition, it is recommended to update the <code>autofs</code> configuration to enable auto-mounting of CernVM-FS repositories, and to make sure the <code>autofs</code> service is running.</p> <p>All these actions can be performed in one go by running the following command:</p> <pre><code>sudo cvmfs_config setup\n</code></pre> <p>Additional options can be passed to the <code>cvmfs_config setup</code> command to disable some of the actions, like <code>nouser</code> to not create the <code>cvmfs</code> user and group, or <code>noautofs</code> to not update the <code>autofs</code> configuration.</p>"},{"location":"tutorial/access/client/#autofs","title":"Recommendations for <code>autofs</code>","text":"<p>It is recommended to configure <code>autofs</code> to never unmount repositories due to inactivity, since that can cause problems in specific situations.</p> <p>This can be done by setting additional options in <code>/etc/sysconfig/autofs</code> (on RHEL-based Linux distributions) or <code>/etc/default/autofs</code> (on Debian-based distributions):</p> <pre><code>OPTIONS=\"--timeout 0\"\n</code></pre> <p>The default <code>autofs</code> timeout is typically 5 minutes (300 seconds), which is usually specified in <code>/etc/autofs.conf</code>.</p> Warning when using Slurm's <code>job_container/tmpfs</code> plugin with <code>autofs</code> (click to expand) <p>Slurm versions up to 23.02 had issues when the <code>job_container/tmpfs</code> plugin was being used in combination with <code>autofs</code>. More information can be found at the Slurm bug tracker and the CernVM-FS forum.</p> <p>Slurm version 23.02 includes a fix by providing a <code>Shared</code> option for the <code>job_container/tmpfs</code> plugin, which allows it to work with <code>autofs</code>.</p>"},{"location":"tutorial/access/client/#using-static-mounts","title":"Using static mounts","text":"<p>If you prefer not to use <code>autofs</code>, you will need to use static mounting, by either:</p> <ul> <li> <p>Manually mounting the CernVM-FS repositories you want to use, for example:   <pre><code>sudo mkdir -p /cvmfs/software.eessi.io\nsudo mount -t cvmfs software.eessi.io /cvmfs/software.eessi.io\n</code></pre></p> </li> <li> <p>Updating <code>/etc/fstab</code> to ensure that the CernVM-FS repositories are mounted at boot time.</p> </li> </ul> <p>Configuring <code>autofs</code> to never unmount due to inactivity is preferable to using static mounts, because the latter requires that every repository is mounted individually, even if is already known in your CernVM-FS configuration. When using <code>autofs</code> you can access all repositories that are known to CernVM-FS through its active configuration.</p> <p>For more information on mounting repositories, see the CernVM-FS documentation.</p>"},{"location":"tutorial/access/client/#checking-client-setup","title":"Checking client setup","text":"<p>To ensure that the setup of the CernVM-FS client component is valid, you can run:</p> <pre><code>sudo cvmfs_config chksetup\n</code></pre> <p>You should see <code>OK</code> as output of this command.</p>"},{"location":"tutorial/access/client/#default-repositories","title":"Default repositories","text":"<p>The default configuration of CernVM-FS, provided by the <code>cvmfs-config-default</code> package, provides the public keys and configuration for a number of commonly used CernVM-FS repositories.</p> <p>One particular repository included in the default CernVM-FS configuration is <code>cvmfs-config.cern.ch</code>, which is a CernVM-FS config repository that provides public keys and configuration for additional flagship CernVM-FS repositories, like <code>software.eessi.io</code>:</p> <pre><code>$ ls /cvmfs/cvmfs-config.cern.ch/etc/cvmfs\ncommon.conf  config.d  default.conf  domain.d  keys\n\n$ find /cvmfs/cvmfs-config.cern.ch/etc/cvmfs -type f -name '*eessi*'\n/cvmfs/cvmfs-config.cern.ch/etc/cvmfs/domain.d/eessi.io.conf\n/cvmfs/cvmfs-config.cern.ch/etc/cvmfs/keys/eessi.io/eessi.io.pub\n</code></pre> <p>That means we now already have access to the EESSI CernVM-FS repository:</p> <pre><code>$ ls /cvmfs/software.eessi.io\nREADME.eessi  host_injections  versions\n</code></pre>"},{"location":"tutorial/access/client/#inspecting_configuration","title":"Inspecting repository configuration","text":"<p>To check whether a specific CernVM-FS repository is accessible, we can probe it:</p> <pre><code>$ cvmfs_config probe software.eessi.io\nProbing /cvmfs/software.eessi.io... OK\n</code></pre> <p>To view the configuration for a specific repository, use <code>cvmfs_config showconfig</code>: <pre><code>cvmfs_config showconfig software.eessi.io\n</code></pre></p> <p>To check the active configuration for a specific repository used by the running CernVM-FS instance, use <code>cvmfs_talk -i &lt;repo&gt; parameters</code> (which requires admin privileges):</p> <pre><code>sudo cvmfs_talk -i software.eessi.io parameters\n</code></pre> <p><code>cvmfs_talk</code> requires that the repository is currently mounted. If not, you will see an error like this:</p> <pre><code>$ sudo cvmfs_talk -i software.eessi.io parameters\nSeems like CernVM-FS is not running in /var/lib/cvmfs/shared (not found: /var/lib/cvmfs/shared/cvmfs_io.software.eessi.io)\n</code></pre>"},{"location":"tutorial/access/client/#accessing-a-repository","title":"Accessing a repository","text":"<p>To access the contents of the repository, just use the corresponding subdirectory as if it were a local filesystem.</p> <p>While the contents of the files you are accessing are not actually available on the client system the first time they are being accessed, CernVM-FS will automatically downloaded them in the background, providing the illusion that the whole repository is already there.</p> <p>We like to refer to this as \"streaming\" of software installations, much like streaming music or video services.</p> <p>To start using EESSI just source the initialisation script included in the repository:</p> <pre><code>source /cvmfs/software.eessi.io/versions/2023.06/init/bash\n</code></pre> <p>You may notice some \"lag\" when files are being accessed, or not, depending on the network latency.</p>"},{"location":"tutorial/access/client/#additional-repositories","title":"Additional repositories","text":"<p>To access additional CernVM-FS repositories beyond those that are available by default, you will need to:</p> <ul> <li>Add the public keys for those repositories into a domain-specific subdirectory of <code>/etc/cvmfs/keys/</code>;</li> <li>Add the configuration for those repositories into <code>/etc/cvmfs/domain.d</code> (domain-specific) or <code>/etc/cvmfs/config.d</code> (repository-specific).</li> </ul> <p>Examples are available in the <code>etc/cvmfs</code> subdirectory of the config-repo GitHub repository.</p> <p>(next: Squid proxy server)</p>"},{"location":"tutorial/access/proxy/","title":"Proxy","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/access/proxy/#squid-proxy-server","title":"Squid proxy server","text":"<p>As a first step towards a production-ready CernVM-FS setup we can install a Squid forward proxy server, which is strongly recommended in the context of HPC systems.</p> <p>The proxy server will (often dramatically) reduce the latency for client systems for accessing CernVM-FS repositories, and hence significantly improve start-up performance of software provided via CernVM-FS. In addition, it reduces the load on the Stratum 1 replica servers that support the repositories being used.</p> <p>This is particularly important when running large-scale MPI software, since the software binary and all the libraries it requires must be available on all worker nodes being employed before the software can start running.</p>"},{"location":"tutorial/access/proxy/#general-recommendations","title":"General recommendations","text":"<p>The proxy server should have a 10Gbit link to the client systems, a sufficiently powerful CPU, a decent amount of memory for the kernel cache (tens of GBs), and fast local storage (SSD or NVMe).</p> <p>It is strongly recommended to have at least two proxy servers available, to have some redundancy available in case of unexpected problems, or during a maintenance window.</p> <p>As a rule of thumb, it is recommended to have (at least) one proxy server for every couple of hundred worker nodes (100-500).</p> <p>Note that the load on the proxy servers used by CernVM-FS is highly dependent on the workload mix on the client systems.</p>"},{"location":"tutorial/access/proxy/#proxy-server-setup","title":"Proxy server setup","text":""},{"location":"tutorial/access/proxy/#installation","title":"Installation","text":"<p>First, install the <code>squid</code> package using your OS package manager:</p> For RHEL-based Linux distros (incl. CentOS, Rocky, Fedora, ...)For Debian-based Linux distros (incl. Ubuntu) <pre><code>sudo yum install -y squid\n</code></pre> <pre><code>sudo apt install -y squid\n</code></pre>"},{"location":"tutorial/access/proxy/#configuration","title":"Configuration","text":"<p>Create a configuration file for the Squid proxy in <code>/etc/squid/squid.conf</code>.</p> <p>You can use the following template for this:</p> <pre><code># List of local IP addresses (separate IPs and/or CIDR notation) allowed to access your local proxy\nacl local_nodes src YOUR_CLIENT_IPS\n\n# Destination domains that are allowed\n# cern.ch + opensciencegrid.org domains because of cvmfs-config.cern.ch repository,\n# which are provided via Stratum-1 mirror servers hosted by CERN and OSG\nacl stratum_ones dstdomain .cern.ch .opensciencegrid.org .YOURDOMAIN.ORG\n\n# Squid port\nhttp_port 3128\n\n# Deny access to anything which is not part of our stratum_ones ACL.\nhttp_access deny !stratum_ones\n\n# Only allow access from our local machines\nhttp_access allow local_nodes\nhttp_access allow localhost\n\n# Finally, deny all other access to this proxy\nhttp_access deny all\n\nminimum_expiry_time 0\nmaximum_object_size 1024 MB\n\n# proxy memory cache of 1GB\ncache_mem 1024 MB\nmaximum_object_size_in_memory 128 KB\n# 50 GB disk cache\ncache_dir ufs /var/spool/squid 50000 16 256\n</code></pre> <p>In this template, you must change two things in the Access Control List (ACL) settings:</p> <p>1) Specify which client systems can access your proxy by replacing \"<code>YOUR_CLIENT_IPS</code>\" with the corresponding IP range, using CIDR notation;</p> <p>2) Make sure that the proxy server allows access to the Stratum 1 replica servers that are relevant for the CernVM-FS repositories    you are using, by replacing \"<code>.YOURDOMAIN.ORG</code>\" with domain name for the Stratum 1 replica servers    (see also the Squid ACL documentation).</p> <p>For example, to allow connecting to the EESSI Stratum 1 replica servers, use:</p> <pre><code># public Stratum-1 mirror servers for EESSI are hosted under eessi.science domain\nacl stratum_ones dstdomain .cern.ch .opensciencegrid.org .eessi.science\n</code></pre> <p>Note that this configuration assumes that port 3128 is accessible on the proxy server.</p> <p>To check your Squid configuration, use:</p> <pre><code>sudo squid -k parse\n</code></pre> <p>If no warnings or errors are printed by this command, you should be all set (assuming that the ACLs are set correctly).</p> <p>For more information on configuring a Squid proxy, see the CernVM-FS documentation,</p>"},{"location":"tutorial/access/proxy/#starting-the-service","title":"Starting the service","text":"<p>To start the Squid and enable it on booting the proxy server, run:</p> <pre><code>sudo systemctl start squid\nsudo systemctl enable squid\n</code></pre> <p>To check the status of the Squid, you can use:</p> <pre><code>sudo systemctl status squid\n</code></pre>"},{"location":"tutorial/access/proxy/#client-system-configuration","title":"Client system configuration","text":"<p>To make a CernVM-FS client system use the proxy server, the <code>/etc/cvmfs/default.local</code> configuration file on the client system should be updated to include:</p> <pre><code># replace PROXY_IP with the IP address of the proxy server\nCVMFS_HTTP_PROXY=\"http://PROXY_IP:3128\"\n</code></pre> <p>To apply the change we need to reload the CernVM-FS configuration on the client system:</p> <pre><code>sudo cvmfs_config reload\n</code></pre> <p>You can test the new configuration and verify whether the proxy is indeed being used by the client system via <code>cvmfs_config stat</code>:</p> <pre><code>ls /cvmfs/software.eessi.io\ncvmfs_config stat -v software.eessi.io\n</code></pre> <p>We first inspect the contents of the repository using <code>ls</code> to make sure that the repository is mounted, which is assumed by <code>cvmfs_config stat</code>.</p> <p>The output of the <code>stat</code> command should look something like this:</p> <p>Note the <code>Connection</code> line, which clearly shows that the proxy server is used (and is working):</p> <pre><code>Connection: .../software.eessi.io through proxy http://PROXY_IP:3128 (online)\n</code></pre> <p>To check whether the proxy is working as intended you can use <code>curl</code> to try to access the <code>.cvmfspublished</code> file in the root of the repository on a Stratum 1, for example:</p> <pre><code># replace PROXY_IP with the IP address of the proxy server\nhttp_proxy=http://PROXY_IP:3128 curl --head http://aws-eu-central-s1.eessi.science/cvmfs/software.eessi.io/.cvmfspublished\n</code></pre> <p>The first output line of this command should be:</p> <pre><code>HTTP/1.1 200 OK\n</code></pre>"},{"location":"tutorial/access/proxy/#cleanup_proxy","title":"Cleanup to prepare for Stratum 1","text":"<p>To prepare for the next tutorial section on setting up a private Stratum 1 replica server, comment out the <code>CVMFS_HTTP_PROXY</code> line in <code>/etc/cvmfs/default.local</code> by prefixing it with a hash (<code>#</code>):</p> <pre><code>#CVMFS_HTTP_PROXY=\"http://PROXY_IP:3128\"\n</code></pre> <p>The full contents of <code>/etc/cvmfs/default.local</code> on the client system should again be as shown below, like it was initially created when configuring the client:</p> <pre><code>CVMFS_CLIENT_PROFILE=\"single\"\nCVMFS_QUOTA_LIMIT=10000\n</code></pre> <p>Do not forget to also reload the CernVM-FS client configuration: <pre><code>sudo cvmfs_config reload\n</code></pre></p> <p>We will later reconfigure the proxy server so it can be used together with our private Stratum 1.</p> <p>(next: Setting up a Stratum 1 replica server)</p>"},{"location":"tutorial/access/stratum1/","title":"Stratum1","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/access/stratum1/#private-stratum-1-replica-server","title":"Private Stratum 1 replica server","text":"<p>In this section of the tutorial, we will set up a Stratum 1 replica server, which is the next step towards a production-ready CernVM-FS setup.</p>"},{"location":"tutorial/access/stratum1/#cernvm-fs-as-cdn","title":"CernVM-FS as CDN","text":"<p>The content of CernVM-FS repositories is served by a set of Stratum 1 replica servers (sometimes also called mirror servers), which together with the central Stratum 0 server and the proxy servers can be seen as a content delivery network (CDN).</p> <p>A Stratum 1 replica server is a standard web server that uses the CernVM-FS server tools to provide a full mirror of one or more CernVM-FS repositories, which are served and managed through a central Stratum 0 server.</p> <p>The figure below shows the CernVM-FS network for repositories in the <code>cern.ch</code> domain, including the Stratum 1 replica servers which are spread all across the world, and a distributed hierarchy of proxy servers which fetch content from the closest Stratum 1.</p> <p> </p>"},{"location":"tutorial/access/stratum1/#motivation","title":"Motivation","text":"<p>Next to the public Stratum 1 servers that are operated by the maintainers of a CernVM-FS repository, you can also set up your own \"private\" Stratum 1 replica server in your local network.</p> <p>In the context of using CernVM-FS on HPC infrastructure this brings the following benefits:</p> <ul> <li>To improve the overall reliability of the setup, for example in case of (temporary) loss of connectivity to the public Stratum 1 replica servers;</li> <li>To reduce the load on the public Stratum 1 servers;</li> <li>To mitigate the impact of poor network bandwidth to the closest public Stratum 1 server;</li> <li>To improve the latency and hence start-up time of software in situations where the cache of the proxy servers has insufficient capacity;</li> </ul>"},{"location":"tutorial/access/stratum1/#recommendations","title":"Recommendations","text":"<p>When setting up a Stratum 1 replica server, you should take the following recommendations into account:</p> <ul> <li>A RAID-protected low latency storage setup (like SSD   or NVMe) should be used,   because the CernVM-FS server component will run lots of <code>stat</code> system calls against it.</li> <li>An <code>ext3</code> or <code>ext4</code> file system   is preferred (rather than XFS).</li> <li>A standard Apache web server should be installed, which should be close to the   low latency storage. Directory listing is not required.</li> <li>HTTP connections to port <code>80</code> must be possible.</li> </ul> Recommendations on monitoring (click to expand) <p>It is strongly recommended to actively monitor a Stratum 1 replica server, in particular:</p> <ul> <li>CPU usage;</li> <li>disk usage;</li> <li>I/O load;</li> <li>network bandwidth and latency;</li> <li>log messages produced in syslog;</li> </ul> <p>The <code>cvmfs-servermon</code> package can be used to watch for problems in every repository\u2019s <code>.cvmfs_status.json</code> status file.</p> <p>See also the CernVM-FS documentation.</p> Recommendations for a high-availability setup (click to expand) <p>To create a high-availability setup, it is not recommended to use two or more separate Stratum 1 replica servers in a single round-robin service.</p> <p>Since they will be updated at different rates, that would cause errors when a client sees an updated catalog from one Stratum 1, but then tries to read corresponding data files from another that does not yet have the files.</p> <p>Instead, different Stratum 1 replica servers should either be separately configured on the clients, or a pair can be configured  as a high availability active/standby pair using the <code>cvmfs-hastratum1</code> package. </p> <p>An active/standby pair can also be managed by switching a DNS name between two different servers.</p> Recommendations for a public Stratum 1 replica server (click to expand) <p>For a public Stratum 1 replica server, it is recommended to install a Squid frontend in front of the Stratum 1, which should be configured as a reverse proxy, and installed on the same system as the web server, to reduce the number of points of failure. The optimized <code>frontier-squid</code> distribution is recommended. For more information, see the CernVM-FS configuration.</p> <p>Alternatively, separate Squid proxy server machines can be configured in a round-robin DNS configuration and each forward to the Apache server. Note however that if any of them are down the entire service will be considered down by CernVM-FS clients. The impact of this can be mitigated through front end hardware load balancer that quickly takes a system that is down out of service.</p> Recommendations on garbage collection (click to expand) <p>If any CernVM-FS repositories being replicated have garbage collection enabled, the Stratum 1 also needs to run garbage collection in order to prevent the disk space usage from growing rapidly.</p> <p>See the CernVM-FS documentation for more details.</p> Using S3-compatible storage (Amazon S3, Azure Blob, Ceph) <p>CernVM-FS can store data directly to S3-compatible storage systems, such as Amazon S3, Azure Blob, or Ceph.</p> <p>For more information, see the CernVM-FS documentation.</p>"},{"location":"tutorial/access/stratum1/#setup-procedure","title":"Setup procedure","text":"<p>To set up a Stratum 1 replica server and configure it to replicate a particular CernVM-FS repository, you should:</p> <ul> <li>Install the <code>cvmfs-server</code> package;</li> <li>Add the public key of the CernVM-FS repository you want to replicate to <code>/etc/cvmfs/keys/</code>;</li> <li>Create the repository replica;</li> <li>Run the initial synchronisation;</li> <li>Configure <code>cron</code> to perform periodic synchronisation;</li> </ul> <p>In the sections below, we will set up a Stratum 1 replica server for the EESSI CernVM-FS repository <code>software.eessi.io</code>.</p>"},{"location":"tutorial/access/stratum1/#installing-cernvm-fs-server","title":"Installing CernVM-FS server","text":"<p>Start with installing the <code>cvmfs-server</code> package which provides the CernVM-FS server tools.</p> <p>Although we won't actually use the functionality that requires it, we also need to install a package that provides the <code>mod_wsgi</code> Apache adapter module.</p> For RHEL-based Linux distros (incl. CentOS, Rocky, Fedora, ...)For Debian-based Linux distros (incl. Ubuntu) <pre><code># install cvmfs-release package to add yum repository\nsudo yum install -y https://ecsft.cern.ch/dist/cvmfs/cvmfs-release/cvmfs-release-latest.noarch.rpm\n\n# install CernVM-FS server package\nsudo yum install -y cvmfs-server\n\n# install mod_wsgi Apache adapter module\n# (on versions older than equivalent to RHEL8, install mod_wsgi instead)\nsudo yum install -y python3-mod_wsgi\n</code></pre> <pre><code># install cvmfs-release package to add apt repository\nsudo apt install lsb-release\ncurl -OL https://ecsft.cern.ch/dist/cvmfs/cvmfs-release/cvmfs-release-latest_all.deb\nsudo dpkg -i cvmfs-release-latest_all.deb\nsudo apt update\n\n# install CernVM-FS server package + the required mod-wsgi\nsudo apt install -y cvmfs-server\n\n# install mod_wsgi Apache adapter module\n# (on Ubuntu versions older than 22.04, install libapache2-mod-wsgi instead)\nsudo apt install -y libapache2-mod-wsgi-py3\n</code></pre>"},{"location":"tutorial/access/stratum1/#adding-repository-public-key","title":"Adding repository public key","text":"<p>Add the public key for the repositories in the <code>eessi.io</code> domain to <code>/etc/cvmfs/keys</code>:</p> <pre><code>sudo mkdir -p /etc/cvmfs/keys/eessi.io/\nsudo cp eessi.io.pub /etc/cvmfs/keys/eessi.io/\n</code></pre> <p>You can get the contents for <code>eessi.io.pub</code> from the default CernVM-FS config repository on a CernVM-FS client system at:</p> <pre><code>/cvmfs/cvmfs-config.cern.ch/etc/cvmfs/keys/eessi.io/eessi.io.pub\n</code></pre>"},{"location":"tutorial/access/stratum1/#creating-repository-replica","title":"Creating repository replica","text":"<p>To create the repository replica, we need to use run the <code>cvmfs_server add-replica</code> command.</p>"},{"location":"tutorial/access/stratum1/#synchronisation-server","title":"Synchronisation server","text":"<p>We will need to specify the server that should be used for synchronising the repository contents. This can either be the Stratum 0 server, or a public Stratum 1 replica server that was set up to be used for repository synchronisation (by having a <code>.cvmfs_master_replica</code> file in the HTTP root directory).</p> <p>For EESSI we should use <code>aws-eu-west-s1-sync.eessi.science</code> as synchronisation server.</p>"},{"location":"tutorial/access/stratum1/#disabling-the-geoapi","title":"Disabling the GeoAPI","text":"<p>Before creating the replica, we first need to disable the Geo API service in the CernVM-FS server configuration, to avoid getting this error when creating the replica:</p> <pre><code>Installing GeoIP Database... CVMFS_GEO_LICENSE_KEY not set\nfail\n</code></pre> <p>The Geo API service enables client systems to automatically sort Stratum 1 replica servers geographically, so the CernVM-FS client component can prioritize connecting to the closest one.</p> <p>This is really only relevant for public Stratum 1 replica servers, not a private Stratum 1 replica server that is only accessible from within the local network, like the one we are setting up here.</p> <p>To disable the Geo API service, set <code>CVMFS_GEO_DB_FILE</code> to <code>NONE</code> in <code>/etc/cvmfs/server.local</code>:</p> <pre><code>echo 'CVMFS_GEO_DB_FILE=NONE' | sudo tee -a /etc/cvmfs/server.local\n</code></pre>"},{"location":"tutorial/access/stratum1/#creating-replica","title":"Creating replica","text":"<p>To actually create the replica, run the <code>cvmfs_server add-replica</code> command as follows, specifying that the current user account should be the repository owner via <code>-o $USER</code>:</p> <pre><code>sync_server='aws-eu-west-s1-sync.eessi.science'\nrepo='software.eessi.io'\nkey_dir='/etc/cvmfs/keys/eessi.io'\nsudo cvmfs_server add-replica -o $USER http://${sync_server}/cvmfs/${repo} ${key_dir}\n</code></pre> Starting Apache (click to expand) <p>If creating the replica fails with:</p> <pre><code>Apache must be installed and running\n</code></pre> <p>try starting the <code>httpd</code> service first:</p> <pre><code>sudo systemctl start httpd.service\nsudo systemctl enable httpd.service\n</code></pre>"},{"location":"tutorial/access/stratum1/#initial-synchronisation","title":"Initial synchronisation","text":"<p>After creating the replica, we should trigger the initial synchronisation of the repository replica, using the <code>cvmfs_server snapshot</code> command:</p> <pre><code>cvmfs_server snapshot software.eessi.io\n</code></pre> <p>Time for a coffee...</p> <p>Since this will download the full repository contents from the synchronisation server that was specified when creating the repository replica, the initial synchronisation may take a while.</p> <p>The time required for the initial synchronisation is heavily dependent on the size of the repository, and the available network latency to the synchronisation server.</p>"},{"location":"tutorial/access/stratum1/#periodic-synchronisation","title":"Periodic synchronisation","text":"<p>To ensure that updates to the contents of the CernVM-FS repository are synchronised automatically to the Stratum-1 replica server, we should set up a cron job to do periodic synchronisation by running <code>cvmfs_server snapshot -a</code>.</p>"},{"location":"tutorial/access/stratum1/#log-rotation","title":"Log rotation","text":"<p>Before setting up a cron job, we first need to configure log rotation, or running <code>snapshot -a</code> will fail with: <pre><code>/etc/logrotate.d/cvmfs does not exist!\n</code></pre></p> <p>Create <code>/etc/logrotate.d/cvmfs</code> with the following contents:</p> <pre><code>/var/log/cvmfs/*.log {\n    weekly\n    missingok\n    notifempty\n}\n</code></pre>"},{"location":"tutorial/access/stratum1/#cron-job","title":"Cron job","text":"<p>To synchronize all active replica repositories every 5 minutes, we can create a cron job <code>/etc/cron.d/cvmfs_stratum1_snapshot</code> that runs <code>cvmfs_server snapshot -a -i</code>:</p> <pre><code>*/5 * * * * OWNER output=$(/usr/bin/cvmfs_server snapshot -a -i 2&gt;&amp;1) || echo \"$output\"\n</code></pre> <p>In here, you must replace \"<code>OWNER</code>\" with the account name of the repository owner (cfr. the <code>-o $USER</code> option used in the <code>add-replica</code> command above).</p> <p>The <code>-a</code> option enables synchronisation of all active replica repositories, while <code>-i</code> indicates that that repositories for which an initial snapshot has not been run should be skipped.</p> <p>To verify that periodic synchronisation is working correctly, check the contents of the log file:</p> <pre><code>/var/log/cvmfs/snapshots.log\n</code></pre>"},{"location":"tutorial/access/stratum1/#more-information","title":"More information","text":"<p>For more information on the setup and configuration of a Stratum 1 replica server, see the CernVM-FS documentation, in particular the following sections:</p> <ul> <li>Notable CernVM-FS Server Locations and Files</li> <li>CernVM-FS Server Infrastructure</li> </ul>"},{"location":"tutorial/access/stratum1/#using-the-private-stratum-1","title":"Using the private Stratum 1","text":"<p>To actually use the \"private\" Stratum 1 replica server that has been set up we need to change the configuration on each CernVM-FS client system.</p> <p>Initially, we will use only the private Stratum 1 replica server, without a proxy server.</p> <p>Remove <code>CVMFS_HTTP_PROXY</code> from client configuration</p> <p>Do make sure that the <code>CVMFS_HTTP_PROXY</code> line is removed from the CernVM-FS configuration file <code>/etc/cvmfs/default.local</code> on the client system, and that the CernVM-FS configuration was reloaded (with <code>sudo cvmfs_config reload</code>), as was instructed here.</p> <p>After we have verified that the Stratum 1 is used by the client system, we will bring the proxy server back in the game, and demonstrate how to use both the proxy server and the Stratum 1 replica server.</p>"},{"location":"tutorial/access/stratum1/#only-private-stratum-1","title":"Only private Stratum 1","text":""},{"location":"tutorial/access/stratum1/#client-configuration","title":"Client configuration","text":"<p>The <code>CVMFS_SERVER_URL</code> configuration setting on a client system:</p> <ul> <li>Is a string value with a semicolon-separated (<code>;</code>) list of known Stratum 1 servers;</li> <li>Should be enclosed in quotes;</li> <li>Specifies each Stratum 1 as a URL that starts with <code>http://</code>, and ends with <code>/cvmfs/@fqrn@</code></li> </ul> <p>For example:</p> <pre><code>CVMFS_SERVER_URL=\"http://s1.test.eu/cvmfs/@fqrn@;http://s1.test.us/cvmfs/@fqrn@\"\n</code></pre> <p>The <code>@fqrn@</code> substring is replaced by CernVM-FS with the fully qualified repository name, like <code>software.eessi.io</code>.</p> <p><code>CVMFS_SERVER_URL</code> should be specified in the domain-specific configuration file in <code>/etc/cvmfs</code> that is relevant for the CernVM-FS repository we have replicated on our Stratum 1.</p> <p>For <code>software.eessi.io</code>, we should add the following to <code>/etc/cvmfs/domain.d/eessi.io.local</code>:</p> <pre><code>CVMFS_SERVER_URL=\"http://STRATUM1_IP/cvmfs/@fqrn@\"\n</code></pre> <p>in which \"<code>STRATUM1_IP</code>\" must be replaced with (you guessed it) the IP address or hostname of the private Stratum 1 replica server.</p> <p>To apply the configuration change, run <code>cvmfs_config reload</code>:</p> <pre><code>sudo cvmfs_config reload\n</code></pre>"},{"location":"tutorial/access/stratum1/#testing","title":"Testing","text":"<p>To verify that the client configuration was changed correctly, use <code>cvmfs_config stat</code> (which requires that the repository is mounted):</p> <pre><code>ls /cvmfs/software.eessi.io\ncvmfs_config stat -v software.eessi.io\n</code></pre> <p>The output line that starts with <code>Connection</code> should mention <code>online</code>, like this:</p> <pre><code>Connection: http://.../cvmfs/software.eessi.io through proxy DIRECT (online)\n</code></pre> <p>The <code>proxy DIRECT</code> indicates that we are not using a proxy server yet in this setup.</p> <p>You can also use <code>curl</code> to check the connection to the Stratum 1, by letting it print the HTTP header for the <code>.cvmfspublished</code> file in the root of the repository:</p> <pre><code>curl --head http://STRATUM1_IP/cvmfs/software.eessi.io/.cvmfspublished\n</code></pre> <p>the first line of the output should be something like: <pre><code>HTTP/1.1 200 OK\n</code></pre></p> <p>If instead you see <code>403 Forbidden</code> then the proxy server is blocking the connection: <pre><code>HTTP/1.1 403 Forbidden\n</code></pre></p>"},{"location":"tutorial/access/stratum1/#proxy-private-stratum-1","title":"Proxy + private Stratum 1","text":"<p>To have a more complete view, let's now also bring the proxy server back in the game.</p>"},{"location":"tutorial/access/stratum1/#reconfigure-squid-proxy","title":"Reconfigure Squid proxy","text":"<p>First we need to make a small but important change to the configuration of the Squid proxy, to ensure that the proxy server is allowed to connect to the private Stratum 1 replica server.</p> <p>Update the ACL for the Stratum 1 servers in <code>/etc/squid/squid.conf</code> on the proxy server by adding the IP address of the private Stratum 1: <pre><code># replace STRATUM1_IP with the IP address of the private Stratum 1\nacl stratum_ones dstdomain .eessi.science STRATUM1_IP\n</code></pre></p> <p>And then reload for configuration for the Squid proxy service:</p> <pre><code>sudo systemctl reload squid\n</code></pre>"},{"location":"tutorial/access/stratum1/#client-configuration_1","title":"Client configuration","text":"<p>We also need to update the client configuration to restore the <code>CVMFS_HTTP_PROXY</code> line in <code>/etc/cvmfs/default.local</code>, like we did when using the proxy server:</p> <pre><code># replace PROXY_IP with the IP address of the proxy server\nCVMFS_HTTP_PROXY=\"http://PROXY_IP:3128\"\n</code></pre> <p>Don't forget to reload the CernVM-FS client configuration:</p> <pre><code>sudo cvmfs_config reload\n</code></pre>"},{"location":"tutorial/access/stratum1/#testing_1","title":"Testing","text":"<p>To test whether the setup using both the proxy server and the Stratum 1 replica server works, we can try accessing the EESSI repository, for example by sourcing the initialisation script:</p> <pre><code>source /cvmfs/software.eessi.io/versions/2023.06/init/bash\n</code></pre> <p>The output of <code>sudo cvmfs_config stat -v software.eessi.io</code> should include a <code>Connection</code> line that ends with <code>(online)</code>, like this:</p> <pre><code>Connection: http://STRATUM1_IP/cvmfs/software.eessi.io through proxy http://PROXY_IP:3128 (online)\n</code></pre> <p>You can also use <code>curl</code> to check whether the Stratum 1 can be reached via the proxy server:</p> <pre><code>http_proxy=http://PROXY_IP:3128 curl --head http://STRATUM1_IP/cvmfs/software.eessi.io/.cvmfspublished\n</code></pre>"},{"location":"tutorial/access/stratum1/#conclusions","title":"Conclusions","text":"<p>With a private Stratum 1 replica server, we have a more production-ready setup in place for using CernVM-FS.</p> <p>Using both a proxy server and a Stratum 1 replica server is another step in that direction, since it further improves the resilience, maintainability, scalability, and performance of the setup (since the proxy server can serve request from its memory cache).</p> <p>For the sake of demonstration we have used two separate systems for the Stratum 1 replica server and the proxy server, but both services can also be installed and configuration on the same server, and also installing multiple proxy servers is sensible to improve load balancing, for example to serve different HPC clusters that have significantly different workload mixes.</p> <p>(next: Alternative ways to access CernVM-FS repositories)</p>"},{"location":"tutorial/appendix/terminology/","title":"Terminology","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/appendix/terminology/#cernvm-fs-terminology","title":"CernVM-FS Terminology","text":"<p>An overview of terms used in the context of CernVM-FS, in alphabetical order.</p>"},{"location":"tutorial/appendix/terminology/#catalog","title":"Catalog","text":"<p>A catalog of a CernVM-FS repository is a table that lists files and directories along with the corresponding metadata (sizes, timestamps, etc.).</p> <p>Catalogs can be nested: subtrees of the repository may have their own catalog.</p> <p>For more information on the catalog concept, see the CernVM-FS documentation.</p>"},{"location":"tutorial/appendix/terminology/#cernvm","title":"CernVM","text":"<p>CernVM is a virtual machine image based on CentOS combined with a custom, virtualization-friendly Linux kernel, and which includes the CernVM-FS client software.</p> <p>It is used for the CERN Large Hadron Collider (LHC) experiment, and was created to remove a need for the installation of the experiment software and to minimize the number of platforms (compiler-OS combinations) on which experiment software needs to be supported and tested.</p> <p>While originally developed in conjunction, the CernVM File System today is a product that is completely independent from the CernVM virtual appliance.</p> <p>For more information on CernVM, see the website and documentation.</p>"},{"location":"tutorial/appendix/terminology/#cvmfs","title":"CernVM-FS","text":"<p>(see What is CernVM-FS?)</p>"},{"location":"tutorial/appendix/terminology/#client","title":"Client","text":"<p>A client in the context of CernVM-FS is a computer system on which a CernVM-FS repository is being accessed, on which it will be presented as a POSIX read-only file system in a subdirectory of <code>/cvmfs</code>.</p>"},{"location":"tutorial/appendix/terminology/#proxy","title":"Proxy","text":"<p>A proxy, also referred to as squid proxy, is a forward caching proxy server which acts as an intermediary between a CernVM-FS client and the Stratum-1 replica servers.</p> <p>It is used to improve the latency observed when accessing the contents of a repository, and to reduce the load on the Stratum-1 replica servers.</p> <p>A commonly used proxy is Squid.</p> <p>For more information on proxies, see the CernVM-FS documentation.</p>"},{"location":"tutorial/appendix/terminology/#publishing","title":"Publishing","text":"<p>Publishing is the process of adding more files to a CernVM-FS repository, which is done via a transaction mechanism, and is on possible on the Stratum-0 server, via a publisher, or via a repository gateway.</p> <p>The workflow of publishing content is covered in detail in the CernVM-FS documentation.</p>"},{"location":"tutorial/appendix/terminology/#repository","title":"Repository","text":"<p>A CernVM-FS repository is where the files and directories that you want to distribute via CernVM-FS are stored, which usually correspond to a collection of software installations.</p> <p>It is a form of content-addressable storage (CAS), and is the single source of (new) data for the file system being presented as a subdirectory of <code>/cvmfs</code> on client systems that mount the repository.</p> <p>Note</p> <p>A CernVM-FS repository includes software installations, not software packages like RPMs.</p>"},{"location":"tutorial/appendix/terminology/#software-installations","title":"Software installations","text":"<p>An important distinction for a CernVM-FS repository compared to the more traditional notion of a software repository is that a CernVM-FS repository provides access to the individual files that collectively form a particular software installation, as opposed to housing a set of software packages like RPMs, each of which being a collection of files for a particular software installation that are packed together in a single package to distribute as a whole.</p> <p>Note</p> <p>This is an important distinction, since CernVM-FS enables only downloading the specific files that are required to perform a particular task with a software installation, which often is a small subset of all files that are part of that software installation.</p>"},{"location":"tutorial/appendix/terminology/#stratum0","title":"Stratum 0 server","text":"<p>A Stratum 0 server, often simply referred to a Stratum 0 (Stratum Zero), is the central server for one or more CernVM-FS repositories.</p> <p>It is the single source of (new) data, since it hosts the master copy of the repository contents.</p> <p>Adding or updating files in a CernVM-FS repository (publishing) can only be done on the Stratum 0 server, either directly via the <code>cvmfs_server publish</code> command, or indirectory via a publisher server.</p> <p>For more information, see the CernVM-FS documentation.</p>"},{"location":"tutorial/appendix/terminology/#stratum1","title":"Stratum 1 replica server","text":"<p>A Stratum 1 replica server, often simply referred to a Stratum 1 (Stratum One), is a standard web server that acts as a mirror server for one or more CernVM-FS repositories.</p> <p>It holds a complete copy of the data for each CernVM-FS repository it serves, and automatically synchronises with the Stratum 0.</p> <p>There is typically a network of several Stratum 1 servers for a CernVM-FS repository, which are geographically distributed.</p> <p>Clients can be configured to automatically connect to the closest Stratum 1 server by using the CernVM-FS GeoAPI.</p> <p>For more information, see the CernVM-FS documentation.</p>"},{"location":"tutorial/cvmfs/","title":"Index","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/cvmfs/#introduction-to-cernvm-fs","title":"Introduction to CernVM-FS","text":"<ul> <li>What is CernVM-FS?</li> <li>Technical details</li> <li>Flagship repositories</li> </ul>"},{"location":"tutorial/cvmfs/flagship-repositories/","title":"Flagship repositories","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/cvmfs/flagship-repositories/#flagship-cernvm-fs-repositories","title":"Flagship CernVM-FS repositories","text":"<p>Here we list a couple of flagship CernVM-FS repositories, all of which are publicly available.</p>"},{"location":"tutorial/cvmfs/flagship-repositories/#lhc-experiments","title":"LHC experiments","text":"<p>CernVM-FS repositories are used to distribute the software required to analyse the data produced by the Large Hadron Collider (LHC) at each of the LHC experiments.</p> <p>Examples include (click to browse repository contents):</p> <ul> <li><code>/cvmfs/alice.cern.ch</code>: software for ALICE experiment</li> <li><code>/cvmfs/atlas.cern.ch</code>: software for ATLAS experiment</li> <li><code>/cvmfs/cms.cern.ch</code>: software for CMS experiment</li> <li><code>/cvmfs/lhcb.cern.ch</code>: software for LHCb experiment</li> <li><code>/cvmfs/sft.cern.ch</code>: LCG Software Stacks</li> </ul>"},{"location":"tutorial/cvmfs/flagship-repositories/#lcg-releases","title":"LCG Releases","text":"<p>The LCG Software Stacks which is distributed via the CernVM-FS repository <code>/cvmfs/sft.cern.ch</code> contains in total over 800 external packages as well as HEP-specific tools and generators.</p> <p>Software installations included often come with a script that updates your shell environment for using them by sourcing it. In addition, through so-called views a complete software stack can be made available in your shell environment.</p> <p>For example, loading software for the specific view LCG_107 for RHEL9 can be dona via: <pre><code>source /cvmfs/sft.cern.ch/lcg/views/LCG_107/x86_64-el9-gcc14-opt/setup.sh\n</code></pre></p>"},{"location":"tutorial/cvmfs/flagship-repositories/#the-alliance","title":"The Alliance","text":"<p>The Digital Research Alliance of Canada, a.k.a. The Alliance and formerly known as Compute Canada, uses CernVM-FS to distribute the software stack for the Canadian national compute clusters.</p> <p>Documentation on using their CernVM-FS repository <code>/cvmfs/soft.computecanada.ca</code> can be found here, and an overview of all available software can be found here.</p>"},{"location":"tutorial/cvmfs/flagship-repositories/#unpacked-containers","title":"Unpacked containers","text":"<p>CernVM-FS repositories can be used to provide an efficient way to access container images, by serving unpacked container images that can be consumed by container runtimes such as Apptainer.</p> <p>Examples include:</p> <ul> <li><code>/cvmfs/unpacked.cern.ch</code></li> <li><code>/cvmfs/singularity.opensciencegrid.org</code></li> </ul> <p>More information on <code>unpacked.cern.ch</code> is available in the CernVM-FS documentation:</p> <ul> <li>Container Images and CernVM-FS</li> <li>Working with DUCC and Docker Images</li> </ul>"},{"location":"tutorial/cvmfs/flagship-repositories/#eessi","title":"EESSI","text":"<p>The European Environment for Scientific Software Installations (EESSI) provides optimized installations of scientific software for <code>x86_64</code> (Intel + AMD) and <code>aarch64</code> (64-bit Arm) systems that work on any Linux distribution via the CernVM-FS repository <code>/cvmfs/software.eessi.io</code>.</p> <p>We will use EESSI as an example CernVM-FS repository throughout this tutorial.</p> <p>(next: What is EESSI?)</p>"},{"location":"tutorial/cvmfs/technical-details/","title":"Technical details","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/cvmfs/technical-details/#technical-details-of-cernvm-fs","title":"Technical details of CernVM-FS","text":"<p>CernVM-FS is implemented as a POSIX read-only filesystem in user space (FUSE) with repositories of files that are served via outgoing HTTP connections only, thus avoiding problems with firewalls.</p> <p>Files in a CernVM-FS repository are automatically downloaded on-demand to a client system as they are accessed, from web servers that support the CernVM-FS repository being used.</p> <p>Internally, CernVM-FS uses content-adressable storage (CAS) and Merkle trees (like Git also does) to store file data and metadata.</p>"},{"location":"tutorial/cvmfs/technical-details/#caching","title":"Caching","text":"<p>CernVM-FS uses a caching mechanism with a least-recently used (LRU) cache replacement policy, in which configurable local client cache is populated via either a forward proxy server (like Squid), or from a Stratum-1 replica server.</p> <p>Both the proxy and the replica server could be within the same local network as the client, or not.</p> <p>To help reduce performance problems regarding network latency and bandwidth, clients can leverage the Geo API supported by CernVM-FS Stratum-1 replica servers to automatically sort them geographically, in order to prioritize connecting to the closest ones.</p> <p>Furthermore, additional caches can be made available to CernVM-FS, such as an alien cache on a shared cluster filesystem like GPFS or Lustre that is not managed by CernVM-FS, and a Content Delivery Network (CDN) can be used to help limit the time required to download files that are not cached yet.</p> <p>(next: Flagship CernVM-FS repositories)</p>"},{"location":"tutorial/cvmfs/what-is-cvmfs/","title":"What is cvmfs","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/cvmfs/what-is-cvmfs/#what-is-cernvm-fs","title":"What is CernVM-FS?","text":"<p>CernVM-FS, the CernVM File System (also known as CVMFS), is a file distribution service that is particularly well suited to distribute software installations across a large number of systems world-wide in an efficient way.</p> <p>From an end user perspective, files in a CernVM-FS repository are available read-only via a subdirectory in <code>/cvmfs</code>, with a user experience similar to that of an on-demand streaming service for music or video, but then (mainly) applied to software installations.</p>"},{"location":"tutorial/cvmfs/what-is-cvmfs/#primary-use-case","title":"Primary use case","text":"<p>The primary use case of CernVM-FS is distributing software, and it provides several interesting features that support this, including:</p> <ul> <li>on-demand downloading and updating of repository contents;</li> <li>multi-level caching;</li> <li>de-duplication of files;</li> <li>compression of data;</li> <li>verification of data integrity;</li> </ul> <p>CernVM-FS has been proven to scale to billions of files and tens of thousands of clients.</p> <p>It was originally developed at CERN to let High Energy Physics (HEP) collaborations like the experiments at the Large Hadron Collider (LHC) deploy software on the Worldwide LHC Computing Grid (WLCG) infrastructure that is used to run data processing applications.</p> <p>The primary use case of distributing software is a particular one, since software often comprises many small files that are frequently opened and read as a whole, and frequent look-ups for files in multiple directories are triggered when search paths are examined.</p> <p>In certain cases, the CernVM-FS has also been used to distribute large data repositories.</p>"},{"location":"tutorial/cvmfs/what-is-cvmfs/#features","title":"Features","text":""},{"location":"tutorial/cvmfs/what-is-cvmfs/#features-ondemand","title":"On-demand downloading of files and metadata","text":"<p>The metadata and content of files included in a CernVM-FS repository are automatically downloaded on-demand as files and directories are being accessed, which is akin to streaming services for music, movies, and TV series.</p> <p>This happens fully transparently, all the contents of a repository are exposed by CernVM-FS as if they were a local (read-only) file system. Hence, clients that access a CernVM-FS repository typically do not have a local copy of all the files included in that repository, but only have a limited set of files and metadata directly available: those which were most recently accessed.</p>"},{"location":"tutorial/cvmfs/what-is-cvmfs/#features-updating","title":"Automatic updates","text":"<p>CernVM-FS clients automatically pull in updates to the contents of a repository as they are published server-side. This happens in transactions, to ensure that clients observe a consistent state of the repository.</p> <p>Once a CernVM-FS repository is accessible on a client system, no subsequent actions must be taken to keep clients up-to-date other than updating CernVM-FS itself on a regular basis.</p> <p>This significantly limits the maintenance burden, since no action is required on client systems to update the software stack that is provided through a CernVM-FS repository, since the updates are streamed in automatically by CernVM-FS.</p> <p>Only the CernVM-FS client should be updated on a regular basis on client systems.</p> <p>For more elaborate setups that involve proxies or CernVM-FS replica (mirror) servers, additional maintenance is necessary, but again only to update the CernVM-FS components themselves.</p>"},{"location":"tutorial/cvmfs/what-is-cvmfs/#features-caching","title":"Multi-level caching","text":"<p>CernVM-FS uses a multi-level caching hierarchy to reduce the latency observed when accessing repository contents. Caching is an essential part of CernVM-FS, since the contents of a CernVM-FS repository are downloaded on-demand as they are accessed.</p> <p>The caching mechanism employed by CernVM-FS goes way beyond the standard (in-memory) Linux kernel file system cache, and consists of a local client cache, an optional forward proxy server that acts as an intermediary cache level, and a distributed network of mirror servers that support the CernVM-FS repository being accessed.</p> <p>When a part of the repository is being accessed that is not available yet in the local client cache, CernVM-FS will traverse the multi-level cache hierarchy to obtain the necessary data and update the local client cache with it, so the files being accessed can be served with low latency.</p> <p>Proxy and mirror servers scale horizontally: the CernVM-FS client makes automatic use of multiple deployed service instances for load-balancing and high-availability.</p> <p>We will explore this multi-level caching mechanism in more detail in this tutorial.</p> <p>See here more technical details on CernVM-FS caching.</p>"},{"location":"tutorial/cvmfs/what-is-cvmfs/#features-deduplication","title":"De-duplication of files","text":"<p>CernVM-FS stores the contents of a file only once, even when it is included multiple times in a particular repository at different paths.</p> <p>This can result in a significant reduction in storage capacity that is required to host a large software stack, especially when identical files are spread out across the repository, as often happens with particular files like example data files across multiple versions of the same software.</p> <p>For the CernVM-FS client, data de-duplication will also happen across repositories when the local client cached is shared across all repositories (the default).</p>"},{"location":"tutorial/cvmfs/what-is-cvmfs/#features-compression","title":"Compression of data","text":"<p>CernVM-FS stores file content compressed on the server, which not only further reduces required storage space but also significantly limits the network bandwidth that is required to download (and serve) the contents of a repository.</p> <p>On the client side, the data is transparently decompressed when the files included in a CernVM-FS repository are presented under <code>/cvmfs</code> as a normal (read-only) file system.</p>"},{"location":"tutorial/cvmfs/what-is-cvmfs/#features-data-integrity","title":"Verification of data integrity","text":"<p>The integrity of data provided by a CernVM-FS server is ensured on a client system by verifying a cryptographic hash, which is again a direct result of content-addressable storage mechanism that is used by CernVM-FS. This is an essential security aspect since CernVM-FS uses (possibly untrusted) caches and HTTP connections to distribute the contents of a repository.</p> <p>(next: Technical details of CernVM-FS)</p>"},{"location":"tutorial/eessi/","title":"Index","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/eessi/#eessi","title":"EESSI","text":""},{"location":"tutorial/eessi/#european-environment-for-scientific-software-installations","title":"European Environment for Scientific Software Installations","text":"<ul> <li>What is EESSI?</li> <li>Motivation &amp; Goals</li> <li>Inspiration</li> <li>High-level design</li> <li>Using EESSI</li> <li>Getting support</li> </ul>"},{"location":"tutorial/eessi/high-level-design/","title":"High level design","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/eessi/high-level-design/#high-level-design-of-eessi","title":"High-level design of EESSI","text":"<p>The design of EESSI is very similar to that of the Compute Canada software stack it is inspired by, and is aligned with the motivation and goals of the project.</p> <p>In the remainder of this section of the tutorial, we will explore the layered structure of the EESSI software stack, and how to use it.</p> <p>In the next section will cover in detail how you can get access to EESSI (and other publicly available CernVM-FS repositories).</p>"},{"location":"tutorial/eessi/high-level-design/#layered-structure","title":"Layered structure","text":"<p>To provide optimized installations of scientific software stacks for a diverse set of system architectures, the EESSI project consists of 3 layers, which are constructed by leveraging various open source software projects:</p> <ul> <li>the filesystem layer to distribute the software stack;</li> <li>the compatibility layer to level the ground across different client operating systems;</li> <li>the software layer to run optimized applications and provided their dependencies</li> </ul> <p> </p>"},{"location":"tutorial/eessi/high-level-design/#filesystem_layer","title":"Filesystem layer","text":"<p>The filesystem layer uses CernVM-FS to distribute the EESSI software stack to client systems.</p> <p>As presented in the previous section, CernVM-FS is a mature open source software project that was created exactly for this purpose: to distribute software installations worldwide reliably and efficiently in a scalable way. As such, it aligns very well with the goals of EESSI.</p> <p>The CernVM-FS repository for EESSI is <code>/cvmfs/software.eessi.io</code>, which is part of the default CernVM-FS configuration since 21 November 2023.</p> <p>To gain access to it, no other action is required then installing (and configuring) the client component of CernVM-FS.</p> Note on the EESSI pilot repository (click to expand) <p>There is also a \"pilot\" CernVM-FS repository for EESSI (<code>/cvmfs/pilot.eessi-hpc.org</code>), which was primarily used to gain experience with CernVM-FS in the early years of the EESSI project.</p> <p>Although it is still available currently, we do not recommend using it.</p> <p>Not only will you need to install the CernVM-FS configuration for EESSI to gain access to it, there also are no guarantees that the EESSI pilot repository will remain stable or even available, nor that the software installations it provides are actually functional, since it may be used for experimentation purposes by the EESSI maintainers.</p>"},{"location":"tutorial/eessi/high-level-design/#compatibility_layer","title":"Compatibility layer","text":"<p>The compatibility layer of EESSI levels the ground across different (versions of) the Linux operating system (OS) of client systems that use the software installations provided by EESSI.</p> <p>It consists of a limited set of libraries and tools that are installed in a non-standard filesystem location (a \"prefix\"), which were built from source for the supported CPU families using Gentoo Prefix.</p> <p>The installation path of the EESSI compatibility layer corresponds to the <code>compat</code> subdirectory of a specific version of EESSI (like <code>2023.06</code>) in the EESSI CernVM-FS repository, which is specific to a particular type of OS (currently only <code>linux</code>) and CPU family (currently <code>x86_64</code> and <code>aarch64</code>):</p> <pre><code>$ ls /cvmfs/software.eessi.io/versions/2023.06/compat\nlinux\n\n$ ls /cvmfs/software.eessi.io/versions/2023.06/compat/linux\naarch64  x86_64\n\n$ ls /cvmfs/software.eessi.io/versions/2023.06/compat/linux/x86_64\nbin  etc  lib  lib64  opt  reprod  run  sbin  stage1.log  stage2.log  stage3.log  startprefix  tmp  usr  var\n\n$ ls -l /cvmfs/software.eessi.io/versions/2023.06/compat/linux/x86_64/lib64\ntotal 4923\n-rwxr-xr-x 1 cvmfs cvmfs  210528 Nov 15 11:22 ld-linux-x86-64.so.2\n...\n-rwxr-xr-x 1 cvmfs cvmfs 1876824 Nov 15 11:22 libc.so.6\n...\n-rwxr-xr-x 1 cvmfs cvmfs  911600 Nov 15 11:22 libm.so.6\n...\n</code></pre> <p>Libraries included in the compatibility layer can be used on any Linux client system, as long as the CPU family is compatible and taken into account.</p> <pre><code>$ uname -m\nx86_64\n\n$ cat /etc/redhat-release\nRed Hat Enterprise Linux release 8.8 (Ootpa)\n\n$ /cvmfs/software.eessi.io/versions/2023.06/compat/linux/x86_64/lib64/libc.so.6\nGNU C Library (Gentoo 2.37-r7 (patchset 10)) stable release version 2.37.\n...\n</code></pre> <p>By making sure that the software installations included in EESSI only rely on tools and libraries provided by the compatibility layer, and do not (directly) require anything from the client OS, we can ensure that they can be used in a broad variety of Linux systems, regardless of the (version of) Linux distribution being used.</p> <p>Note</p> <p>This is very similar to the OS tools and libraries that are included in container images, except that no container runtime is involved here.</p> <p>Typically only CernVM-FS is used to provide the entire software (stack).</p>"},{"location":"tutorial/eessi/high-level-design/#software_layer","title":"Software layer","text":"<p>The top layer of EESSI is called the software layer, which contains the actual scientific software applications and their dependencies.</p>"},{"location":"tutorial/eessi/high-level-design/#easybuild","title":"EasyBuild to install software","text":"<p>Building, managing, and optimising the software installations included in the software layer is layer is done using EasyBuild, a well-established software build and installation framework for managing (scientific) software stacks on High-Performance Computing (HPC) systems.</p>"},{"location":"tutorial/eessi/high-level-design/#lmod","title":"Lmod as user interface","text":"<p>Next to installing the software itself, EasyBuild also automatically generates environment module files. These files, which are essentially small Lua scripts, are consumed via Lmod, a modern implementation of the concept of environment modules which provides a user-friendly interface to end users of EESSI.</p>"},{"location":"tutorial/eessi/high-level-design/#cpu_detection","title":"CPU detection via <code>archspec</code> or <code>archdetect</code>","text":"<p>The initialisation script that is included in the EESSI repository automatically detects the CPU family and microarchitecture of a client system by leveraging either <code>archspec</code>, a small Python library, or <code>archdetect</code>, a minimal pure bash implementation of the same concept.</p> <p>Based on the features of the detected CPU microarchitecture, the EESSI initialisation script will automatically select the best suited subdirectory of the software layer that contains software installations that are optimised for that particular type of CPU, and update the session environment to start using it.</p>"},{"location":"tutorial/eessi/high-level-design/#software_layer_structure","title":"Structure of the software layer","text":"<p>For now, we just briefly show the structure of <code>software</code> subdirectory that contains the software layer of a particular version of EESSI below.</p> <p>The <code>software</code> subdirectory is located at the same level as the <code>compat</code> directory for a particular version of EESSI, along with the <code>init</code> subdirectory that provides initialisation scripts:</p> <pre><code>$ cd /cvmfs/software.eessi.io/versions/2023.06\n$ ls\ncompat  init  software\n</code></pre> <p>In the <code>software</code> subdirectory, a subtree of directories is located that contains software installations that are specific to a particular OS family (only <code>linux</code> currently) and a specific CPU microarchitecture (with <code>generic</code> as a fallback):</p> <pre><code>$ ls software\nlinux\n\n$ ls software/linux\naarch64  x86_64\n\n$ ls software/linux/aarch64\ngeneric  neoverse_n1  neoverse_v1\n\n$ ls software/linux/x86_64\namd  generic  intel\n\n$ ls software/linux/x86_64/amd\nzen2  zen3\n\n$ ls software/linux/x86_64/intel\nhaswell  skylake_avx512\n</code></pre> <p>Each subdirectory that is specific to a particular CPU microarchitecure provides the actual optimised software installations (in <code>software</code>) and environment module files (in <code>modules/all</code>).</p> <p>Here we explore the path that is specific to AMD Milan CPUs, which have the Zen3 microarchitecture, focusing on the installations of OpenBLAS:</p> <pre><code>$ ls software/linux/x86_64/amd/zen3\nmodules  software\n\n$ ls software/linux/x86_64/amd/zen3/software\n\n... (long list of directories of software names omitted) ...\n\n$ ls software/linux/x86_64/amd/zen3/software/OpenBLAS/\n0.3.21-GCC-12.2.0  0.3.23-GCC-12.3.0\n\n$ ls software/linux/x86_64/amd/zen3/software/OpenBLAS/0.3.23-GCC-12.3.0/\nbin  easybuild  include  lib  lib64\n\n$ ls software/linux/x86_64/amd/zen3/modules/all\n\n... (long list of directories of software names omitted) ...\n\n$ ls software/linux/x86_64/amd/zen3/modules/all/OpenBLAS\n0.3.21-GCC-12.2.0.lua  0.3.23-GCC-12.3.0.lua\n</code></pre> <p>Each of the other subdirectories for specific CPU microarchitectures will have the exact same structure, and provide the same software installations and accompanying environment module files to access them with Lmod.</p> <p>A key aspect here is that binaries and libraries that make part of the software installations included in the EESSI software layer only rely on libraries provided by the compatibility layer and/or other software installations in the EESSI software layer.</p> <p>See for example libraries to which the OpenBLAS library links:</p> <pre><code>$ ldd software/linux/x86_64/amd/zen3/software/OpenBLAS/0.3.23-GCC-12.3.0/lib/libopenblas.so\n    linux-vdso.so.1 (0x00007ffd4373d000)\n    libm.so.6 =&gt; /cvmfs/software.eessi.io/versions/2023.06/compat/linux/x86_64/lib/../lib64/libm.so.6 (0x000014d0884c8000)\n    libgfortran.so.5 =&gt; /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen3/software/GCCcore/12.3.0/lib64/libgfortran.so.5 (0x000014d087115000)\n    libgomp.so.1 =&gt; /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen3/software/GCCcore/12.3.0/lib64/libgomp.so.1 (0x000014d088480000)\n    libc.so.6 =&gt; /cvmfs/software.eessi.io/versions/2023.06/compat/linux/x86_64/lib/../lib64/libc.so.6 (0x000014d086f43000)\n    /lib64/ld-linux-x86-64.so.2 (0x000014d08837e000)\n    libpthread.so.0 =&gt; /cvmfs/software.eessi.io/versions/2023.06/compat/linux/x86_64/lib/../lib64/libpthread.so.0 (0x000014d088479000)\n    libdl.so.2 =&gt; /cvmfs/software.eessi.io/versions/2023.06/compat/linux/x86_64/lib/../lib64/libdl.so.2 (0x000014d088474000)\n    libquadmath.so.0 =&gt; /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen3/software/GCCcore/12.3.0/lib64/libquadmath.so.0 (0x000014d08842d000)\n    libgcc_s.so.1 =&gt; /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen3/software/GCCcore/12.3.0/lib64/libgcc_s.so.1 (0x000014d08840d000)\n</code></pre> Note on <code>/lib64/ld-linux-x86-64.so.2</code> (click to expand) <p>The <code>/lib64/ld-linux-x86-64.so.2</code> path, which corresponds to the dynamic linker/loader of the Linux client OS, that is shown in the output of <code>ldd</code> above is a bit misleading.</p> <p>It only pops up because we are running the <code>ldd</code> command provided by the client OS, which typically resides at <code>/usr/bin/ldd</code>.</p> <p>When actually running software provided by the EESSI software layer, the loader provided by the EESSI compatibility layer is used to launch binaries.</p> <p>We will explore the EESSI software layer a bit more when we demonstrate how to use the software installations provided the EESSI CernVM-FS repository.</p> <p>(next: Using EESSI)</p>"},{"location":"tutorial/eessi/inspiration/","title":"Inspiration","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/eessi/inspiration/#inspiration-for-eessi","title":"Inspiration for EESSI","text":"<p>The EESSI concept is heavily inspired by software stack provided by the Digital Research Alliance of Canada (a.k.a. The Alliance, formerly known as Compute Canada), which is a shared software stack used on all national host sites for Advanced Research Computing in Canada that is distributed across Canada (and beyond) using CernVM-FS; see also here.</p> <p>EESSI is significantly more ambitious in its goals however, in various ways.</p> <p>It intends to support a broader range of system architectures than what is currently supported by the Compute Canada software stack, like Arm 64-bit microprocessors, accelerators beyond NVIDIA GPUs, etc.</p> <p>In addition, EESSI is set up to be a community project, by setting up services and infrastructure to automate the software build and installation process as much as possible, providing extensive documentation and support to end users, user support teams, and system administrators who want to employ EESSI, and allowing contributors to propose additions to the software stack.</p> <p>The design of the Compute Canada software stack is discussed in detail in the PEARC'19 paper \"Providing a Unified Software Environment for Canada\u2019s National Advanced Computing Centers\".</p> <p>It has also been presented at the 5th EasyBuild User Meeting, see slides and talk recording.</p> <p>More information on the Compute Canada software stack is available in their documentation, and in their overview of available software.</p> <p>(next: High-level Overview of EESSI)</p>"},{"location":"tutorial/eessi/motivation-goals/","title":"Motivation goals","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/eessi/motivation-goals/#motivation-goals-of-eessi","title":"Motivation &amp; Goals of EESSI","text":""},{"location":"tutorial/eessi/motivation-goals/#motivation","title":"Motivation","text":"<p>EESSI is motivated by the observation that the landscape of computational science is changing in various ways, including:</p> <ul> <li>Increasing diversity in system architectures: additional families of general-purpose   microprocessors including Arm 64-bit (<code>aarch64</code>) and   RISC-V on top of the well-established Intel and AMD processors (both <code>x86_64</code>),   and different types of GPUS (NVIDIA, AMD, Intel);</li> <li>Rapid expansion of computational science beyond traditional domains like physics and computational chemistry,   including bioinformatis, Machine Learning (ML) and Artificial Intelligence (AI), etc.,   which leads to a significant growth of the software stack that is used for running scientific workloads;</li> <li>Emergence of commercial cloud infrastructure (Amazon EC2,   Microsoft Azure, ...)   that has competitive advantages over on-premise infrastructure for computational workloads, such as near-instant   availability, increased flexibility, a broader variety of hardware platforms, and faster access to   new generations of microprocessors;</li> <li>Limited manpower that is available in the HPC user support teams that are responsible for helping   scientists with running the software they require on high-end (and complex) infrastructure like supercomputers   (and beyond);</li> </ul> <p>Collectively, these indicate that there is a strong need for more collaboration on building and installing scientific software to avoid duplicate work across computational scientists and HPC user support teams.</p>"},{"location":"tutorial/eessi/motivation-goals/#goals","title":"Goals","text":"<p>The main goal of EESSI is to provide a collection of scientific software installations that work across a wide range of different platforms, including HPC clusters, cloud infrastructure, and personal workstations and laptops, without making compromises on the performance of that software.</p> <p>While initially the focus of EESSI is to support Linux systems with established system architectures like AMD + Intel CPUs and NVIDIA GPUs, the ambition is to also cover emerging technologies like Arm 64-bit CPUs, other accelerators like the AMD Instinct and Intel Xe, and eventually also RISC-V microprocessors.</p> <p>The software installations included in EESSI are optimized for specific generations of microprocessors by targeting a variety of instruction set architectures (ISAs), like for example Intel and AMD processors supporting the AVX2 or AVX-512 instructions, and Arm processors that support SVE instructions.</p> <p>(next: Inspiration for EESSI)</p>"},{"location":"tutorial/eessi/support/","title":"Support","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/eessi/support/#getting-support-for-eessi","title":"Getting support for EESSI","text":"<p>Thanks to the funding provided by the MultiXscale EuroHPC JU Centre-of-Excellence, a dedicated support team is available to provide help on accessing or using EESSI.</p> <p>If you have any questions, or if you are experiencing problems, do not hesitate to reach out by either opening an issue in the EESSI support portal, or sending an email to <code>support@eessi.io</code>.</p> <p>For more information, see the support section of the EESSI documentation.</p> <p>(next: CernVM-FS client system)</p>"},{"location":"tutorial/eessi/using-eessi/","title":"Using eessi","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/eessi/using-eessi/#using-eessi","title":"Using EESSI","text":"<p>Using the software installations provided by the EESSI CernVM-FS repository <code>software.eessi.io</code> is fairly straightforward.</p> <p>Let's break it down step by step.</p>"},{"location":"tutorial/eessi/using-eessi/#0-is-eessi-available","title":"0) Is EESSI available?","text":"<p>First, check whether the EESSI CernVM-FS repository is available on your system.</p> <p>Try checking the contents of the <code>/cvmfs/software.eessi.io</code> directory with the <code>ls</code> command:</p> <pre><code>$ ls /cvmfs/software.eessi.io\nREADME.eessi  host_injections  versions\n</code></pre> <p>If you see an error message like \"<code>No such file or directory</code>\", then either the CernVM-FS client is not installed on your system, or the configuration for the EESSI repository is not available. In that case, you may want to revisit the Accessing a CernVM-FS repository section, or go through the Troubleshooting section.</p> Don't be fooled by <code>autofs</code> (click to expand) <p>The <code>/cvmfs</code> directory may seem empty at first, because CernVM-FS repositories are automatically mounted as they are accessed via <code>autofs</code>.</p> <p>So rather than just using \"<code>ls /cvmfs/</code>\" to check which CernVM-FS repositories are available on your system, you should try to directly access a specific repository as shown above for EESSI with <code>ls /cvmfs/software.eessi.io</code> .</p> <p>For more information on various aspects of mounting of CernVM-FS repositories, see the CernVM-FS documentation.</p>"},{"location":"tutorial/eessi/using-eessi/#init","title":"1) Initialise shell environment","text":"<p>If the EESSI repository is available, you can proceed to preparing your shell environment for using a particular version of EESSI by sourcing the provided initialisation script by running the <code>source</code> command:</p> <pre><code>$ source /cvmfs/software.eessi.io/versions/2023.06/init/bash\nFound EESSI repo @ /cvmfs/software.eessi.io/versions/2023.06!\narchdetect says x86_64/amd/zen2\nUsing x86_64/amd/zen2 as software subdirectory.\nUsing /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen2/modules/all as the directory to be added to MODULEPATH.\nFound Lmod configuration file at /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen2/.lmod/lmodrc.lua\nInitializing Lmod...\nPrepending /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen2/modules/all to $MODULEPATH...\nEnvironment set up to use EESSI (2023.06), have fun!\n</code></pre> Details on changes made to the shell environment (click to expand) <p>The initialisation script is a simple bash script that changes a couple of environment variables:</p> <ul> <li>A set of <code>$EESSI_*</code> environment variables is defined;</li> <li>The <code>$PS1</code> environment variable that specifies the shell prompt   is updated to indicate that your shell session has been initialised for EESSI;</li> <li>The location of the tools provided by the EESSI compatibility layer are prepended to the <code>$PATH</code> environment variable;</li> <li>Lmod, which is included in the EESSI compatibility layer, is initialised to ensure that the <code>module</code> command is defined,   and that the Lmod spider cache that is included in the EESSI software layer is picked up;</li> <li>The location to the software installations that are optimised for the CPU microarchitecture of the client system   is prepended to the <code>$MODULEPATH</code> environment variable by running a \"<code>module use</code>\" command.</li> </ul> <p>Note how the CPU microarchitecture is being auto-detected, which determines which path that points to a set of environment module files is used to update <code>$MODULEPATH</code>.</p> <p>This ensures that the modules that will be loaded provide access to software installations from the EESSI software layer that are optimised for the system you are using EESSI on.</p>"},{"location":"tutorial/eessi/using-eessi/#2-load-modules","title":"2) Load module(s)","text":"<p>After initialising your shell environment for using EESSI, you can start exploring the EESSI software layer using the <code>module</code> command.</p> <p>Using <code>module avail</code> (or <code>ml av</code>), you can check which software is available. Without extra arguments, <code>module avail</code> will produce an overview of all available software. By passing an extra argument you can filter the results and search for specific software:</p> <pre><code>$ module avail tensorflow\n\n----- /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen2/modules/all -----\n\n    TensorFlow/2.13.0-foss-2023a\n</code></pre> <p>To start using software you should load the corresponding environment module files using <code>module load</code> (or <code>ml</code>). For example:</p> <pre><code>$ module load TensorFlow/2.13.0-foss-2023a\n</code></pre> <p>A <code>module load</code> command usually does not produce any output, but it updates your shell environment to make the software ready to use.</p> <p>For more information on the <code>module</code> command, see the User Guide for Lmod.</p>"},{"location":"tutorial/eessi/using-eessi/#3-use-software","title":"3) Use software","text":"<p>After loading a module, you should be able to use the corresponding software.</p> <p>For example, after loading the <code>TensorFlow/2.13.0-foss-2023a</code> module, you can start a Python session and play with the <code>tensorflow</code> Python package:</p> <pre><code>$ python\n&gt;&gt;&gt; import tensorflow as tf\n&gt;&gt;&gt; tf.__version__\n'2.13.0'\n</code></pre> <p>Keep in mind that you are using a Python installation provided by the EESSI software layer here, not the Python version that may be provided by your client OS:</p> <pre><code>$ command -v python\n/cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen2/software/Python/3.11.3-GCCcore-12.3.0/bin/python\n</code></pre> Initial start-up delay (click to expand) <p>You may notice a bit of \"lag\" initially when starting to use software provided by the EESSI software layer.</p> <p>This is expected, since CernVM-FS may need to first download the files that are required to run the software you are using; see also On-demand downloading of files and metadata.</p> <p>You should not observe any significant start-up delays anymore when running the same software shortly after, since then CernVM-FS will be able to serve the necessary files from the local client cache; see also Multi-level caching.</p> <p>(next: Getting support for EESSI)</p>"},{"location":"tutorial/eessi/what-is-eessi/","title":"What is eessi","text":"<p>Work in progress</p> <p>(30 April 2025)</p> <p>The contents of this tutorial are currently being reworked to be up-to-date with recent developments in CernVM-FS, and to be well integrated in the EESSI documentation.</p> <p>It is based on the \"Best Practices for CernVM-FS in HPC\" tutorial that was held on 4 Dec 2023, see also https://multixscale.github.io/cvmfs-tutorial-hpc-best-practices.</p>"},{"location":"tutorial/eessi/what-is-eessi/#what-is-eessi","title":"What is EESSI?","text":"<p>The European Environment for Scientific Software Installations (EESSI, pronounced as \"easy\") is a collaboration between different European partners in the HPC (High Performance Computing) community.</p> <p>EESSI provides a common stack of optimized scientific software installations that work on any Linux distribution, and currently supports both <code>x86_64</code> (AMD/Intel) and <code>aarch64</code> (Arm 64-bit) systems, which is distributed via CernVM-FS.</p> <p>(next: Motivation &amp; Goals of EESSI)</p>"},{"location":"using_eessi/basic_commands/","title":"Basic commands","text":""},{"location":"using_eessi/basic_commands/#basic-commands-to-access-software-provided-via-eessi","title":"Basic commands to access software provided via EESSI","text":"<p>EESSI provides software through environment module files and Lmod.</p> <p>To see which modules (and extensions) are available, run:</p> <pre><code>module avail\n</code></pre> <p>Below is a short excerpt of the output produced by <code>module avail</code>, showing 10 modules only. <pre><code>   PyYAML/5.3-GCCcore-9.3.0\n   Qt5/5.14.1-GCCcore-9.3.0\n   Qt5/5.15.2-GCCcore-10.3.0                               (D)\n   QuantumESPRESSO/6.6-foss-2020a\n   R-bundle-Bioconductor/3.11-foss-2020a-R-4.0.0\n   R/4.0.0-foss-2020a\n   R/4.1.0-foss-2021a                                      (D)\n   re2c/1.3-GCCcore-9.3.0\n   re2c/2.1.1-GCCcore-10.3.0                               (D)\n   RStudio-Server/1.3.1093-foss-2020a-Java-11-R-4.0.0\n</code></pre></p> <p>Load modules with <code>module load package/version</code>, e.g., <code>module load R/4.1.0-foss-2021a</code>, and try out the software. See below for a short session</p> <pre><code>[EESSI 2023.06] $ module load R/4.1.0-foss-2021a\n[EESSI 2021.06] $ which R\n/cvmfs/software.eessi.io/versions/2021.12/software/linux/x86_64/intel/skylake_avx512/software/R/4.1.0-foss-2021a/bin/R\n[EESSI 2023.06] $ R --version\nR version 4.1.0 (2021-05-18) -- \"Camp Pontanezen\"\nCopyright (C) 2021 The R Foundation for Statistical Computing\nPlatform: x86_64-pc-linux-gnu (64-bit)\n\nR is free software and comes with ABSOLUTELY NO WARRANTY.\nYou are welcome to redistribute it under the terms of the\nGNU General Public License versions 2 or 3.\nFor more information about these matters see\nhttps://www.gnu.org/licenses/.\n</code></pre>"},{"location":"using_eessi/building_on_eessi/","title":"Building software on top of EESSI","text":""},{"location":"using_eessi/building_on_eessi/#building-software-on-top-of-eessi-with-easybuild","title":"Building software on top of EESSI with EasyBuild","text":"<p>Building on top of EESSI with EasyBuild is relatively straightforward. One crucial feature is that EasyBuild supports building against operating system libraries that are not in a standard prefix (such as <code>/usr/lib</code>). This is required when building against EESSI, since all of the software in EESSI is built against the compatibility layer.</p>"},{"location":"using_eessi/building_on_eessi/#starting-the-eessi-software-environment","title":"Starting the EESSI software environment","text":"<p>Start your environment as described here</p>"},{"location":"using_eessi/building_on_eessi/#using-the-eessi-extend-module","title":"Using the EESSI-extend module","text":"<p>The <code>EESSI-extend</code> module facilitates building on top of EESSI using EasyBuild. It does a few key things:</p> <ol> <li>It configures EasyBuild to match how the rest of the EESSI software is built</li> <li>It configures EasyBuild to use a certain installation path (e.g. in your homedir), taking into account the hardware architecture you are building on</li> <li>It adds the relevant subdirectory from your installation path to your <code>MODULEPATH</code>, to make sure your newly installed modules are available</li> <li>It loads the EasyBuild module</li> </ol> <p>The <code>EESSI-extend</code> module recognizes a few environment variables. To print an up-to-date list, check the module itself <pre><code>module help EESSI-extend/2023.06-easybuild\n</code></pre></p> <p>The installation prefix is determined by <code>EESSI-extend</code> through the following logic:</p> <ol> <li>If <code>$EESSI_CVMFS_INSTALL</code> is set, software is installed in <code>$EESSI_SOFTWARE_PATH</code>. This variable shouldn't be used by users and would only be used by CVMFS administrators of the EESSI repository.</li> <li>If <code>$EESSI_SITE_INSTALL</code> is set, the EESSI site installation prefix (<code>$EESSI_SITE_SOFTWARE_PATH</code>) will be used. This is typically where sites hosting a system that has EESSI deployed would install additional software on top of EESSI and make it available to all their users.</li> <li>If <code>$EESSI_PROJECT_INSTALL</code> is set (and <code>$EESSI_USER_INSTALL</code> is not set), this prefix will be used. You should use this if you want to install additional software on top of EESSI that should also be usable by your project partners on the same system. For example, if you have a project space at <code>/project/my_project</code> that all your project partners can access, you could set <code>export EESSI_PROJECT_INSTALL=/project/my_project/eessi</code>. Make sure that this directory has the SGID permission set (<code>chmod g+s $EESSI_PROJECT_INSTALL</code>). This way, all the additional installations done with <code>EESSI-extend</code> will be put in that prefix, and will get the correct UNIX file permissions so that all your project partners can access it.</li> <li>If <code>$EESSI_USER_INSTALL</code> is set, this prefix will be used. You should use this if you want to install additional software on top of EESSI just for your own user. For example, you could set <code>export EESSI_USER_INSTALL=$HOME/my/eessi/extend/prefix</code>, and <code>EESSI-extend</code> will install all software in this prefix. Unix file permissions will be set such that these installations will be readable only to the user.</li> </ol> <p>If none of the above apply, the default is a user installation in <code>$HOME/EESSI</code> (i.e. effectively the same as setting <code>EESSI_USER_INSTALL=$HOME/EESSI</code>).</p> <p>Here, we assume you are just an end-user, not having set any of the above environment variables, and loading the <code>EESSI-extend</code> module with the default installation prefix:</p> <pre><code>module load EESSI-extend/2023.06-easybuild\n</code></pre> <p>Now, if we check the EasyBuild configuration</p> <pre><code>eb --show-config\nallow-loaded-modules (E) = EasyBuild, EESSI-extend\nbuildpath            (E) = /tmp/&lt;user&gt;/easybuild/build\ncontainerpath        (E) = /tmp/&lt;user&gt;/easybuild/containers\ndebug                (E) = True\nexperimental         (E) = True\nfilter-deps          (E) = Autoconf, Automake, Autotools, binutils, bzip2, DBus, flex, gettext, gperf, help2man, intltool, libreadline, libtool, M4, makeinfo, ncurses, util-linux, XZ, zlib\nfilter-env-vars      (E) = LD_LIBRARY_PATH\nhooks                (E) = /cvmfs/software.eessi.io/versions/2023.06/init/easybuild/eb_hooks.py\nignore-osdeps        (E) = True\ninstallpath          (E) = /home/&lt;user&gt;/eessi/versions/2023.06/software/linux/x86_64/amd/zen2\nmodule-extensions    (E) = True\npackagepath          (E) = /tmp/&lt;user&gt;/easybuild/packages\nprefix               (E) = /tmp/&lt;user&gt;/easybuild\nread-only-installdir (E) = True\nrepositorypath       (E) = /tmp/&lt;user&gt;/easybuild/ebfiles_repo\nrobot-paths          (D) = /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen2/software/EasyBuild/4.9.4/easybuild/easyconfigs\nrpath                (E) = True\nsourcepath           (E) = /tmp/&lt;user&gt;/easybuild/sources\nsticky-bit           (E) = True\nsysroot              (E) = /cvmfs/software.eessi.io/versions/2023.06/compat/linux/x86_64\ntrace                (E) = True\numask                (E) = 077\nzip-logs             (E) = bzip2\n</code></pre> <p>Apart from the <code>installpath</code>, this is exactly how EasyBuild is configured when software is built for EESSI itself.</p> <p>Note</p> <p>Be aware that <code>EESSI-extend</code> will optimize the installation for your current hardware architecture, and the <code>installpath</code> also contains this architecture in it's directory structure (just like regular EESSI installations do). This means you should run the installation on the node type on which you also want to use the software. If you want the installation to be present for multiple node types, you can simply run it once on each type of node.</p> <p>And, if we check our <code>MODULEPATH</code>, we see that the <code>installpath</code> that EasyBuild will use here is prepended <pre><code>$ echo $MODULEPATH\n/home/&lt;user&gt;/eessi/versions/2023.06/software/linux/x86_64/amd/zen2/modules/all:...\n</code></pre></p>"},{"location":"using_eessi/building_on_eessi/#building","title":"Building","text":"<p>Now, you are ready to build. For example, suppose you want to install <code>netcdf4-python-1.6.5-foss-2023b.eb</code> (which is not present at the time of writing), you run:</p> <pre><code>eb netcdf4-python-1.6.5-foss-2023b.eb\n</code></pre> <p>Note</p> <p>If this netCDF for python module is available by the time you are trying, you can force a local rebuild by adding the <code>--rebuild</code> argument in order to experiment with building locally, or pick a different EasyConfig to build.</p>"},{"location":"using_eessi/building_on_eessi/#using-the-newly-built-module","title":"Using the newly built module","text":"<p>If the installation was done in the site installation path (i.e. <code>EESSI_SITE_INSTALL</code> was set, and things were installed in <code>/cvmfs/software.eessi.io/host_injections/...</code>), the modules are available by default to anyone who has initialized the EESSI software environment.</p> <p>If the installation through <code>EESSI-extend</code> was done in a <code>EESSI_PROJECT_INSTALL</code> or <code>EESSI_USER_INSTALL</code> location, one has to make sure to load the <code>EESSI-extend</code> module before loading the module of interest, since this adds those prefixes to the <code>MODULEPATH</code>.</p> <p>If we don't have the <code>EESSI-extend</code> module loaded, it will not find any modules installed in the <code>EESSI_PROJECT_INSTALL</code> or <code>EESSI_USER_INSTALL</code> locations: <pre><code>$ module unload EESSI-extend\n$ module av netcdf4-python/1.6.5-foss-2023b\nNo module(s) or extension(s) found!\n</code></pre></p> <p>But, if we load <code>EESSI-extend</code> first:</p> <pre><code>$ module load EESSI-extend/2023.06-easybuild\n$ module av netcdf4-python/1.6.5-foss-2023b\n\n---- /home/&lt;user&gt;/eessi/versions/2023.06/software/linux/x86_64/amd/zen2/modules/all ----\n   netcdf4-python/1.6.5-foss-2023b\n</code></pre> <p>This means you'll always need to load the <code>EESSI-extend</code> module if you want to use these modules (also, and particularly when you want to use them in a job script).</p>"},{"location":"using_eessi/building_on_eessi/#manually-building-software-on-top-of-eessi-without-easybuild","title":"Manually building software on top of EESSI (without EasyBuild)","text":"<p>Warning</p> <p>We are working on a module file that should make building on top of EESSI (without using EasyBuild) more straightforward, particularly when using <code>Autotools</code> or <code>CMake</code>. Right now, it is a little convoluted and requires you to have a decent grasp of * What a runtime dynamic linker (<code>ld-linux*.so</code>) is and does * How to influence the behaviour of the runtime linker with <code>LD_LIBRARY_PATH</code> * The difference between <code>LIBRARY_PATH</code> and <code>LD_LIBRARY_PATH</code></p> <p>As such, this documentation is intended for \"experts\" in the runtime linker and it's behaviour, and most cases are untested. Any feedback on this topic is highly appreciated. </p> <p>Building and running software on top of EESSI without EasyBuild is not straightforward and requires some considerations to take care of. </p> <p>It is expected that you will have loaded all of your required dependencies as modules from the EESSI environment. Since EESSI sets <code>LIBRARY_PATH</code> for all of the modules and the <code>GCC</code> compiler is configured to use the compat layer, there should be no additional configuration required to execute a standard build process. On the other hand, EESSI does not set <code>LD_LIBRARY_PATH</code> so, at runtime, the executable will need help finding the libraries that it needs to actually execute. The easiest way to circumvent this requirement is by setting the environment variable <code>LD_RUN_PATH</code> during compile time as well. With <code>LD_RUN_PATH</code> set, the program will be able to tell the dynamic linker to search in those paths when the program is being executed. </p> <p>EESSI uses a compatibility layer to ensure that it takes as few libraries from the host as possible. The safest way to make sure all libraries will point to the required locations in the compatibility layer (and do not leak in from the host operating system) is starting an EESSI prefix shell before building. To do this: </p> <ul> <li>First of all, load the environment by starting an EESSI shell as described here. </li> <li>Load all dependencies you need to build your software. You must use at least a toolchain from EESSI to compile it (<code>foss</code> is a good option as it will also   include MPI with OpenMPI and math libraries via FlexiBLAS/FFTW). </li> <li>Set manually <code>LD_RUN_PATH</code> to resolve libraries at runtime. <code>LIBRARY_PATH</code> should contain all the paths we need, and we also need to include the path to   <code>libstdc++</code> from our GCC installation to avoid picking up the one from the host:   <pre><code>    export LD_RUN_PATH=$LIBRARY_PATH:$EBROOTGCCCORE/lib64\n</code></pre></li> <li> <p>Compile and make sure the library resolution points to the EESSI stack. For this, <code>ldd</code> from compatibility layer and not <code>/usr/bin/ldd</code> should be used   when checking the binary.</p> </li> <li> <p>Run! </p> </li> </ul> <p>To exemplify this, take the classic MPI Hello World example code:</p> <pre><code>/*The Parallel Hello World Program*/\n#include &lt;stdio.h&gt;\n#include &lt;mpi.h&gt;\n\nint main(int argc, char **argv)\n{\n   int node;\n\n   MPI_Init(&amp;argc,&amp;argv);\n   MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);\n\n   printf(\"Hello World from MPI rank %d\\n\", rank);\n\n   MPI_Finalize();\n}\n</code></pre> <p>As described in the steps above, prepare the environment and load the required dependencies. For this case, we will use <code>gompi/2023b</code> as the toolchain to compile it.</p> <pre><code># Starting the environment\n$ source /cvmfs/software.eessi.io/versions/2023.06/init/bash\n\n# Loading the toolchain\n{EESSI 2023.06} $ module load gompi/2023b\n</code></pre> <p>Now, set the <code>LD_RUN_PATH</code> environment variable for all the libraries to point to the runtime libraries, then compile the code.</p> <pre><code># Setting LD_RUN_PATH\n{EESSI 2023.06}$ export LD_RUN_PATH=$LIBRARY_PATH:$EBROOTGCCCORE/lib64\n\n# Compile the code manually\n{EESSI 2023.06} $ mpicc -o HelloWorld mpi.c\n</code></pre> <p>This is the moment to check if the compiler picked all the libraries from the software and compatibility layer, not the host.</p> <p>Look at the difference on the library solving when using the compatibility layer ldd from the host one:</p> <pre><code># ldd from the compatibility layer, notice how all libraries are resolved from the software layer -&gt; \"/cvmfs/software.eessi.io/versions/2023.06/software\", the libc and the interpreter point to the compatibility layer, so all good to go!\n\n{EESSI 2023.06} $ ldd HelloWorld\n    linux-vdso.so.1 (0x00007ffce03af000)\n    libmpi.so.40 =&gt; /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/intel/skylake_avx512/software/OpenMPI/4.1.6-GCC-13.2.0/lib/libmpi.so.40 (0x00007fadd9e84000)\n    libc.so.6 =&gt; /cvmfs/software.eessi.io/versions/2023.06/compat/linux/x86_64/lib64/libc.so.6 (0x00007fadd9ca8000)\n[...]\n    libevent_pthreads-2.1.so.7 =&gt; /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/intel/skylake_avx512/software/libevent/2.1.12-GCCcore-13.2.0/lib64/libevent_pthreads-2.1.so.7 (0x00007fadd98f0000)\n    libm.so.6 =&gt; /cvmfs/software.eessi.io/versions/2023.06/compat/linux/x86_64/lib/../lib64/libm.so.6 (0x00007fadd9810000)\n    /cvmfs/software.eessi.io/versions/2023.06/compat/linux/x86_64/lib64/ld-linux-x86-64.so.2 (0x00007fadd9fab000)\n</code></pre> <p><pre><code># ldd from the host, even though the libraries point to the software layer, now the linker ld-linux-x86-64.so.2 from the compat layer directly points to \"/lib64/ld-linux-x86-64.so.2\" from the host to do the resolving, resulting in the GLIBC mismatch as libc is also resolved in the host and not the compat layer\n\n{EESSI 2023.06} $ /usr/bin/ldd HelloWorld\n./HelloWorld: /lib64/libc.so.6: version `GLIBC_2.36' not found (required by /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/intel/skylake_avx512/software/libevent/2.1.12-GCCcore-13.2.0/lib64/libevent_core-2.1.so.7)\n./HelloWorld: /lib64/libc.so.6: version `GLIBC_ABI_DT_RELR' not found (required by /cvmfs/software.eessi.io/versions/2023.06/compat/linux/x86_64/lib/../lib64/libm.so.6)\n    linux-vdso.so.1 (0x00007fffe4fd3000)\n    libmpi.so.40 =&gt; /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/intel/skylake_avx512/software/OpenMPI/4.1.6-GCC-13.2.0/lib/libmpi.so.40 (0x00007f1fdf571000)\n    libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f1fdf200000)\n    [...]\n    libevent_pthreads-2.1.so.7 =&gt; /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/intel/skylake_avx512/software/libevent/2.1.12-GCCcore-13.2.0/lib64/libevent_pthreads-2.1.so.7 (0x00007f1fdf420000)\n    libm.so.6 =&gt; /cvmfs/software.eessi.io/versions/2023.06/compat/linux/x86_64/lib/../lib64/libm.so.6 (0x00007f1fdeeb1000)\n    /cvmfs/software.eessi.io/versions/2023.06/compat/linux/x86_64/lib64/ld-linux-x86-64.so.2 =&gt; /lib64/ld-linux-x86-64.so.2 (0x00007f1fdf698000)\n</code></pre> Now is the moment of truth, if everything looks right when checking with ldd, you should be fine to run the program:</p> <p><pre><code>{EESSI 2023.06} $ mpirun -n 2 HelloWorld\nHello World from Node 0\nHello World from Node 1\n</code></pre> Even when closing the shell and restarting the environment, the libraries should point to the directories we set in <code>LD_RUN_PATH</code>, still, remember to load the required dependencies before running the binary.</p> <p>Warning</p> <p>RPATH should never point to a compatibility layer directory, only to software layer ones, as all resolving is done via the runtime linker (<code>ld-linux*.so</code>) that is shipped with EESSI, which automatically searches these locations.</p> <p>The biggest downside of this approach is that your executable becomes bound to the architecture you linked your libraries for, i.e., if you add to your executable RPATH a <code>libhdf5.so</code>compiled for <code>intel_avx512</code>, you will not be able to run that binary on a machine with a different architecture. If this is an issue for you, you should look into how EESSI itself organises the location of binaries and perhaps leverage the relevant environment variables (e.g., <code>EESSI_SOFTWARE_SUBDIR</code>).</p>"},{"location":"using_eessi/eessi_demos/","title":"Running EESSI demos","text":"<p>To really experience how using EESSI can significantly facilitate the work of researchers, we recommend running one or more of the EESSI demos.</p> <p>First, clone the <code>eessi-demo</code> Git repository, and move into the resulting directory:</p> <pre><code>git clone https://github.com/EESSI/eessi-demo.git\ncd eessi-demo\n</code></pre> <p>The contents of the directory should be something like this:</p> <pre><code>$ ls -l\ntotal 48\ndrwxrwxr-x 2 example users  4096 May 15 13:26 Bioconductor\ndrwxrwxr-x 2 example users  4096 May 15 13:26 ESPResSo\ndrwxrwxr-x 2 example users  4096 May 15 13:26 GROMACS\n-rw-rw-r-- 1 example users 18092 Dec  5  2022 LICENSE\ndrwxrwxr-x 2 example users  4096 May 15 13:26 OpenFOAM\n-rw-rw-r-- 1 example users   543 May 15 13:26 README.md\ndrwxrwxr-x 3 example users  4096 May 15 13:26 scripts\ndrwxrwxr-x 2 example users  4096 May 15 13:26 TensorFlow\n</code></pre> <p>The directories we care about are those that correspond to particular scientific software, like <code>Bioconductor</code>, <code>GROMACS</code>, <code>OpenFOAM</code>, <code>TensorFlow</code>, ...</p> <p>Each of these contains a <code>run.sh</code> script that can be used to start a small example run with that software. Every example takes a couple of minutes to run, even with limited resources only.</p>"},{"location":"using_eessi/eessi_demos/#example-running-tensorflow","title":"Example: running TensorFlow","text":"<p>Let's try running the TensorFlow example.</p> <p>First, we need to make sure that our environment is set up to use EESSI:</p> <pre><code>source /cvmfs/software.eessi.io/versions/2023.06/init/bash\n</code></pre> <p>Change to the <code>TensorFlow</code> subdirectory of the <code>eessi-demo</code> Git repository, and execute the <code>run.sh</code> script:</p> <pre><code>[EESSI 2023.06] $ cd TensorFlow\n[EESSI 2023.06] $ ./run.sh\n</code></pre> <p>Shortly after starting the script you should see output as shown below, which indicates that TensorFlow has started running:</p> <pre><code>Epoch 1/5\n   1875/1875 [==============================] - 3s 1ms/step - loss: 0.2983 - accuracy: 0.9140\nEpoch 2/5\n   1875/1875 [==============================] - 3s 1ms/step - loss: 0.1444 - accuracy: 0.9563\nEpoch 3/5\n   1875/1875 [==============================] - 3s 1ms/step - loss: 0.1078 - accuracy: 0.9670\nEpoch 4/5\n   1875/1875 [==============================] - 3s 1ms/step - loss: 0.0890 - accuracy: 0.9717\nEpoch 5/5\n   1875/1875 [==============================] - 3s 1ms/step - loss: 0.0732 - accuracy: 0.9772\n313/313 - 0s - loss: 0.0679 - accuracy: 0.9790 - 391ms/epoch - 1ms/step\n\nreal   1m24.645s\nuser   0m16.467s\nsys    0m0.910s\n</code></pre>"},{"location":"using_eessi/eessi_in_ci/","title":"Leveraging EESSI for Continuous Integration","text":"<p>EESSI is already available as both a GitHub Action and a GitLab CI/CD component, which means you can easily integrate it if you use continuous integration within those ecosystems.</p> <p>Note</p> <p>Both of these EESSI CI tools support the use of <code>direnv</code> to allow you to store your desired environment within a <code>.envrc</code> file within your repository. See the documentation of the individual tools for detailed usage.</p>"},{"location":"using_eessi/eessi_in_ci/#the-eessi-github-action","title":"The EESSI GitHub Action","text":"<p>The EESSI GitHub Action can be found on the GitHub Marketplace, at https://github.com/marketplace/actions/eessi. Below is a minimal example of how to leverage the action, for detailed usage please refer to the official action documentation.</p> <pre><code>name: Minimal usage\non: [push, pull_request]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: eessi/github-action-eessi@v3\n    - name: Test EESSI\n      run: |\n        module avail\n      shell: bash\n</code></pre>"},{"location":"using_eessi/eessi_in_ci/#the-eessi-gitlab-cicd-component","title":"The EESSI GitLab CI/CD component","text":"<p>The EESSI GitLab CI/CD component can be found in the GitLab CI/CD Catalog, at https://gitlab.com/explore/catalog/eessi/gitlab-eessi. Below is a minimal example of how to leverage the component, for detailed usage please refer to the official component documentation.</p> <pre><code>include:\n  - component: $CI_SERVER_FQDN/eessi/gitlab-eessi/eessi@1.0.5\n\nbuild:\n  stage: build\n  script:\n    - module spider GROMACS\n</code></pre>"},{"location":"using_eessi/setting_up_environment/","title":"Setting up your environment","text":"<p>In Unix-like systems, environment variables are used to configure the environment in which applications and scripts run. To set up EESSI, you need to configure a specific set of environment variables so that your operating system is aware that EESSI exists and is to be used. We have prepared a few automated approaches that do this for you: you can either load an EESSI environment module or <code>source</code> an initialisation script for <code>bash</code>.</p> <p>With any of the approaches below, the first time you use them they may seem to take a while as any necessary data is downloaded in the background from a Stratum 1 server (which is part of the CernVM-FS infrastructure used to distribute files for EESSI).</p>"},{"location":"using_eessi/setting_up_environment/#loading-an-eessi-environment-module","title":"Loading an EESSI environment module","text":"<p>There are a few different scenarios where you may want to set up the EESSI environment by loading an EESSI environment module. The simplest scenario is one where you do not already have a environment module tool on your system, in this case we configure the Lmod module tool shipped with EESSI and automatically load the EESSI environment module: <pre><code>source /cvmfs/software.eessi.io/versions/2023.06/init/lmod/bash\n</code></pre> This command configures Lmod for your system and automatically loads the <code>EESSI</code> module so that EESSI is immediately available to use. If you would like to see what environment variables the module sets, you can use <code>module show EESSI</code>.</p> <p> Your environment is now set up, you are ready to start running software provided by EESSI!</p> What if I don't use a <code>bash</code> shell? <p>The example above is shown for a <code>bash</code> shell but the environment module approach supports all the shells that Lmod itself supports (<code>bash</code>, <code>csh</code>, <code>fish</code>, <code>ksh</code>, <code>zsh</code>): <pre><code>source /cvmfs/software.eessi.io/versions/2023.06/init/lmod/bash\n</code></pre> <pre><code>source /cvmfs/software.eessi.io/versions/2023.06/init/lmod/csh\n</code></pre> <pre><code>source /cvmfs/software.eessi.io/versions/2023.06/init/lmod/fish\n</code></pre> <pre><code>source /cvmfs/software.eessi.io/versions/2023.06/init/lmod/ksh\n</code></pre> <pre><code>source /cvmfs/software.eessi.io/versions/2023.06/init/lmod/zsh\n</code></pre></p> What if I already have Lmod installed or another module tool is available on the system? <p>You can check if the module command is already defined for your system and what version it has with <pre><code>command -v module &amp;&amp; module --version\n</code></pre></p> <ol> <li> <p>If you are already using Lmod (modules based on Lua) with version &gt;= 8.6:</p> <p>In this case, we recommend resetting <code>$MODULEPATH</code>, because EESSI is not designed to mix modules coming from EESSI and from your system.</p> <pre><code>module unuse $MODULEPATH\nmodule use /cvmfs/software.eessi.io/init/modules\nmodule load EESSI/2023.06\n</code></pre> <p> Your environment is now set up, you are ready to start running software provided by EESSI!</p> </li> <li> <p>If you are using an Lmod with a version older than 8.6 or any other module tool utilizing <code>MODULEPATH</code> (e.g.,      Tcl-based Environment Modules):</p> <p>It is recommended to unset <code>$MODULEPATH</code> to prevent Lmod from attempting to build a cache for your module tree (as this can be very slow if you have a lot of modules). Again, unsetting the <code>$MODULEPATH</code> should be considered as a good idea in general so you do not mix local and EESSI modules. You then will need to initialise a compatible version of Lmod, for example the one shipped with EESSI: </p> <pre><code>unset MODULEPATH\nsource /cvmfs/software.eessi.io/versions/2023.06/init/lmod/bash\n</code></pre> <p> Your environment is now set up, you are ready to start running software provided by EESSI!</p> </li> </ol> <p>Why do we recommend to unset <code>MODULEPATH</code>?</p> <p>Unsetting the <code>$MODULEPATH</code> environment variable, which tells Lmod in which directories environment module files are available, may be necessary. The underlying reason to suggest this is that EESSI and your system are most likely based on two different operating system distributions - EESSI uses it's compatibility layer, your system almost certainly uses some other Linux distribution. If you can find a way to ensure that the software stacks from your site and EESSI do not mix (in particular when someone is building new software!), then this should be good enough.</p>"},{"location":"using_eessi/setting_up_environment/#sourcing-the-eessi-bash-initialisation-script","title":"Sourcing the EESSI <code>bash</code> initialisation script","text":"<p>This is supported exclusively for <code>bash</code> shell users. If you're using a different shell, please use the alternative approach</p> <p>You can to see what your current shell is with the command <code>echo $SHELL</code></p> <p>You can initialise EESSI (in a non-reversible way) by running the command:</p> <pre><code>source /cvmfs/software.eessi.io/versions/2023.06/init/bash\n</code></pre> <p>You should see the following output:</p> <pre><code>Found EESSI repo @ /cvmfs/software.eessi.io/versions/2023.06!\narchdetect says x86_64/amd/zen2  # (1)\narchdetect could not detect any accelerators\nUsing x86_64/amd/zen2 as software subdirectory.\nFound Lmod configuration file at /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen2/.lmod/lmodrc.lua\nFound Lmod SitePackage.lua file at /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen2/.lmod/SitePackage.lua\nUsing /cvmfs/software.eessi.io/host_injections/2023.06/software/linux/x86_64/amd/zen2 as the site extension directory for installations.\nUsing /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen2/modules/all as the directory to be added to MODULEPATH.\nUsing /cvmfs/software.eessi.io/host_injections/2023.06/software/linux/x86_64/amd/zen2/modules/all as the site extension directory to be added to MODULEPATH.\nFound libcurl CAs file at RHEL location, setting CURL_CA_BUNDLE\nInitializing Lmod...\nPrepending /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen2/modules/all to $MODULEPATH...\nPrepending site path /cvmfs/software.eessi.io/host_injections/2023.06/software/linux/x86_64/amd/zen2/modules/all to $MODULEPATH...\nEnvironment set up to use EESSI (2023.06), have fun!\n{EESSI 2023.06} [user@system ~]$  # (2)!\n</code></pre> <p>What is reported at <code>(1)</code> depends on the CPU architecture of the machine you are running the <code>source</code> command.</p> <p>At <code>(2)</code> is the prompt indicating that you have access to the EESSI software stack.</p> <p> Your environment is now set up, you are ready to start running software provided by EESSI!</p>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/archive/2024/","title":"2024","text":""}]}